\section{Estimating road speeds}
\label{sec:vehicle_speeds}

Now that we have estimated the necessary vehicle states and their respective trajectories, we are able to infer a vehicle's \emph{average speed} along the $\ell^\text{th}$ road segment, $\Vtt_{\ell}$. These estimates are used later to update the \emph{road network state} (\cref{cha:network_model}) and ultimately estimate arrival times (\cref{cha:prediction}).


Estimation of average road speed is perfomed by first computing the \emph{travel time} along each road segment as the bus traverses the network. To do so, we record the time when the vehicle starts and ends each segment, $\Vsegstart_\ell$ and $\Vsegend_\ell$, respectively, and simply take the difference to obtain the travel time in seconds. By using a particle filter, we simply record these values for each particle as it is transitioned to each new state. Finally, transforming to average speed uses the length of the segment, $\Tseglen_\ell$, in meters, and the standard speed formula (speed = distance / time):
\begin{equation}
\label{eq:vehicle_avg_speed}
\Vtt_\ell = \frac{\Tseglen_\ell}{\Vsegend_\ell - \Vsegstart_\ell}.
\end{equation}


Since estimating \cref{eq:vehicle_avg_speed} is straighforward for each individual particle, the posterior distribution of the vehicle's average travel time along segment $\ell$, given all observations up to and including time $\Vtime_k$, is again approximated using the Dirac measure,
\begin{equation}
\label{eq:pf_speed_dist}
p(\Vtt_\ell | \Vobs_{1:k}) \approx
\sum_{i=1}^\Np \Pwt_k \dirac(\Vtt_\ell - \Vtt\vi_\ell).
\end{equation}
In situations where only some of the particles have completed travel along a segment, we wait until the next iteration to re-check that all particles have completed it and, since start and end times are stored for each individual particle, we can still estimate average speed.



In order to explore the accuracy of the models presented in \cref{sec:vehicle_model}, a simple vehicle simulation was performed with known road speeds and involved tracking the vehicle along the route while ignoring bus stops. In a second simulation, the bus stopped at each stop, and the particle filter implemented the bus stop behaviour model. For each, we used three different sampling methods:
\begin{itemize}
\item uniform sampling with 10~second intervals;
\item uniform sampling with 30~second intervals; and
\item non-uniform sampling at nodes.
\end{itemize}
As mentioned in \cref{sec:vp_data}, the last of these is, in fact, a common feature of the Auckland Transport data; we discuss the complications further in \cref{sec:pf_implementation}. In each simulation, we implemented the three variations of the transition function: $\Vtrans_{A1}$, $\Vtrans_{A2}$, and $\Vtrans_{A3}$.



The posterior mean travel time was used
to examine the estimation accuracy of the models and compare them,
which is simple to calculate from the particle filter estimates of travel time by
the weighted mean of the sample,
\begin{equation}
\label{eq:pf_travel_time_mean}
\bar\Vtt_\ell =
\E{\Vtt_\ell | \Vobs_{1:k}} =
\sum_{i=1}^\Np \Pwt_k \Vtt\vi_\ell
\end{equation}


To evaluate and compare the estimation performance of the models, we use \gls{rmse} and \gls{mae}, which are defined in \cref{app:error-functions}.


\subsubsection{Simulation A: general vehicle model}
\label{sec:vehicle_sim_A}


<<sim1_gen,echo=FALSE,message=FALSE,cache=FALSE>>=
source("scripts/pf_simulation.R")
sim1 <- run_simulation()
s1 <- sim1$sim

segs <- lapply(1:nrow(s1$segments),
    function(i) s1$segments$distance[i] + c(0, s1$segments$length[i])
)
tt <- s1$segments$tt
fcap1 <- 'Simulated vehicle trajectory, with five road segments.'
fscap1 <- c(
    "The simulated data.",
    "10~s sampling.",
    "30~s sampling.",
    "Observations at bus stops and intersections."
)
simnames <- c("Uniform (10s)", "Uniform (30s)", "Waypoints")
@


The simulated data, shown in \cref{fig:sim1_graph1}, uses the transition model described by $\Vtrans_{A1}$ to simulate a vehicle trajectory, and uses several time point sampling methods: uniform sampling with high (\cref{fig:sim1_graph2}) and low (\cref{fig:sim1_graph3}) frequency, and non-uniform sampling (\cref{fig:sim1_graph4}), which is more in line with how the Auckland Transport data is collected.


The goal of the simulation is to estimate the average vehicle speeds along several road segments, as well as the associated uncertainty. The simulation was performed in R \citep{rcore} using $\Np = 2000$ particles per vehicle, and so the implementation is slightly different from the C++ one defined in \cref{sec:pf_implementation}.

<<sim1_graph,echo=FALSE,fig.height=2,fig.width=4,out.width=".49\\linewidth",fig.cap=fcap1,fig.subcap=fscap1,fig.ncol=2,warning=FALSE,message=FALSE>>=
p1 <- ggplot(s1$path, aes(time, distance)) +
    geom_hline(yintercept = s1$segments$distance[-1],
        lty = 2, colour = "gray") +
    theme_classic() +
    theme(panel.grid = element_blank()) +
    xlab('Time (s)') + ylab('Distance (m)') +
    ylim(0, max(s1$path$distance)) + xlim(0, max(s1$path$time))

p1 + geom_path()
p1 + geom_point(aes(t, x), data = s1$observations$high)
p1 + geom_point(aes(t, x), data = s1$observations$low)
p1 + geom_point(aes(t, x), data = s1$observations$waypoints)
@

<<sim1_pf,echo=FALSE,message=FALSE,warning=FALSE,fig.height=3,fig.width=8,out.width="\\linewidth",fig.cap="Simulation results for the three models (rows) applied to the data from three sampling methods (columns), using $\\Np=2000$ particles. The standard deviation of the particle travel times is represented as error bars, though in many cases the error is too small to display.">>=
S0 <- sim1$fits
S0 %>%
    filter(segment != "Segment 6") %>%
    mutate(
        xpos = as.numeric(as.factor(model)) +
            as.numeric(as.factor(segment)) / 15,
        obs = factor(obs, labels = c("Uniform (10s)", "Uniform (30s)", "Nodes"))
    ) %>%
    ggplot(aes(xpos, speed_estimate - avg_speed, colour = segment)) +
    geom_pointrange(
        aes(
            ymin = speed_estimate - avg_speed - speed_sd,
            ymax = speed_estimate - avg_speed + speed_sd
        ),
        shape = 19, size = 0.5
    ) +
    facet_grid( ~ obs,  scales = "free_y") +
    theme_classic() +
    theme(strip.background = element_blank()) +
    geom_hline(yintercept = 0, col = "gray", lty = 2) +
    ylab("Estimate - actual (m/s)") +
    scale_x_continuous(
        "Model",
        limits = c(0.5, 4.0),
        breaks = 1:3,
        labels = paste0("A", 1:3)
    ) +
    labs(colour = "")
@

<<sim1_pf_full,echo=FALSE,message=FALSE,warning=FALSE,fig.width=8,fig.height=8,fig.cap="Speed estimation results for 100 simulations. In each the vehicle trajectory is simulated using a different seed, and the speed estimate is taken as the mean of the particle speeds along each segment.">>=
# do the whole thing over and over again
library(parallel)
cl <- makeCluster(4L)
r <- clusterEvalQ(cl, source("scripts/pf_simulation.R"))

s00 <- pbapply::pblapply(1:100,
    function(seed) {
        run_simulation(seed = seed)
    },
    cl = cl
) %>%
    map("fits") %>%
    bind_rows() %>%
    mutate(
        model = factor(paste0("A", model)),
        obs = factor(obs, labels = c("Uniform (10s)", "Uniform (30s)", "Nodes"))
    )

stopCluster(cl)

s00 %>%
    filter(segment != "Segment 6") %>%
    ggplot(
        aes(
            avg_speed,
            speed_estimate - avg_speed,
            fill = segment,
            colour = segment
        )
    ) +
    geom_hline(yintercept = 0, colour = "gray") +
    geom_pointrange(
        aes(
            ymin = speed_estimate - avg_speed - speed_sd,
            ymax = speed_estimate - avg_speed + speed_sd
        ),
        shape = 19, size = 0.5
    ) +
    facet_grid(obs ~ model, scales = "free_y") +
    theme_classic() +
    theme(strip.background = element_blank()) +
    xlab("Actual speed (m/s)") +
    ylab("Estimate - Actual (m/s)") +
    labs(colour = "", fill = "")


s00 %>%
    filter(is.finite(speed_estimate) & segment != "Segment 6") %>%
    group_by(obs, model) %>%
    summarize(
        "RMSE (m/s)" = sqrt(
            mean(
                (speed_estimate - avg_speed)^2,
                na.rm = TRUE
            )
        ) %>%
            round(2),
        "MAE (m/s)" = round(
            mean(
                abs(speed_estimate - avg_speed),
                na.rm = TRUE
            ),
            2
        )
    ) %>%
    rename(
        "Sampling method" = obs,
        "Model" = model
    ) %>%
    kable(
        format = "latex",
        booktabs = TRUE,
        caption = "RMSE of average speed estimation",
        escape = FALSE,
        linesep = ""
    ) %>%
    kableExtra::row_spec(3, extra_latex_after = "\\midrule") %>%
    kableExtra::row_spec(6, extra_latex_after = "\\midrule")

@

The results of the simulation applied to the data displayed in \cref{fig:sim1_graph} is shown in \cref{fig:sim1_pf}. Under the high-frequency uniform sampling method, all models perform similarly with high precision (the errors are all close to zero) and accuracy (the uncertainty is small enough that it does not show up). For the low-frequency sampling, however, model A3 shows slightly better precision than A1 and A2. Finally, for sampling at nodes, the models all perform similarly except in their estimation of speed for segment 5, which A1 and A2 estimate with high uncertainty.


To further examine the comparative performance of the models, we repeated the simulation 100~times using the same segments and sampling points, but varying the underlying trajectory of the vehicle. From the results displayed in \cref{fig:sim1_pf_full}, the most obvious feature is the difficulty estimating the last segment: this would likely be improved by including a likelihood on arrival time (since, as it stands, the particles may arrive very early for the last stop and, since this is the end of the route, they stay there until the observation). Model A2 appears to estimate with higher precision than either of the others, particularly for the final segment. A1 has better accuracy, overall.



\subsubsection{Simulation B: bus stop model}
\label{sec:vehicle_sim_B}

In the previous simulation, we assumed the vehicle travelled along the route without stopping. Now, we add bus stopping behaviour to the model, as shown in \cref{fig:sim2_graph}. In the simulated data, the bus stops at all stops with an unknown dwell time, and we use $\pi=0.5$ for the stopping probability in the particle filter when estimating vehicle state. The sampling is the same as before: 10~second and 30~second rates, as well as observations at nodes (intersections and bus stops).


<<sim2_gen,echo=FALSE,message=FALSE>>=
source("scripts/pf_simulation.R")
sim2 <- run_simulation(include = "stops", pr_stop = 0.5,
    prefix = "simB_results")
s2 <- sim2$sim

segs <- lapply(1:nrow(s2$segments),
    function(i) s2$segments$distance[i] + c(0, s2$segments$length[i])
)
tt <- s2$segments$tt

fcap2 <- 'Simulated vehicle trajectory, with five road segments and three intermediate stops.'
fscap2 <- c(
    "The simulated data.",
    "10~s sampling.",
    "30~s sampling.",
    "Observations at bus stops and intersections."
)
@



<<sim2_graph,echo=FALSE,fig.height=2,fig.width=4,out.width=".49\\linewidth",fig.cap=fcap2,fig.subcap=fscap2,fig.ncol=2,warning=FALSE,message=FALSE>>=
p2 <- ggplot(s2$path, aes(time, distance)) +
    geom_hline(yintercept = s2$segments$distance[-1],
        lty = 2, colour = "gray") +
    geom_hline(yintercept = s2$stops$distance[-1],
        lty = 3, colour = "orangered") +
    theme_minimal() +
    theme(panel.grid = element_blank()) +
    xlab('Time (s)') + ylab('Distance (m)') +
    ylim(0, max(s2$path$distance)) + xlim(0, max(s2$path$time))

p2 + geom_path()
p2 + geom_point(aes(t, x), data = s2$observations$high)
p2 + geom_point(aes(t, x), data = s2$observations$low)
p2 + geom_point(aes(t, x), data = s2$observations$waypoints)
@


The results of the simulation are shown in \cref{fig:sim2_pf}, where we see somewhat similar results to before: the models perform similarly well under high-frequency uniform sampling, with lower precision under low-frequency sampling. For sampling at nodes, again we see the same issue with estimation of speed for the final segment, but otherwise the models perform similarly.

<<sim2_pf,echo=FALSE,message=FALSE,warning=FALSE,fig.height=3,fig.width=8,out.width="\\linewidth",fig.cap="Simulation results for the three models (rows) applied to the data from three sampling methods (columns), using $\\Np=2000$ particles. [details].">>=
S0 <- sim2$fits
S0 %>%
    filter(segment != "Segment 6") %>%
    mutate(
        xpos = as.numeric(as.factor(model)) +
            as.numeric(as.factor(segment)) / 15,
        obs = factor(obs, labels = c("Uniform (10s)", "Uniform (30s)", "Nodes"))
    ) %>%
    ggplot(aes(xpos, speed_estimate - avg_speed, colour = segment)) +
    geom_pointrange(
        aes(
            ymin = speed_estimate - avg_speed - speed_sd,
            ymax = speed_estimate - avg_speed + speed_sd
        ),
        shape = 19, size = 0.5
    ) +
    facet_grid( ~ obs,  scales = "free_y") +
    theme_classic() +
    theme(strip.background = element_blank()) +
    geom_hline(yintercept = 0, col = "gray", lty = 2) +
    ylab("Estimate - actual (m/s)") +
    scale_x_continuous(
        "Model",
        limits = c(0.5, 4.0),
        breaks = 1:3,
        labels = paste0("A", 1:3)
    ) +
    labs(colour = "")

@


Repeating the simulation 100~times with different vehicle trajectories, we can better compare the models (\cref{fig:sim2_pf_full}, which excludes the final segment). Uncertainties are now much higher, particularly under low-frequency sampling. Models A1 and A2 appear to perform similarly, and better estimate speed along slower segments, versus A3 which shows has difficulty even with slow segments.

<<sim2_pf_full,echo=FALSE,message=FALSE,warning=FALSE,fig.width=8,fig.height=8,fig.cap="Speed estimation results for 100 simulations. In each the vehicle trajectory is simulated using a different seed, and the speed estimate is taken as the mean of the particle speeds along each segment.">>=
library(parallel)
cl <- makeCluster(4L)
r <- clusterEvalQ(cl, source("scripts/pf_simulation.R"))

s00 <- pbapply::pblapply(1:100,
    function(seed) {
        run_simulation(seed = seed, include = "stops", pr_stop = 0.5,
            prefix = "simB_results")
    },
    cl = cl
) %>%
    map("fits") %>%
    bind_rows() %>%
    mutate(
        model = factor(paste0("A", model)),
        obs = factor(obs, labels = c("Uniform (10s)", "Uniform (30s)", "Nodes"))
    )

stopCluster(cl)

s00 <- s00 %>%
    filter(
        segment != "Segment 6" &
        is.finite(speed_estimate) &
        speed_estimate < 30
    )

s00 %>%
    ggplot(
        aes(
            avg_speed,
            speed_estimate - avg_speed,
            fill = segment,
            colour = segment
        )
    ) +
    geom_hline(yintercept = 0, colour = "gray") +
    geom_point() +
    # geom_pointrange(
    #     aes(
    #         ymin = speed_estimate - avg_speed - speed_sd,
    #         ymax = speed_estimate - avg_speed + speed_sd
    #     ),
    #     shape = 19, size = 0.5
    # ) +
    facet_grid(obs ~ model, scales = "free_y") +
    theme_classic() +
    theme(strip.background = element_blank()) +
    xlab("Actual speed (m/s)") +
    ylab("Estimate - Actual (m/s)") +
    labs(colour = "", fill = "")

s00 %>%
    group_by(obs, model) %>%
    summarize(
        "RMSE (m/s)" = sqrt(
            mean(
                (speed_estimate - avg_speed)^2,
                na.rm = TRUE
            )
        ) %>%
            round(2),
        "MAE (m/s)" = round(
            mean(
                abs(speed_estimate - avg_speed),
                na.rm = TRUE
            ),
            2
        )
    ) %>%
    rename(
        "Sampling method" = obs,
        "Model" = model
    ) %>%
    kable(
        format = "latex",
        booktabs = TRUE,
        caption = "RMSE of average speed estimation",
        escape = FALSE,
        linesep = ""
    ) %>%
    kableExtra::row_spec(3, extra_latex_after = "\\midrule") %>%
    kableExtra::row_spec(6, extra_latex_after = "\\midrule")

@



Comparing the estimates numerically using \gls{rmse} (\cref{tab:sim2_pf_full}) we see, within each sampling method, the errors are similar. Models A1 and A2 perform very similarly, while model A3 is consistently higher.
