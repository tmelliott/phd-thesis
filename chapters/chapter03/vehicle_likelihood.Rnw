\subsection{Likelihood}
\label{sec:pf-likelihood}

The second component of \gls{rbe} is the update step, which involves accounting for the likelihood of the data given the predicted state, $p(\Vobs_k | \Vstate_k)$. In the \pf{}, as discussed in \cref{sec:pf}, updating is performed by reweighting each of the particles based on their likelihoods, $p(\Vobs_k | \Vstate\vi_k)$, and then, if necessary, performing weighted resampling with replacement (importance resampling). That is,
\begin{equation}
\label{eq:vehicle_pf_update}
p(\Vstate_k | \Vobs_{1:k}) \approx
\sum_{i=1}^\Np
    \Pwt_{k}
    \dirac\left(
        \Vstate_k - \Vstate\vi_k
    \right)
\end{equation}
where
\begin{equation}
\label{eq:vehicle_pf_reweight}
\Pwt_k = \frac{
    \Pwt_{k-1} p(\Vobs_k | \Vstate\vi_k)
}{
    \sum_{j=1}^\Np \Pwt[j]_{k-1} p(\Vobs_k | \Vstate\vi[j]_k)
}
\end{equation}


The likelihood function is where the \pf{} is superior in this application. Were we to model the vehicle's state with a \kf{}, we would need to somehow compare a distribution in one dimension (distance travelled) with an observation in two dimensions (\gls{gps} coordinate). \cite{Cathey_2003} used an optimisation technique to obtain an estimated observation of distance travelled based on the observation location, which they then used as data for their \kf{} implementation. However, as demonstrated in \cref{fig:lhood_obs}, there are situations where the ``maximised'' location may be wrong, in which case the resulting state will be eroneous.


The \pf{} effectively checks to see how plausible the observation is assuming each particle is the truth, allowing us to weight each particle by its plausibility. Since there are two types of data, two likelihood functions are required: one for \GPS{} observations, and a second for trip updates. There is no need to match the observations to distance: instead, each particle's state can be transformed into a \gls{gps} coordinate, making it directly compariable to the vehicle's reported location.


\subsubsection{GPS vehicle locations}
\label{sec:lhood_gps}

<<lhood_obs,message=FALSE,echo=FALSE,fig.height=3,fig.width=8,fig.cap="Observations of vehicle on a simple path. The red points indicate the reported GPS positions, with circles indicating the GPS error associated with each observation. Observation Y1 is easy to map to the route, while Y2 is more complicated and has two plausible, distinct locations.",cache=TRUE>>=
# function from Y to X = h'(Y)
library(tidyverse)

# library(sf)
path <- tibble(
    lng = c(0.0, 0.5, 2.0, 2.5, 3.0, 2.5, 3.0, 4.0, 5.0),
    lat = c(0.0, 2.0, 3.0, 3.5, 3.0, 2.5, 1.5, 2.0, 2.0)
)

Y <- tibble(
    lng = c(0.5, 2.75),
    lat = c(1.5, 3.05),
    lab = paste0("Y", 1:2),
    match.lng = c(0.39, 2.825),
    match.lat = c(1.55, 3.175)
)

# pth <- st_linestring(path %>% as.matrix)
# pts <- st_point()

plh <- ggplot(path, aes(lng, lat)) +
    geom_path() +
    scale_x_continuous(breaks = NULL) + xlab("Longitude") +
    scale_y_continuous(breaks = NULL) + ylab("Latitude") +
    theme(panel.grid = element_blank()) +
    theme_minimal() +
    coord_fixed(0.5)
plh +
    geom_point(data = Y, col = "orangered") +
    geom_point(data = Y, col = "orangered", pch = 21, size = 15) +
    geom_text(aes(label = lab), data = Y, nudge_x = 0.1)
@



<<lhood_kf,eval=FALSE,echo=FALSE,fig.width=8,fig.height=2,fig.cap="Traditional \\kf{} update of the state.",fig.subcap=c("Observation is mapped to path (cross), and previous state in gray.", "Observation is projected into the state space, $Z_1 = H^{-1}Y_k$ (shown in red, width represents \"GPS error\"). The predicted state $X_{1|0}$ (in blue) calculated using the standard \\kf{} prediction step. Lower graph shows updated state $X_{1|1}$.", "The next observation is received and map matching used to find closest point on route (red cross); the updated state estimate from previous step is shown in gray.", "After projecting observation to the state space (red curve) and obtaining the predicted state (blue curve), the state can be updated.", "The final state is shown, but the state estimate is in neither of the road segments that were likely, which could be caused if the map matching was incorrect (i.e., it should have been matched to the other plausible point)."),fig.ncol=1,cache=TRUE>>=
# the state
X <- tibble(
    x = c(0, 20, 60),
    xhat = c(NA, 15, 50),
    p = c(5, 6, 15),
    phat = c(NA, 8, 20)
)

KF <- function(x, p, z, r) {
    k <- p / (r + p)
    c(x + k * (z - x), (1 - k)^2 * p + k^2 * r)
}
x0 <- c(10, 3)
z1 <- c(50, 5)
x1hat <- c(55, 4)
x1 <- KF(x1hat[1], x1hat[2], z1[1], z1[2])
z2 <- c(150, 5)
x2hat <- c(160, 10)
x2 <- KF(x2hat[1], x2hat[2], z2[1], z2[2])
X <- tibble(x = seq(0, 200, length = 1001)) %>%
    mutate(
        y_x0 = dnorm(x, x0[1], x0[2]),
        y_z1 = dnorm(x, z1[1], z1[2]),
        y_x1hat = dnorm(x, x1hat[1], x1hat[2]),
        y_x1 = dnorm(x, x1[1], x1[2]),
        y_z2 = dnorm(x, z2[1], z2[2]),
        y_x2hat = dnorm(x, x2hat[1], x2hat[2]),
        y_x2 = dnorm(x, x2[1], x2[2])
    )

vs <- ggplot(X, aes(x = x)) +
    geom_segment(aes(x = 0, xend = max(X$x), y = 0, yend = 0), lwd = 0.2) +
    theme(panel.grid = element_blank()) +
    theme_minimal() +
    scale_y_continuous(breaks = NULL) + ylab("") +
    scale_x_continuous(breaks = NULL) + xlab("Distance travelled (m)")

plh + geom_point(data = Y[1,], col = "orangered") +
    geom_point(aes(match.lng, match.lat),
        data = Y[1,], col = "orangered", shape = 4) +
    geom_point(aes(x = 0.5/4, y = 2/5),
        data = NULL, colour = "gray")

egg::ggarrange(
    vs +
        geom_area(aes(y = y_x0), fill = "gray") +
        geom_area(aes(y = y_z1), fill = "orangered", alpha = 0.5) +
        geom_area(aes(y = y_x1hat), fill = "steelblue", alpha = 0.5) +
        annotate(geom = "text", x = x0[1] - 8, y = max(X$y_x0) * 0.9,
            label = "X[0]", parse = TRUE, size = 5) +
        annotate(geom = "text", x = z1[1] - 5, y = max(X$y_z1) * 1.1,
            label = "Z[1]", parse = TRUE, size = 5) +
        annotate(geom = "text", x = x1hat[1] + 7, y = max(X$y_x1hat) * 1.1,
            label = "X[1*group('|',0,'.')]", parse = TRUE, size = 5),
    vs +
        geom_area(aes(y = y_x1), fill = "gray") +
        annotate(geom = "text", x = x1[1] + 8, y = max(X$y_x1) * 0.8,
            label = "X[1*group('|',1,'.')]", parse = TRUE, size = 5),
    ncol = 1
)

plh +
    geom_point(data = Y[1,], col = "orangered") +
    geom_point(data = Y[2,], col = "orangered") +
    geom_point(aes(match.lng, match.lat),
        data = Y[2,], col = "orangered", shape = 4) +
    geom_point(aes(x = 0.4, y = 1.56),
        data = NULL, colour = "gray")

egg::ggarrange(
    vs +
        geom_area(aes(y = y_x1), fill = "gray") +
        geom_area(aes(y = y_z2), fill = "orangered", alpha = 0.5) +
        geom_area(aes(y = y_x2hat), fill = "steelblue", alpha = 0.5) +
        annotate(geom = "text", x = x1[1] - 5, y = max(X$y_x1) * 0.9,
            label = "X[1]", parse = TRUE, size = 5) +
        annotate(geom = "text", x = z2[1] - 5, y = max(X$y_z2) * 1.3,
            label = "Z[2]", parse = TRUE, size = 5) +
        annotate(geom = "text", x = x2hat[1] + 7, y = max(X$y_x2hat) * 1.4,
            label = "X[2*group('|',1,'.')]", parse = TRUE, size = 5),
    vs +
        geom_area(aes(y = y_x2), fill = "gray") +
        annotate(geom = "text", x = x2[1] + 8, y = max(X$y_x2) * 0.8,
            label = "X[2*group('|',2,'.')]", parse = TRUE, size = 5),
    ncol = 1
)

plh +
    geom_point(data = Y[1,], col = "orangered") +
    geom_point(data = Y[2,], col = "orangered") +
    geom_point(aes(x = 2.97, y = 2.97),
        data = NULL, colour = "gray")

@

For the \gls{gps} location update, the inherent \gls{gps} error, $\GPSerr$, needs to be filtered out to get better estimates of vehicle state. Examples of positions are shown in \cref{fig:lhood_obs}. A particle's likelihood should represent the geographical \emph{closeness} of the estimated position to the vehicle's reported position. We therefore want the likelihood to depend on the \emph{distance between the observed and predicted} vehicle locations. The first step to computing the likelihood is therefore
to calculate the GPS position of the \emph{particle}, $\Ppos\vi_k$, by using the \emph{measurement function},
\begin{equation}
\label{eq:pf_measurement_fun}
\Ppos\vi_k = \Vmeas(\Vstate\vi_k, \ShapePath)
\end{equation}
which is simply a deterministic function given the route's path, $\ShapePath$, which is a sequence of latitude-longitude pairs and the cumulative distance along the line. Once the geographical position of the particle is obtained, it is compared to the observed vehicle location, as shown in \cref{fig:gps_dist}.

<<gps_dist,echo=FALSE,message=FALSE,cache=TRUE,fig.width=8,fig.height=4,out.width="0.8\\textwidth",fig.align="center",fig.cap="GPS distance between two points. The vehicle's reported location is shown in orange; one particle estimate of it's location is in black. The desired distance is denoted by the red line.">>=
library(ggmap)

Yx <- tibble(
    lat = c(-36.853634, -36.852870),
    lng = c(174.768615, 174.769481)
)

xr <- extendrange(range(Yx$lng), f = 2)
yr <- extendrange(range(Yx$lat), f = 0.6)
bbox <- c(xr[1], yr[1], xr[2], yr[2])
get_stamenmap(bbox, zoom = 18, maptype = "toner-background") %>%
    ggmap() +
    geom_point(aes(lng, lat), data = Yx,
        colour = c("black", "orangered"), size = 5) +
    geom_segment(aes(lng, lat, xend = Yx$lng[1], yend = Yx$lat[1]),
        data = Yx[2,], position = position_nudge(x = 0.00008, y = -0.00006),
        colour = "red",
        arrow = arrow(angle = 90, length = unit(0.01, 'native'), ends = "both")) +
    theme_nothing()
@

Computing the distance between two GPS coordinates can achieved using several formulae, each with varying levels of accuracy. Since all of the distances are going to be (very) small, the \emph{Equirectangular projection} is sufficiently accurate for computing geographical distances \citep{cn}. This projection transforms the point $\Vobs_1 = \tvec{\Vlon_1, \Vlat_1}$, where latitude $\Vlat$ and longitude $\Vlon$ are in radians (the width of one longitudinal radian depends on latitude) onto a surface with meters on both axes, centered on the point $\Vobs_0 = \tvec{\Vlon_0, \Vlat_0}$ and using the Earth's radius $R = 6.371 \times 10^6$m,
\begin{equation}
\label{eq:equirectangular_projection}
\Vproj{\Vobs_1}{\Vobs_0} =
\begin{bmatrix} x \\ y \end{bmatrix} =
R \begin{bmatrix}
(\Vlon_1 - \Vlon_0) \cos \Vlat_0 \\
(\Vlat_1 - \Vlat_0)
\end{bmatrix}
\end{equation}
so that the distance between the points can easily be computed
using their \emph{euclidean distance}
\begin{equation}
\label{eq:obs_dist}
\dist{\Vobs_0, \Vobs_1} = \sqrt{x^2 + y^2}.
\end{equation}
This is shown visually in \cref{fig:gps_projection}.
Note that conversion from degrees to radians is achieved by
multiplying degrees by $\frac{\pi}{180}$.

<<gps_projection,echo=FALSE,message=FALSE,cache=TRUE,fig.width=4,fig.height=3.5,out.width="0.49\\textwidth",fig.align="center",fig.cap="Equirectangular projection of GPS coordinates onto flat surface, allowing the distance from each particle to the observed location to easily be calculated.",fig.subcap=c("GPS coordinates","Projected points")>>=
xr <- extendrange(range(Yx$lng), f = 0.2)

ggplot(Yx, aes(lng, lat)) +
    geom_point(colour = c("black", "orangered"), size = 2) +
    coord_fixed(cos(Yx$lat[2] * pi / 180)) +
    theme_minimal() + theme(panel.grid = element_blank()) +
    xlab("Longitude (degrees)") + ylab("Latitude (degrees)") +
    xlim(xr[1], xr[2]) + ylim(yr[1], yr[2])

R <- 6371000
Lng <- Yx$lng * pi / 180
Lat <- Yx$lat * pi / 180
Yx <- Yx %>%
    mutate(
        x = (Lng - Lng[1]) * cos(Lat[1]) * R,
        y = (Lat - Lat[1]) * R
    )


xr <- c(-50, 100)
yr <- c(-50, 100)
ggplot(Yx, aes(x, y)) +
    geom_hline(yintercept = 0, lty = 3) +
    geom_vline(xintercept = 0, lty = 3) +
    geom_segment(aes(xend = 0, yend = y),
        data = Yx[2, ], col = "red", lty = 2) +
    geom_segment(aes(xend = x, yend = 0),
        data = Yx[2, ], col = "red", lty = 2) +
    geom_point(colour = c("black", "orangered"), size = 2) +
    coord_fixed(1) +
    theme_minimal() + theme(panel.grid = element_blank()) +
    ylab("North-South (meters)") + xlab("West-East (meters)") +
    xlim(xr[1], xr[2]) + ylim(yr[1], yr[2])
@


Now that spherical observations can be compared on a flat surface,
it is necessary to assume that \GPS{} observations are distributed
as a multivariate random variable around the true position of the vehicle
on the ground,
with a \GPS{} error of $\GPSerr$,
and that the variation does not depend on direction.
That is, if the observation $\Vobs_k$ is projected using
\cref{eq:equirectangular_projection} conditional on the true position
$\Vmeas(\Vstate_k)$,
then the projected point will be a multivariate random variable
$\vec{r}_k \sim \Normal{\vec{0}}{\GPSerr \mat{I}}$.
The above, shown in \cref{fig:gps_error2},
can more simply be expressed by
\begin{equation}
% \label{eq:obs_projection}
\label{eq:gps_error_model}
\Vproj{\Vobs_k}{\Vmeas(\Vstate_k)} =
    \Vproj{\Vmeas(\Vstate_k)}{\Vmeas(\Vstate_k)} + \vec{r}_k
    = \vec{r}_k
\end{equation}

% \begin{equation}
% \Vobs_k = \Viproj{\vec{r}\vi_k}{\Vmeas(\Vstate\vi_k)}.
% \end{equation}

<<gps_error,echo=FALSE,message=FALSE,cache=TRUE,fig.width=4,fig.height=4,out.width="0.49\\textwidth",fig.align="center",fig.cap="GPS error is assumed to be circular on a map.",fig.subcap=c("GPS map error", "Projected error")>>=
xr <- Yx$lng[1] + 0.002 * c(-1, 1)
yr <- Yx$lat[1] + 0.001 * c(-1, 1)
bbox <- c(xr[1], yr[1], xr[2], yr[2])
get_stamenmap(bbox, zoom = 18, maptype = "toner-background") %>%
    ggmap() +
    geom_point(aes(lng, lat), data = Yx,
        colour = c("black", "orangered"), size = 5) +
    geom_point(aes(lng, lat), data = Yx[1,],
        colour = "black", size = 45, shape = 21, fill = "transparent") +
    theme_nothing()


xr <- c(-50, 120)
yr <- c(-50, 120)
ggplot(Yx, aes(x, y)) +
    geom_hline(yintercept = 0, lty = 3) +
    geom_vline(xintercept = 0, lty = 3) +
    geom_point(colour = c("black", "orangered"), size = 5) +
    geom_point(data = Yx[1,], colour = "black", size = 65,
        shape = 21, fill = "transparent") +
    coord_fixed(1) +
    theme_minimal() + theme(panel.grid = element_blank()) +
    ylab("North-South (meters)") + xlab("West-East (meters)") +
    xlim(xr[1], xr[2]) + ylim(yr[1], yr[2])
@


From \cref{eq:equirectangular_projection,eq:obs_dist,eq:gps_error_model}
the distance between the true and observed locations
is the magnitude of the error $\vec{r}_k$,
\begin{equation}
\dist{\Vobs_k, \Vmeas(\Vstate_k)} = ||\vec{r}_k|| =
    \sqrt{r_{k1}^2 + r_{k2}^2}
\end{equation}
However, this error can also be expressed in terms of two independent,
standard normal random variables $z_1, z_2 \sim \Normal{0}{1}$,
such that $r_{jk} = \GPSerrSD z_j$ for $j = 1, 2$,
resulting in
\begin{equation}
\dist{\Vobs_k, \Vmeas(\Vstate\vi_k)} =
    \sqrt{(\GPSerrSD z_1)^2 + (\GPSerrSD z_2)^2} =
    \GPSerrSD \sqrt{z_1^2 + z_2^2}
\end{equation}
Since the distribution of two squared standard normal random variables is known
to be $\chi^2$ distributed with 2~degrees of freedom,
which is itself exponential with rate 0.5
\citep{cn},
then
\begin{equation}
\label{eq:sum_sq_dist}
z_1^2 + z_2^2 \sim \Exp{\frac{1}{2}}
\end{equation}
which, following the [fact] that if $X \sim \Exp{\theta}$,
then $cX \sim \Exp{\frac{\theta}{c}}$,
the squared distance between points is simply represented as
\begin{equation}
\label{eq:distance_distrib}
\dist{\Vobs_k, \Vmeas(\Vstate_k)}^2 \sim \Exp{\frac{1}{2\GPSerr}}
\end{equation}

So now, given a particle state estimate of $\Vstate\vi_k$,
the likelihood of a \GPS{} observation using only
the distance between two coordinates is given by
\begin{equation}
\label{eq:particle_lh_fun}
p(\Vobs_k | \Vstate\vi_k) =
    \frac{1}{2\GPSerr} \exp\left\{
        - \frac{\dist{\Vobs_k, \Vmeas(\Vstate\vi_k)}^2}{2\GPSerr}
    \right\}
\end{equation}
allowing the particles to be reweighted using \cref{eq:vehicle_pf_reweight}.
This is shown visually in \cref{fig:pf_wts}.


<<pf_wts,echo=FALSE,message=FALSE,cache=TRUE,fig.width=8,fig.height=3,fig.align="center",fig.cap="The \\pf{} estimate of vehicle state after reweighting particles based on the likelihood, or distance from the observed location.",fig.ncol=1>>=
proj <- function(x, path) {
    d <- c(0, path %>% as.matrix %>%
        apply(2, diff) %>%
        apply(1, "^", 2) %>%
        colSums %>% sqrt %>% cumsum)
    if (x <= 0) return(path[1, ] %>% as.numeric)
    if (x >= max(d)) return(path[nrow(path), ] %>% as.numeric)
    i <- which(d > x)[1]
    # from i-1:i
    if (x == d[i]) return(path[i, ])
    p1 <- path[i, ] %>% as.numeric
    p2 <- path[i-1, ] %>% as.numeric
    b <- geosphere::bearing(p1, p2, a = 0, f = 0) * pi / 180
    h <- d[i] - x
    p1 + c(sin(b) * h, cos(b) * h)
}

set.seed(10)
dx <- runif(10, 1.2, 2.1)
dy <- t(sapply(dx, proj, path = path))
colnames(dy) <- c("x", "y")
dy <- as_tibble(dy)

# plh +
#     geom_point(data = Y[1,], col = "orangered") +
#     geom_point(aes(x, y), data = dy, col = "black")

wt <- rep(1 / length(dx), length(dx))
dxY <- apply(dy, 1, function(x) sqrt(sum((x - Y[1,c('lng', 'lat')])^2)))
wt <- wt * dexp(dxY, 5)
wt <- wt / sum(wt)

plh +
    geom_point(data = Y[1,], col = "orangered") +
    geom_point(aes(x, y), data = dy, col = "black",
        size = wt * length(wt) * 2)

@


\subsubsection{Trip updates}
\label{sec:lhood_trip}

As well as vehicle position updates from \GPS{} data, \GTFS{} provides trip updates from arrival and departure information. In many situations, it is difficult to infer a vehicle's trajectory based solely on \GPS{} data, and so trip updates are therefore an invaluable part of the update step. In this case, the \pf{} prediction step goes ahead as presented in \cref{sec:vehicle_model_trans}, but instead of then comparing the coordinates, the arrival or departure times are used to compute the liklelihood of the particles.


The trip update observations differ from the \GPS{} observations in that there are now three situations which can occur. The observation can be of an arrival time at stop $m$, $\Varr_m$, or it can be of a departure time, $\Vdep_m$. In the latter case, treatment of the observations depends on whether or not $\Varr_m$ was observed. This gives us three likelihood functions to derive,
\begin{itemize}
\item $p(\Varr_m | \Vstate_k)$, the arrival time likelihood function,
\item $p(\Vdep_m | \Vstate_k, \text{arrival missing})$, the departure time likelihood conditional
    on not having observed arrival time, and
\item $p(\Vdep_m | \Vstate_k, \text{arrival observed})$, the departure time likleihood conditional
    on having observed arrival time.
\end{itemize}


To compute the likelihood for these, we refer back to the dwell time model described in \cref{eq:stop_dwell_model,eq:stop_dwell_time}. Two additional parameters are also needed: the actual arrival time of the bus at stop $m$, $\Tarr_{m}$, and the measurement error of arrival time in seconds, $\TUerr$. The arrival time can be computed for each stop $m$ directly from the model (i.e., via interpolation). The departure time is then computed by summing the arrival and dwell times.


The observed arrival and departured times, denoted $\Varr_m$ and $\Vdep_m$, respectively, are assumed to each be normally distributed, with mean and variance determined by the described model. For arrival time, this is simply
\begin{equation}
\label{eq:tu_arr_lhood}
\Varr_m \sim \Normal{\Tarr_{mr}}{\TUerr}.
\end{equation}
and for departure time,
\begin{equation}
\label{eq:tu_dep_lhood}
\Vdep_m \sim \Normal{\Tarr_m + \pdwell_m}{\TUerr}
\end{equation}


In our \pf{} implementation, each observation will be processed individually; in situations where more than one type of observation is recieved, they are processed in chronological order and the particles reweighted between each. The necessary likelihood component for \cref{eq:vehicle_pf_reweight} is therefore
\begin{equation}
\label{eq:tu_obs_lhood}
p(\Vobs_k | \Vstate\vi_k) =
\begin{cases}
\frac{1}{\sqrt{2\pi\TUerr}}
    \exp\left\{
        -\frac{(\Varr_m - \Tarr_m)^2}{2\TUerr}
    \right\} & \text{for arrival times} \\
\frac{1}{\sqrt{2\pi\TUerr}}
    \exp\left\{
        -\frac{(\Vdep_m - \Tarr\vi_m - \pdwell\vi_m)^2}{2\TUerr}
    \right\} & \text{for departure times}
\end{cases}
\end{equation}
which allows the particle sample to be reweighted according to the temporal difference in arrival and departure times. This is demonstrated in \cref{fig:tu_update}.

<<tu_update,echo=FALSE,fig.width=8,fig.height=4,out.width="0.8\\textwidth",fig.align="center",fig.cap="Particle likelihoods based on stop arrival time.">>=

plot(1:10)

@