\Sexpr{set_parent('particle_filter.Rnw')}

\section{Real-time vehicle model}
\label{sec:vehicle_model}

Transit vehicle behaviour is both predictable and volatile.
The trajectory of a bus servicing a trip is known,
so the direction of travel---a major component in vehicle tracking---%
is a non-issue.
Instead, the main parameter of interest is the vehicle's speed,
with which we can determine information about the congestion along roads.


In this section, we describe the mechanics of bus behaviour,
and how these are included in the final model.
That is, we construct the transition function $f$.



\subsection{General vehicle behaviour}
\label{sec:vehicle_model_behaviour}

We will be working with the following definition of the transition function
for this part,
\begin{equation}
\label{eq:vtrans_general}
\Vstate_k = \Vtrans(\Vstate_{k-1}, \Vtdiff_k, \Vnoise)
\end{equation}
where $\Vtdiff_k = \Vtime_k - \Vtime_{k-1}$
and the system noise $\Vnoise$ is constant over time.

We use a particle filter so we do not need to talk in terms of a distributions.
Instead, in the section, we describe the motion of a particle, a unique ``imaginary'' vehicle.
So, given a particle with state $\Vstate\vi_{k-1}$ at time $\Vtime_{k-1}$,
we use Newton's Laws of Motion \cite{cn}
to predict the state at time $\Vtime_k$
after travelling for $\Vtdiff_k$ seconds.

In the first model, A1, we assume a constant speed $\Vspeed_k$
in the interval $(\Vtime_{k-1}, \Vtime_k)$,
\begin{equation*}
\Vspeed\vi_k \sim \TNormal{\Vspeed\vi_{k-1}}{\Vnoise}{0}{30}
\end{equation*}
where $\TNormal{\mu}{\sigma}{a}{b}$ is the normal distribution
truncated to the interval $(a, b)$.
In this case, we truncate the vehicle's speed to ensure it is
both positive and under 30~m/s,
which is 108~km/h (the maximum road speed in Auckland is 100~km/h).

Having sampled a new speed (to ensure system variability, see \cref{sec:pf}),
the particle can be transitioned forward,
% as shown in \cref{fig:vtrans_general1},
using the equation
\begin{equation*}
\Vdist\vi_k = \Vdist\vi_{k-1} + \Vtdiff_k\Vspeed\vi_k.
\end{equation*}

To compute the travel time along segments,
blah blah blah.


In the second model, A2, we allow the vehicle speed to follow a random walk
between observations rather than remaining constant,
% as shown in \cref{fig:vtrans_general2}.
That is,
\begin{equation*}
\Vspeed\vi_s \sim \TNormal{\Vspeed\vi_{s-1}}{\Vnoise}{0}{30},\quad
\Vtime_s \in (\Vtime_{k-1}, \Vtime_k]
\end{equation*}
Now, the distance is updated iteratively at the same time as the speed,
\begin{equation*}
\Vdist\vi_s = \Vdist\vi_{s-1} + \Vspeed\vi_s.
\end{equation*}
which also makes travel time computation easier:
once the particle enters segment $\ell$ ($\Vdist\vi_s \geq \Tsegd_\ell$),
the travel time $\Vtt\vi_\ell$ is incremented by one second each
iteration until the particle leaves the segment
($\Vdist\vi_s \geq \Tsegd_\ell + \Tseglen_\ell$).


In the third model, A3, we add an additional parameter to the vehicle's state,
the acceleration $\Vaccel_k$ at time $\Vtime_k$.
This allows us to more realistically model the vehicle's behaviour,
and it is this model we use to generate the simulated data below.
Given an acceleration, we can update the vehicle's speed using
\begin{equation*}
\Vspeed\vi_s = \Vspeed\vi_{s-1} + \Vaccel\vi_{s}
\end{equation*}
We must truncate the acceleration distribution to ensure
the vehicle's speed remains positive and under 30~m/s,
which given the above equation yields the inequality
\begin{equation*}
0 \leq \Vspeed\vi_{s-1} + \Vaccel\vi_s \leq 30
\end{equation*}
so the acceleration distribution is
\begin{equation*}
\Vaccel\vi_s \sim \TNormal{\Vaccel\vi_{s-1}}{\Vnoise}{-\Vspeed\vi_{s-1}}{30 - \Vspeed\vi_{s-1}}
\end{equation*}
This model would be improved by placing additional constraints on the acceleration,
for example to model acceleration and deceleration phases
differently.
However, as we will discuss later,
such detail was unnecessary in the model
due to the sparsity of the observations.
The travel time computation for this model is the same as for A2.


% <<vtrans_general,echo=FALSE,message=FALSE,fig.width=8,fig.height=1.5,fig.cap="Vehicle transition function for the three models.",fig.ncol=1,fig.subcap=c("Model A1", "Model A2", "Model A3")>>=
% library(tidyverse)
% set.seed(11)
% d <-
%     tibble(
%         t = 0:10,
%         v1 = 10,
%         v2 = cumsum(c(10, rnorm(10, 0, 1)))
%     )
% set.seed(30)
% d <- d %>% mutate(
%         v3 = cumsum(
%             c(10, cumsum(rnorm(10, 0, 0.5)))
%         ),
%         d1 = cumsum(v1),
%         d2 = cumsum(v2),
%         d3 = cumsum(v3)
%     )
% px <- ggplot(d, aes(t)) +
%     theme_minimal() +
%     theme(panel.grid = element_blank()) +
%     xlab("Time") +
%     scale_x_continuous(
%         breaks = c(0, 10),
%         labels = c(expression(t[k-1]), expression(t[k]))
%     )
% egg::ggarrange(
%     px + geom_path(aes(y = d1)) + ylab("Distance") +
%     scale_y_continuous(
%         breaks = range(d$d1),
%         labels = c(expression(x[k-1]), expression(x[k]))
%     ),
%     px + geom_path(aes(y = v1)) + ylab("Speed") +
%     scale_y_continuous(
%         breaks = range(d$v1),
%         labels = c(expression(v[k-1]), '')
%     ),
%     nrow = 1
% )
% egg::ggarrange(
%     px + geom_path(aes(y = d2)) + ylab("Distance") +
%     scale_y_continuous(
%         breaks = range(d$d2),
%         labels = c(expression(x[k-1]), expression(x[k]))
%     ),
%     px + geom_path(aes(y = v2)) + ylab("Speed") +
%     scale_y_continuous(
%         breaks = d$v2[c(1, 11)],
%         labels = c(expression(v[k]), expression(v[k-1]))
%     ),
%     nrow = 1
% )
% egg::ggarrange(
%     px + geom_path(aes(y = d3)) + ylab("Distance") +
%     scale_y_continuous(
%         breaks = range(d$d3),
%         labels = c(expression(x[k-1]), expression(x[k]))
%     ),
%     px + geom_path(aes(y = v3)) + ylab("Speed") +
%     scale_y_continuous(
%         breaks = d$v3[c(1, 11)],
%         labels = c(expression(v[k-1]), expression(v[k]))
%     ),
%     nrow = 1
% )
% @


\subsubsection{Simulation}

<<sim1_gen,echo=FALSE,message=FALSE>>=
source('sims.R')
s1 <- simulate_vehicle()
segs <- lapply(1:nrow(s1$segments),
    function(i) s1$segments$distance[i] + c(0, s1$segments$length[i])
)
tt <- s1$segments$tt
fcap1 <- 'Simulated vehicle trajectory, with five road segments.'
fscap1 <- c(
    "The simulated data.",
    "10~s sampling.",
    "30~s sampling.",
    "Observations at bus stops and intersections."
)
simnames <- c("Uniform (10s)", "Uniform (30s)", "Waypoints")

@


To assess the performance of these models and compare their
estimation of road travel times, we implemented a simple simulation.
The simulated data, shown in \cref{fig:sim1_graph1},
uses model A3 to simulate a vehicle trajectory,
and uses several time point sampling methods:
uniform sampling with high (\cref{fig:sim1_graph2})
and low (\cref{fig:sim1_graph3}) frequency,
and non-uniform sampling (\cref{fig:sim1_graph4}),
which is more in line with how the Auckland Transport data is collected.


The goal of the simulation is to estimate the travel time
along a \Sexpr{diff(segs[[1]])}~m ``road segment'' with constant traffic flow,
and a \Sexpr{diff(segs[[2]])}~m segment with congestion,
denoted by the shaded regions in the figures below.
The simulation was performed in R \citep{rcore}
using $\Np = 2000$ particles per vehicle,
and so the implementation is slightly different from the C++ one
defined in \cref{sec:pf_implementation}.

<<sim1_graph,echo=FALSE,fig.height=2,fig.width=4,out.width=".49\\linewidth",fig.cap=fcap1,fig.subcap=fscap1,fig.ncol=2>>=
p1 <- ggplot(s1$path, aes(time, distance)) +
    geom_hline(yintercept = s1$segments$distance[-1],
        lty = 2, colour = "gray") +
    theme_minimal() +
    theme(panel.grid = element_blank()) +
    xlab('Time (s)') + ylab('Distance (m)') +
    ylim(0, max(s1$path$distance)) + xlim(0, max(s1$path$time))

p1 + geom_path()
p1 + geom_point(aes(t, x), data = s1$observations$high)
p1 + geom_point(aes(t, x), data = s1$observations$low)
p1 + geom_point(aes(t, x), data = s1$observations$waypoints)
@

<<sim1_pf,echo=FALSE,message=FALSE,warning=FALSE,fig.height=2,fig.width=8,out.width="\\linewidth",fig.cap="Simulation results for the three models (rows) applied to the data from three sampling methods (columns), using $\\Np=2000$ particles. Model A1 tended to underestimate the travel time, whilst models A2 and A3 gave quite similar results. As expected, the uniform high-frequency sampling gives the best estimate of travel time, while the other two result in significant uncertainty in travel times.",fig.ncol=1,fig.subcap=paste("Segment", 1:5)>>=
S0 <- get_sim_1()
for (i in 1:5) {
    print(
        S0 %>% filter(segment == sprintf("Segment %d", i)) %>%
            ggplot(aes(travel_time, fill = model)) +
            geom_histogram(bins = 30) +
            facet_grid(model~sim) +
            theme_minimal() + theme(panel.grid = element_blank()) +
            geom_vline(xintercept = tt[i], col = "gray", lty = 2) +
            scale_y_continuous(breaks = NULL) +
            xlab("Travel time (s)") + ylab("Frequency")
    )
}
@

<<sim1_pf_full,echo=FALSE,message=FALSE,warning=FALSE,fig.width=8,fig.height=4,fig.cap="Travel time estimation results for 100 simulations, in which each the vehicle trajectory is simulated using a different seed, and the travel time estimate is taken as the mean of the particle travel times along each segment.">>=
# do the whole thing over and over again
n <- 240
Nparticle <- 2000
simnames <- c("Uniform (10s)", "Uniform (30s)", "Waypoints")

s00 <- pbapply::pblapply(1:100, function(seed) {
    if (!dir.exists("sims")) dir.create("sims")
    # message(sprintf("\n* Now running simulation %d ...", seed))
    x <- NULL
    set.seed(seed)
    while(is.null(x))
        x <- doSim(Nparticle, simnames, seed = sample(1e9, 1), fn = seed)
    x
}) %>% bind_rows() %>% ungroup()

s00 %>% ggplot(aes(truth, (truth - estimate), fill = segment, colour = segment)) +
    geom_hline(yintercept = 0, colour = "gray") +
    geom_point() +
    facet_grid(sim ~ model) +
    theme_minimal() + theme(panel.grid = element_blank()) +
    xlab("Actual travel time (s)") + ylab("Estimate - Actual (s)")
@

From these two model simulations,
it is obvious that the preferred model is model A1
with non-constant speed controlled by noise ("acceleration") each second.


\subsection{Bus stops}
\label{sec:vehicle_model_stops}

The main feature of transit vehicle behaviour that distinguishes it from
other vehicle tracking applications is the presense of known stopping locations,
or \emph{bus stops}.
It is therefore an integral component of our model;
however, modelling stopping behaviour in real-time is a difficult problem,
particularly when the observations are sparse,
or frequently observed (only) at bus stops (\cref{sec:realtime-data}).

The typical behaviour is that, with some probability $\Prstop_m$,
a bus servicing route $r$ will stop at bus stop $m \in \{1, \ldots, \Nstop_r\}$.
In those situations when the bus does not stop,
the behaviour follows the model described above (\cref{sec:vehicle_model_behaviour}).
Conversely, when it does stop, it follows the following behaviour:
\begin{enumerate}
\item deceleration on approach to stop, doors open,
\item passengers alight and board, and
\item doors close, acceleration into traffic flow.
\end{enumerate}
Following the work by \cite{Hans_2015},
steps 1 and 3 above are combined into a single constant parameter $\mindwell$,
which represents the \emph{minimum dwell time} at a stop.

The second step is modelled as the service time of the stop,
that is the time to allow passengers to alight and board.
As we have no real-time data on passenger counts available in Auckland,
we rely on the flexibility of the particle filter to estimate
dwell time in real-time.
We are using a truncated normal distribution
with mean $\mindwell + \dwell_m$ and variance $\dwellvar_m$,
with a point mass of $1-\Prstop_m$ on zero,
as shown in \cref{fig:eta_dwell_times}.

<<eta_dwell_times, echo=FALSE, fig.height=5,fig.cap="Dwell time at bus stop $m$">>=
gamma <- 10
tau <- 20
omega <- 10
xx <- seq(gamma, 40, length.out = 1001)
yy <- dnorm(xx, tau, omega)
pi <- max(yy) * 0.8
plot(xx, yy, type = "l", xlim = c(0, max(xx)), ylim = c(0, max(yy)),
    xlab = "Dwell time", ylab = "Probability density",
    xaxt = "n", yaxt = "n")
lines(c(0, gamma), c(0, 0))
points(gamma, yy[1], pch = 19)
points(c(0, gamma), c(0, 0), pch = 21, bg = "white")
points(0, pi, pch = 19)
axis(2, at = c(0, pi), label = c(0, expression(1-pi[m])), las = 2)
axis(1, at = c(0, gamma, tau), label = c(0, expression(gamma), expression(gamma + tau[m])))
@

So, for a given particle approaching stop $m$,
the dwell time associated with that stop
can be expressed as a function of
\begin{equation*}
\Istop\vi_m \sim \Bern{\Prstop_m}\quad\text{and}\quad
\pserve\vi_m \sim \TNormal{\dwell_m}{\dwellvar_m}{\gamma}{\infty}
\end{equation*}
giving the dwell time $\pdwell\vi_m$ as
\begin{equation}
\label{eq:stop_dwell_time}
\pdwell\vi_m = \Istop\vi_m (\mindwell + \pserve\vi_m)
\end{equation}


\subsubsection{Simulation}

And now we simulate some models with stopping at bus stops.

<<sim2_gen,echo=FALSE,message=FALSE>>=
s2 <- simulate_vehicle(pi = 1, seed = 1000)
segs <- lapply(1:nrow(s2$segments),
    function(i) s2$segments$distance[i] + c(0, s2$segments$length[i])
)
tt <- s2$segments %>% rowwise() %>%
    mutate(
        tt = tt -
            sum(s2$stops$d[between(s2$stops$distance,
                distance, distance + length
            )])
    ) %>% pluck("tt")
fcap2 <- 'Simulated vehicle trajectory, with five road segments and three intermediate stops.'
fscap2 <- c(
    "The simulated data.",
    "10~s sampling.",
    "30~s sampling.",
    "Observations at bus stops and intersections."
)
@

<<sim2_graph,echo=FALSE,fig.height=2,fig.width=4,out.width=".49\\linewidth",fig.cap=fcap2,fig.subcap=fscap2,fig.ncol=2>>=
p2 <- ggplot(s2$path, aes(time, distance)) +
    geom_hline(yintercept = s2$segments$distance[-1],
        lty = 2, colour = "gray") +
    geom_hline(yintercept = s2$stops$distance[-1],
        lty = 3, colour = "orangered") +
    theme_minimal() +
    theme(panel.grid = element_blank()) +
    xlab('Time (s)') + ylab('Distance (m)') +
    ylim(0, max(s2$path$distance)) + xlim(0, max(s2$path$time))

p2 + geom_path()
p2 + geom_point(aes(t, x), data = s2$observations$high)
p2 + geom_point(aes(t, x), data = s2$observations$low)
p2 + geom_point(aes(t, x), data = s2$observations$waypoints)
@



<<sim2_pf,echo=FALSE,message=FALSE,warning=FALSE,fig.height=2,fig.width=8,out.width="\\linewidth",fig.cap="Simulation results for the three models (rows) applied to the data from three sampling methods (columns), using $\\Np=2000$ particles. Model A1 tended to underestimate the travel time, whilst models A2 and A3 gave quite similar results. As expected, the uniform high-frequency sampling gives the best estimate of travel time, while the other two result in significant uncertainty in travel times.",fig.ncol=1,fig.subcap=paste("Segment", 1:5)>>=
S0 <- get_sim_2()
for (i in 1:5) {
    print(
        S0 %>% filter(segment == sprintf("Segment %d", i)) %>%
            ggplot(aes(travel_time, fill = model)) +
            geom_histogram(bins = 30) +
            facet_grid(model~sim) +
            theme_minimal() + theme(panel.grid = element_blank()) +
            geom_vline(xintercept = tt[i], col = "gray", lty = 2) +
            scale_y_continuous(breaks = NULL) +
            xlab("Travel time (s)") + ylab("Frequency")
    )
}
@




\subsection{Intersections}
\label{sec:vehicle_model_intersections}

Unlike route paths and bus stops which are known,
intersections are, for the most part, unknown,
as there is no readily available, up-to-date information about
the locations of intersections
