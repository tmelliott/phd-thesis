\section{\Rt{} vehicle model}
\label{sec:vehicle_model}

\Rt{} tracking of vehicles has been studied vigorously,
particularly for robotics applications and self driving cars \citep{cn}.
However, most of these use data that has a (very) high sampling rate,
often more than one per second.
In transit data, this is not the case;
instead, our models need to be able to deal with data that is updated
once every 10--30~seconds or, in some cases, even longer.


The two main problems with low frequency sampling are that,
firstly, the possible locations a vehicle can be at grows exponentially,
so the prediction part of the \gls{rbe} algorithm (see \cref{sec:recursive-bayes})
can struggle to cover all of the possible trajectories the vehicle might take---%
remembering that this is a key part of what we are trying to estimate!
The second problem, related to the first,
is that it is very easy to \emph{lose} the vehicle in the predict step,
resulting in degradation of the filter and having to reinitialize.
This is bad because it means we lose any information about travel times
in that period.


The \kf{} is a fast estimation method, however it has a higher chance of failure
in our application due to the above reasons,
and it assumes the state is Gaussian, which is often not the case,
for example at bus stops---the bus may or may not stop,
so there will be at least two plausible locations for the prediction.
The \pf{}, while having a much higher computational cost,
is much more flexible and capable of accounting for a larger range of
plausible trajectories, as mentioned by \cite{Hans_2015},
who also used a \pf{} to model buses.


The vehicle model itself implements a simplified estimation of bus behaviour,
allowing us to infer the vehicle's trajectory between consecutive observations.
The foundation of this model is a simple dynamic vehicle tracking model,
in which the vehicle's unknown state, $\Vstate$,
is infered using a sequence of GPS coordinates.
The path of the vehicle is known,
so the state uses the \emph{distance traveled}, $\Vdist_k$, along the route at time $\Vtime_k$.
We are also interested in the \emph{speed} of the vehicle, $\Vspeed_k$
Therefore, the underlying, unknown, and \emph{unobservable} state of each vehicle is denoted
\begin{equation}
\label{eq:vehicle_state}
\Vstate_k = \tvec{\Vdist_k, \Vspeed_k}
\end{equation}

As discussed, we chose to implement a Bayes' filter model,
implemented using a \pf{},
to estimate the \rt{} state of each vehicle.
To do so, we need a \emph{transition function} $\Vtrans$
to predict the future state
$p(\Vstate_k | \Vstate_{k-1})$,
and a likelihood and measurement function $\Vmeas$
to update the state given an observation
$p(\Vstate_k | \Vobs_{1:k})$.
The vehicle model is, in it's simplest form,
composed of the state $\Vstate$, the transition function $\Vtrans$
with system noise $\Vnoise$---which represents the change in speed per second---%
as well as the observation $\Vobs$, measurement function $\Vmeas$
and measurement---or \gls{gps}---error, $\GPSerr$,
\begin{equation}
\label{eq:vehicle_model}
\begin{split}
\Vstate_k &= \Vtrans(\Vstate_{k-1}, \Vnoise_k) \\
\Vobs_k &= \Vmeas(\Vstate_k) + \GPSerr
\end{split}
\end{equation}

The \pf{} permits a lot of flexibility in how each of the components are specified.
The transition function $\Vtrans$, for example,
can implement a complex simulation of bus behaviour,
while the measurement function $\Vmeas$ can be constructed
to use \emph{points} that can easily be
mapped between one and two dimensions.


We will now discuss the details of the vehicle model components separately.
The model of bus behaviour for the transition function is covered in
\cref{sec:vehicle_model_trans},
and presents several models which will be compared later
in \cref{sec:vehicle_travel_times}.
Then, in \cref{sec:pf-likelihood},
the necessary measurement function and likelihood for the data
will be constructed.
Details of the actual implementation have been left for
\cref{sec:particle-filter}.



\subsection{Vehicle transition model}
\label{sec:vehicle_model_trans}

Transit vehicle behaviour is both predictable and volatile.
Unlink the majority of vehicle tracking applications,
transit vehicles travel along a known \emph{path},
which is stored as a sequence of \gls{gps} coordinates
referred to in \GTFS{} as the \emph{shape}.
However, the position along this two-dimensional line,
and the speed at which it is travelling, is unknown.
Estimation of each of these is therefore necessary
in order to estimate travel time along road segments:
the position along the shape tells us which road segment the vehicle is on,
and the speed tells us about the travel time.


In this section, we develop a model of bus behaviour incrementally,
starting off with a simple distance and speed model
before incorporating stops and intersections.
The overall goal is to \emph{predict} the state of the vehicle,
which, using the particle filter, is given by
\begin{equation}
\label{eq:vehicle_pf_predict}
p(\Vstate_k | \Vstate_{k-1}) \approx
\sum_{i=1}^\Np
    \Pwt_{k-1}
    \dirac\left(\Vstate_k - f(\Vstate\vi_{k-1}, \Vtdiff_k, \Vnoise_k)\right)
\end{equation}
where $\Vtdiff_k = \Vtime_k - \Vtime_{k-1}$
and the system noise $\Vnoise$ is constant over time.


\subsubsection{General vehicle behaviour (Model A)}

Since the \pf{} is applying the transition function to points,
rather than distributions (as is the case with the \kf{}),
each particle can be transitioned independently according to physics,
in this case Newton's Laws of Motion \cite{cn},
which allows us to predict the distance travelled of an object
after travelling for $\Vtdiff_k$~seconds at a speed of $\Vspeed_k$,
\begin{equation}
\label{eq:vehicle_model_newton}
\Vdist_k = \Vdist_{k-1} + \Vtdiff_k\Vspeed_k.
\end{equation}
This same basic model was used by the likes of
\cite{Cathey_2003,cn}.


The second part of the model to consider is the noise variation.
Clearly, vehicles do not travel at a constant speed,
instead they accelerate and decelerate according to the traffic conditions,
driver behaviour, and other factors (bus stops and intersections are
explicitely examined later).
Presented below are three increasingly generalised models,
from a constant speed between observations and stops,
to random speed and random acceleration.

In the first model (A1) we assume a constant speed $\Vspeed_k$
in the interval $(\Vtime_{k-1}, \Vtime_k)$,
\begin{equation}
\Vspeed_k \sim \TNormal{\Vspeed_{k-1}}{\Vnoise}{0}{30}
\end{equation}
where $\TNormal{\mu}{\sigma}{a}{b}$ is the normal distribution
truncated to the interval $(a, b)$.
In this case, vehicle speed was truncated to ensure it is
both positive and under 30~m/s,
which is 108~km/h (the maximum road speed in Auckland is 100~km/h).
The truncation point could, of course,
be reduced in a majority of roads throughout Auckland,
but this information was not straightforward/free to obtain.
Having sampled a new speed (to ensure system variability, see \cref{sec:pf}),
the vehicle travels forward according to \cref{eq:vehicle_model_newton}.


In order to compute the vehicle's travel time along a road segment,
the start and end times of travel along the segment,
$\Vsegstart_\ell$ and $\Vsegend_\ell$,
respectively, are interpolated.
The end time of travel along segment $\ell - 1$ is the same as the
start time of travel along segment $\ell$,
so given segment $\ell$ begins at $\Tsegd_\ell$~meters along the route shape,
then whenever $\Tsegd_\ell \in (\Vdist_{k-1},  \leq \Vdist_k]$,
the relevant segment start and end times are computed as
\begin{equation}
\label{eq:vehicle_model_a1_tt_interp}
\Vsegend_{\ell-1} = \Vsegstart_\ell =
\Vtime_{k-1} + \frac{\Tsegd_\ell - \Vdist_{k-1}}{\Vspeed_k}.
\end{equation}


Travel times are straightforward to compute in this model
once both start and end times of travel along a segment $\ell$
have been interpolated,
\begin{equation}
\label{eq:vehicle_model_a1_tt}
\Vtt_\ell = \Vsegend_\ell - \Vsegstart_\ell.
\end{equation}



A second model (A2) allows the vehicle speed to follow a random walk
between observations rather than remaining constant.
That is,
\begin{equation}
\Vspeed_s \sim \TNormal{\Vspeed_{s-1}}{\Vnoise}{0}{30},\quad
\Vtime_s \in (\Vtime_{k-1}, \Vtime_k].
\end{equation}
In order to simultaneously compute segment travel times,
the distance is also iteratively updated each second
by modifying \cref{eq:vehicle_model_newton} (removing the $\Vdtiff_k$ parameter)
\begin{equation}
\Vdist_s = \Vdist_{s-1} + \Vspeed_s.
\end{equation}
Once the particle enters segment $\ell$ ($\Vdist_s \geq \Tsegd_\ell$),
the travel time $\Vtt_\ell$ is incremented by one second each
iteration until the particle leaves the segment
($\Vdist_s \geq \Tsegd_\ell + \Tseglen_\ell$).


In the third model (A3),
the process is generalised even further by adding another parameter
to the vehicle state,
the acceleration $\Vaccel_k$ at time $\Vtime_k$.
This allows more realistical modelling of vehicle behaviour,
and it was this model we used to generate the simulated data below.
Given an acceleration and again following Newton's Laws,
vehicle speed is updated by
\begin{equation}
\label{eq:vehicle_model_accel}
\Vspeed_s = \Vspeed_{s-1} + \Vaccel_{s}
\end{equation}

The acceleration noise distribution needed to be truncated
in such as was as to to ensure
the vehicle's speed remained positive and less than 30~m/s,
which from \cref{eq:vehicle_model_accel} yields the inequality
\begin{equation}
- \Vspeed_{s-1} \leq \Vaccel_s \leq 30 - \Vspeed_{s-1}
\end{equation}
resulting in the acceleration distribution
\begin{equation}
\Vaccel_s \sim \TNormal{\Vaccel_{s-1}}{\Vnoise}{-\Vspeed_{s-1}}{30 - \Vspeed_{s-1}}
\end{equation}

Computing the travel time of the vehicle along road segments
was done in the same way as for model A2.

\subsubsection{Bus stops}
\label{sec:vehicle_model_stops}

The main feature of transit vehicle behaviour that distinguishes it from
other vehicle tracking applications is the presense of known stopping locations,
or \emph{bus stops}.
It is therefore an integral component of our model;
however, modelling stopping behaviour in \rt{} is a difficult problem,
particularly when the observations are sparse,
or frequently observed (only) at bus stops (\cref{sec:realtime-data}).

The typical behaviour is that, with some probability $\Prstop_m$,
a bus servicing route $r$ will stop at bus stop $m \in \{1, \ldots, \Nstop_r\}$.
In those situations when the bus does not stop,
the behaviour follows the model described above (\cref{sec:vehicle_model_behaviour}).
Conversely, when it does stop, it follows the following behaviour:
\begin{enumerate}
\item deceleration on approach to stop, doors open,
\item passengers alight and board, and
\item doors close, acceleration into traffic flow.
\end{enumerate}
Following the work by \cite{Hans_2015},
steps 1 and 3 above are combined into a single constant parameter $\mindwell$,
which represents the \emph{minimum dwell time} at a stop.

The second step is modelled as the service time of the stop,
that is the time to allow passengers to alight and board.
As we have no \rt{} data on passenger counts available in Auckland,
we rely on the flexibility of the \pf{} to estimate
dwell time in \rt{}.
We are using a truncated normal distribution
with mean $\mindwell + \dwell_m$ and variance $\dwellvar_m$,
with a point mass of $1-\Prstop_m$ on zero,
as shown in \cref{fig:eta_dwell_times}.

<<eta_dwell_times, echo=FALSE, fig.height=3,fig.cap="Dwell time at bus stop $m$">>=
gamma <- 10
tau <- 20
omega <- 10
xx <- seq(gamma, 40, length.out = 1001)
yy <- dnorm(xx, tau, omega)
pi <- max(yy) * 0.8
tibble(x = xx, y = yy) %>%
    ggplot(aes(x, y)) +
    geom_path() +
    geom_segment(aes(x = 0, y = 0, xend = gamma, yend = 0), data = NULL) +
    geom_point(data = tibble(x = c(0, gamma), y = c(0, 0)),
        shape = 21, fill = "white") +
    geom_point(data = tibble(x = c(0, gamma), y = c(pi, yy[1])),
        shape = 19) +
    xlab("Dwell time") + ylab("Probability density") +
    scale_x_continuous(breaks = c(0, gamma, tau),
        labels = c(0, expression(gamma), expression(gamma + tau[m]))) +
    scale_y_continuous(breaks = c(0, pi),
        labels = c(0, expression(1 - pi[m]))) +
    theme_minimal() +
    theme(panel.grid = element_blank())
@

So, for a given particle approaching stop $m$,
the dwell time associated with that stop
can be expressed as a function of
\begin{equation}
\Istop\vi_m \sim \Bern{\Prstop_m}\quad\text{and}\quad
\pserve\vi_m \sim \TNormal{\dwell_m}{\dwellvar_m}{\gamma}{\infty}
\end{equation}
giving the dwell time $\pdwell\vi_m$ as
\begin{equation}
\label{eq:stop_dwell_time}
\pdwell\vi_m = \Istop\vi_m (\mindwell + \pserve\vi_m)
\end{equation}




\subsubsection{Intersections}
\label{sec:vehicle_model_intersections}

Unlike route paths and bus stops which are known,
intersections are, for the most part, unknown,
as there is no readily available, up-to-date information about
the locations of intersections.
We can, however, develop our model to allow for intersections,
which can then be created by
\begin{itemize}
\item importing from an external source,
\item detecting intersections using shape files (\cref{sec:route-segments}), or
\item using historical GPS data to find locations of high bus density.
\end{itemize}
Each of these methods have their benefits and downfalls,
but this is not the topic of this thesis.


To model intersections,
we use a similar approach as for bus stops,
however we remove the minimum dwell time
and simply use an exponential distribution for the wait times,
\begin{equation}
\Iint\vi_\ell \sim \Bern{\rho_\ell}\quad\text{and}\quad
\pcwait\vi_\ell \sim \Exp{\intwait_\ell^{-1}}
\end{equation}
giving the wait time $\pwait\vi_\ell$ as
\begin{equation}
\label{eq:intersection_wait_time}
\pwait\vi_\ell = \Iint\vi_\ell \pcwait\vi_\ell.
\end{equation}

Another complication with intersections is that
it is possible for a vehicle to be stuck in a queue
and need to wait multiple light phases before getting through the intersection.
While it should be sufficient to simply include this
in the segment's travel time,
due to the issues discussed in \cref{sec:vp_data},
it is possible for a vehicle to be queuing up
and report its location as \emph{at the intersection},
rather than in the queue.

