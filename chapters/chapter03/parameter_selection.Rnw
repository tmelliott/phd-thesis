\subsection{Parameter selection}
\label{sec:pf_params}

Once the inherent data issues have been dealt with,
we can begin determining the values of the model parameters.
Some of these are fixed and constant across all vehicles, routes, and stops,
for example,
GPS error, $\GPSerr$,
system noise, $\Vnoise$,
and minimum dwell time, $\mindwell$.
Others will inevitably vary between routes, stops, and time of day,
such as stopping probability, $\Prstop$,
and dwell time, $\dwell$.


% We explore these by modelling a subset of routes throughout Auckland over several days,
% using historical data to allow us to vary parameters and compare their effects.
% Some parameters, notably $\GPSerr$ and $\dwell$
% can be determined from the data:
% the value $\GPSerr$ can be approximated by looking at the variability
% of points around the route,
% since we assume there is no directional bias,
% so the distance from an observation to the route is an approximate estimate
% of measurement error.


\subsubsection{GPS error}
\label{sec:pf_params_gps}

The GPS or \emph{measurement} error used in the model has a strong effect on performance, as we saw in \cref{sec:pf_issues}. We can get a simple estimate of GPS error by examining the distribution of observations around the route; that is, we computed the shortest distance between the route and each observation, and graphed the results in \cref{fig:pf_param_gps}. We see two modes at about 0.5 and 2.5~meters, which could be due to a multitude of reasons. One likely one, however, is \emph{road width}, since the route shapes typically run in the middle of the road and the buses drive either side of the center line. Single-lane roads will have a smaller average distance between the bus and the center line, while for roads with two or more lanes, this will be larger. Additionally, some roads have a median (either painted or raised) which further increases the distance between the bus and the ``center line''. It is possible that some combination of this could result in the distribution shown in \cref{fig:pf_param_gps}.



<<pf_param_gps,cache=TRUE,message=FALSE,echo=FALSE,fig.width=8,fig.height=3,fig.cap="Distribution of distance from observation to nearest point on the route, truncated to 10~m.">>=
suppressPackageStartupMessages(library(tidyverse))

dfile <- "data/distances.rda"
if (!file.exists(dfile)) {
    curd <- setwd("../../data")
    source("load_data.R")
    setwd(curd)

    source("scripts/load_vps.R")

    library(RSQLite)
    suppressPackageStartupMessages(library(dbplyr))
    con <- dbConnect(SQLite(), db)
    # for each ROUTE, fetch the shape
    rids <- unique(vps$route_id)
    routeshape <- con %>% tbl('trips') %>%
        select(route_id, shape_id) %>%
        filter(route_id %in% rids) %>%
        distinct()
    shapes <- con %>% tbl('shapes') %>%
        inner_join(routeshape) %>%
        collect() %>%
        group_by(route_id)
    tids <- unique(vps$trip_id)
    date <- format(
        as.POSIXct(median(vps$timestamp), origin = "1970-01-01"),
        "%Y-%m-%d"
    )
    triptimes <- con %>% tbl('stop_times') %>%
        filter(trip_id %in% tids & stop_sequence ==1 ) %>%
        select(trip_id, departure_time) %>%
        collect()
    dbDisconnect(con)

    date <- as.POSIXct(paste(date, "00:00:00"))
    triptimes <- triptimes %>%
        mutate(t = date + sapply(departure_time, function(x) {
            sum(c(60*60, 60, 1) * as.numeric(strsplit(x, ":")[[1]]))
        }))

    # trip time - start time
    vps <- vps %>% right_join(triptimes) %>%
        filter(timestamp >= t & timestamp < t + 60*60*1)

    # filter out single obs
    vps <- vps %>% group_by(vehicle_id, trip_id) %>%
        do({
            zz <- (.)
            if (nrow(zz) < 5) zz <- zz %>% filter(FALSE)
            zz
        })

    dist_to_line <- function(x, s) {
        s <- sf::st_linestring(s %>% ungroup %>% select(shape_pt_lon, shape_pt_lat) %>% as.matrix)
        geosphere::dist2Line(x %>% select('lon', 'lat') %>% as.matrix, s)[, 1]
    }

    vpsd <- vps[sample(nrow(vps), 20000),] %>% group_by(route_id) %>%
        do({
            zz <- (.)
            sh <- shapes %>% filter(route_id == zz$route_id[1])
            zz %>% mutate(dist2r = dist_to_line(., sh))
        })

    save(vpsd, file = dfile)
} else {
    load(dfile)
}

vpdat <- vpsd %>%
    filter(dist2r < 10 & dist2r > -1) %>%
    mutate(dist2r = pmax(0, dist2r))

ggplot(vpdat %>% arrange(dist2r)) +
    geom_histogram(aes(dist2r, stat(density)), bins = 50) +
    theme_minimal() +
    theme(panel.grid = element_blank()) +
    xlab("Distance (m)") +
    ylab("Distribution") +
    scale_x_continuous(breaks = seq(0, 10, by = 2))
    # scale_y_continuous(breaks = NULL)
    # geom_point(aes(lon, lat, colour = dist2r)) +
    # scale_colour_viridis_c("D")
    # geom_point(aes(lon, lat))

p <- ggplot(
    vpdat %>% filter(dist2r<=4)%>%
        mutate(
            dist_cat = cut(dist2r, breaks = c(0, 0.5, 1, 2, 4), include.lowest=T)
        ),
    aes(lon, lat, colour = dist2r)
) +
    geom_point() +
    scale_colour_viridis_c() +
    facet_wrap(~dist_cat)

#fitt <- lm(dist2r ~ route_id - 1, data = vpdat)
#smryfit <- summary(fitt)
#plot(sort(coef(smryfit)[,1]))

@

The other issue is the heavy tail in the distribution of distance to path, which we trunctated to 10~meters to more easily see the modes. GPS devices usually have good accuracy, but occasionally they may be quite far off of the true location, possibly due to physical interference. \Sexpr{round(mean(vpsd$dist2r > 10 & vpsd$dist2r < 50) * 100)}\% of bus observations were more than 10~meters from the shape, excluding any observations greater than 50~meters since these were most likely attributed to the wrong trip (and therefore not anywhere near the route path). This would explain a large proportion of the degeneration rate (\cref{fig:model_performance_degen}), which we saw previously decreases significantly with increased GPS error.





\subsubsection{System noise}
\label{sec:pf_params_noise}

The definition of system noise is model-dependent; for transition models $f_{A1}$ and $f_{A2}$ it is \emph{the average change in speed per second}, while for model $f_{A3}$ it is \emph{the average change in acceleration per second}. From the simulations in \cref{sec:pf_issues}, we demonstrated that system noise affected the performance of the particle filter (how often resampling is required) but neither the degeneration rate nor parameter estimation.

Unlike GPS error, it is not possible to estimate system noise directly from the data. Indeed, most of the time a vehicle's speed is constant, but may change suddenly at certain locations (which are unknown), so the system noise must allow for this. We found that a smaller value of system noise under the second transition model $f_{A2}$ gave the best results in terms of sampling possible trajectories, and as such this was the model used during the simulation.



\subsubsection{Dwell times}
\label{sec:pf_params_dwell}

We are able to observe a large proportion of dwell times at stops, by compiling all those for which we have observed both arrival times $\Varr_{srm}$ and departure times $\Vdep_{srm}$ at stop $m$ of trip $r$ on day $s$ giving us a set of dwell times
\begin{equation}
\label{eq:dwell_time_obs}
\Vdwell_{srm} = \Vdep_{srm} - \Varr_{srm}
\end{equation}

<<observed_dwell,cache=TRUE,message=FALSE,warning=FALSE,echo=FALSE,fig.width=8,fig.height=3,out.width="\\linewidth",fig.cap="Distribution of dwell times observed over the course of five days, truncated at one minute.">>=
library(tidyverse)
dwellfile <- "data/dwell.rda"
if (file.exists(dwellfile)) {
    load(dwellfile)
} else {
    d <- tempdir()
    files <- unzip("../../../transitr/trip_updates_archive.zip",
        exdir = d
    )

    dwell <- pbapply::pblapply(files, function(file) {
        load(file) # -> tu
        tu <- tu %>% as_tibble %>% distinct %>%
            mutate(date = format(timestamp, "%Y-%m-%d")) %>%
            select(date, vehicle_id, trip_id, route_id, stop_sequence, type, time)
        tu %>% filter(type == "arrival") %>% select(-type) %>%
            inner_join(tu %>% filter(type == "departure") %>% select(-type),
                by = c("date", "vehicle_id", "trip_id",
                    "route_id", "stop_sequence"),
                suffix = c("_arrival", "_departure")
            ) %>%
            mutate(dwell = time_departure - time_arrival) %>%
            filter(dwell >= 0)
    }) %>% bind_rows()
    save(dwell, file = dwellfile)
}
gamma <- 10
ggplot(dwell %>% filter(dwell < 60)) +
    geom_histogram(aes(dwell, stat(density)), bins = 60) +
    theme_minimal() + theme(panel.grid = element_blank()) +
    xlab("Dwell time (seconds)") + ylab("Distribution") +
    scale_x_continuous(breaks = seq(0, 60, by = 20)) +
    geom_vline(xintercept = gamma, lty = 2) +
    geom_path(aes(x, p),
        data = tibble(
            x = seq(0, 60, length = 1001),
            p = truncnorm::dtruncnorm(x, gamma, Inf, 28, 10)
        ),
        lty = 2, colour = "red"
    )

@

There is no precise way to measure the minimum dwell time parameter $mindwell$. \cite{Hans_2015} used 14.25~seconds as the time lost due to deceleration and acceleration, and 4.1~seconds as the time needed to open and close the doors. Other studies have found values of \ldots, 


% which is marked by a dashed vertical line in \cref{fig:observed_dwell}. There are a few dwell times less than this, but given the spike at 6~seconds, it seems reasonable to continue with this value.

The raw data from five~days' observations are shown in \cref{fig:observed_dwell}. Here, we see an interesting pattern with apparent peaks every nine~seconds. While we could not determine the precise cause, we assume it to be due to a systematic problem in the arrival time recording system used to collect the data. However, this makes the first peak at 9~seconds difficult to evaluate: are there really dwell times this short (contrary to the literature) or is the an artefact? For example, if a bus passes a stop without stopping and reports an arrival time followed a few seconds later by a departure time, does the reporting delay of about 9~seconds affect this? 

From the historical dwell time data, we were able to estimate the mean and variance of dwell time for each stop $j$, $\bar\dwell_j$ and $\dwellvar_j$, respectively, which could then be used in the dwell time model.


The dwell times for each stop calcualted above \emph{include} the minimum dwell time phase. To avoid having to recompute each stop's dwell time parameter whenever $\mindwell$ is changed, we adjusted the mean of each stop's dwell time at run time to account for the minimum dwell time. That is, we use $\dwell_j = \bar\dwell_j - \mindwell$ in \cref{eq:stop_dwell_time}.
