\subsection{Parameter selection}
\label{sec:pf_params}

Once the inherent data issues have been dealt with,
we can begin determining the values of the model parameters.
Some of these are fixed and constant across all vehicles, routes, and stops,
for example,
GPS error, $\GPSerr$,
system noise, $\Vnoise$,
and minimum dwell time, $\mindwell$.
Others will inevitably vary between routes, stops, and time of day,
such as stopping probability, $\Prstop$,
and dwell time, $\dwell$.


We explore these by modelling a subset of routes throughout Auckland over several days,
using historical data to allow us to vary parameters and compare their effects.
Some parameters, notably $\GPSerr$ and $\dwell$
can be determined from the data:
the value $\GPSerr$ can be approximated by looking at the variability
of points around the route,
since we assume there is no directional bias,
so the distance from an observation to the route is an approximate estimate
of measurement error.


\subsubsection{Estimating GPS error}
\label{sec:pf_params_gps}

The measurement error for the model is arguably one of the more important parameters,
as it is indeed the entire purpose of the model to filter noisy observations
in order to infer things about the state of the vehicle.
In a full Bayesian model,
the GPS error could simply be given a prior and estimated using \gls{mcmc}.
However it turns out trying to for a Bayesian model to the data
is a very difficult process,
particularly the question of
\emph{how to map observations to the route},
so while it would have been nice to implement such a model
(and indeed we have plans to, time allowing),
we use a far more primitive method.


Buses travel along a route which has a known path.
Although the line will not always lie exactly on the path of the vehicle,
it gives us a close enough approximation.
If we therefore compute the shortest distance
from each observation to the route,
we can get a distribution of the GPS error.

First, we need to extract the data \ldots
Then, the route itself can be extracted from the database \ldots

<<pf_param_gps,cache=TRUE,message=FALSE,echo=FALSE,fig.width=8,fig.height=3,fig.cap="Distribution of distance from observation to nearest point on the route, truncated to 10~m.">>=
suppressPackageStartupMessages(library(tidyverse))
load("vps.rda")
vps <- vps %>% distinct

library(RSQLite)
suppressPackageStartupMessages(library(dbplyr))
con <- dbConnect(SQLite(), "fulldata.db")
# for each ROUTE, fetch the shape
rids <- unique(vps$route_id)
routeshape <- con %>% tbl('trips') %>%
    select(route_id, shape_id) %>%
    filter(route_id %in% rids) %>%
    distinct()
shapes <- con %>% tbl('shapes') %>%
    inner_join(routeshape) %>%
    collect() %>%
    group_by(route_id)
tids <- unique(vps$trip_id)
date <- format(
    as.POSIXct(median(vps$timestamp), origin = "1970-01-01"),
    "%Y-%m-%d"
)
triptimes <- con %>% tbl('stop_times') %>%
    filter(trip_id %in% tids & stop_sequence ==1 ) %>%
    select(trip_id, departure_time) %>%
    collect()
dbDisconnect(con)

date <- as.POSIXct(paste(date, "00:00:00"))
triptimes <- triptimes %>%
    mutate(t = date + sapply(departure_time, function(x) {
        sum(c(60*60, 60, 1) * as.numeric(strsplit(x, ":")[[1]]))
    }))

# trip time - start time
vps <- vps %>% right_join(triptimes) %>%
    filter(timestamp >= t & timestamp < t + 60*60*1)

# filter out single obs
vps <- vps %>% group_by(vehicle_id, trip_id) %>%
    do({
        zz <- (.)
        if (nrow(zz) < 5) zz <- zz %>% filter(FALSE)
        zz
    })

dist_to_line <- function(x, s) {
    s <- sf::st_linestring(s %>% ungroup %>% select(shape_pt_lon, shape_pt_lat) %>% as.matrix)
    geosphere::dist2Line(x %>% select('lon', 'lat') %>% as.matrix, s)[, 1]
}
vpsd <- vps[sample(nrow(vps), 20000),] %>% group_by(route_id) %>%
    do({
        zz <- (.)
        sh <- shapes %>% filter(route_id == zz$route_id[1])
        zz %>% mutate(dist2r = dist_to_line(., sh))
    })

ggplot(vpsd %>% filter(dist2r < 10 & dist2r > -1) %>% arrange(dist2r)) +
    geom_histogram(aes(dist2r, stat(density)), bins = 50) +
    theme_minimal() + theme(panel.grid = element_blank()) +
    xlab("Distance (m)") + ylab("Distribution") +
    scale_x_continuous(breaks = seq(0, 10, by = 2))
    # scale_y_continuous(breaks = NULL)
    # geom_point(aes(lon, lat, colour = dist2r)) +
    # scale_colour_viridis_c("D")
    # geom_point(aes(lon, lat))
@


The results are shown in \cref{fig:pf_param_gps},
which shows one peak at about 0.5~m,
and another at 2.5~m.
This gives us a vague idea of what the GPS error should be,
although it is very artificial
(and demonstrates how bad our assumption is that the observations
are normally distributed, but eh \ldots)


From here, we choose a range of GPS error values:
2~m, 3~m, and 5~m.



\subsubsection{Estimating dwell times}
\label{sec:pf_params_dwell}

We are able to observe a large proportion of dwell times at stops,
by compiling all those for which we have observed both
arrival times $\Varr_{srm}$ and departure times $\Vdep_{srm}$
at stop $m$ of trip $r$ on day $s$
giving us a set of dwell times
\begin{equation}
\label{eq:dwell_time_obs}
\Vdwell_{srm} = \Vdep_{srm} - \Varr_{srm}
\end{equation}

<<observed_dwell,cache=TRUE,message=FALSE,echo=FALSE,fig.width=8,fig.height=3,fig.cap="Distribution of dwell times observed over the course of five days.">>=

@

The raw data from five~days' observations
are shown in \cref{fig:observed_dwell}.
Here, we see an interesting pattern with apparent peaks every nine~seconds.
While we could not determine the precise cause,
we assume it to be due to a systematic problem in the arrival time
recording system used to collect the data.

Regardless, we can still explore the dwell times for any stop or time effects.

To these data we fitted the following model
\begin{equation}
\label{eq:dwell_time_model}
\Vdwell_{drm} =
    \dwell_m +   % mean dwell time for stop m
    \alpha_0 (\Varr_{drm}) +  % time effect
    \sum_{j=1}^\Nstop \eta_j I_{j=s}
\end{equation}
using \emph{A METHOD}.
We obtained some results.
These are useful for the predictive model
(\cref{cha:prediction}),
and slightly useful for the \pf{} model,
but not so much since we either know the approximate dwell time
(from arrival and departure observations),
or we only know one of them,
and then we don't know if the bus stopped or not,
so we have to guess.
Although I suppose it does give us a more distinctive
set of possible values.


\subsubsection{Estimating system noise}
\label{sec:pf_params_noise}

The system noise parameter $\Vnoise$
controls the variability of the system,
that is how quickly the particles mutate.
That is,
if we duplicate one particle 100 times,
how quickly do we want them to diverge?
Too quickly and the distribution becomes too sparse;
too slow and the true value may not be captured.

It's also important to note that often large values of $\Vtdiff$
are not necessarily associated with a large change in distance.
A lot of the time the vehicle wont have moved at all,
and the way the location system is set up means that
no new position is reported until the bus moves again.



We can measure these two situations:
\begin{itemize}
\item the proportion of iterations requiring resampling,
    which will be large if the mutation rate is too high, and
\item the proportion of iterations requiring reinitialisation,
    which will be large if the mutation rate is too low.
\end{itemize}



And then the same for remaining parameters \ldots

Minimum dwell time $\mindwell$ we just use literature values,
since there isn't really anything else to go on.


