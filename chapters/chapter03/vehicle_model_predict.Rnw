\subsection{Predicting vehicle state: the transition function}
\label{sec:vehicle_model_trans}

The goal of the prediction step is to obtain a \emph{prior distribution} of the vehicle's state at time $\Vtime_k$ based on its previous state at time $\Vtime_{k-1}$. That is, we wish to estimate $p(\Vstate_k | \Vstate_{k-1})$. Using the model definition in \cref{eq:vehicle_model} along with the particle filter approximation of state in \cref{eq:vehicle_state_dirac}, we can write the prior prediction of the vehicle's state as
\begin{equation}
\label{eq:vehicle_pf_predict}
p(\Vstate_k | \Vstate_{k-1}) \approx
\sum_{i=1}^\Np
    \Pwt_{k-1}
    \dirac\left(\Vstate_k - f(\Vstate\vi_{k-1}, \Vtdiff_k, \Vnoise_k)\right),
\end{equation}
where $\Vtdiff_k = \Vtime_k - \Vtime_{k-1}$.

The transition function $\Vtrans$ is where we define the vehicle behaviours mentioned earlier (and others). In Kalman filter applications, one is limited to linear transformations of the state which can be expressed in a \emph{transition matrix}. However, we see in \cref{eq:vehicle_pf_predict} that, in the particle filter implementation, the transition function is applied to each particle independently, allowing for a lot more flexibility in $\Vtrans$. We now describe the various model components of $\Vtrans$, which we implemented as an algorithm in the \verb+transitr+ package (see \cref{sec:particle-filter} for details). The core components are vehicle motion (speed and acceleration along a known path), stopping behaviour at known locations (bus stops and intersections), and a suite of other scenarios we may need to include to avoid degeneration.


\subsubsection{Component A: vehicle motion}
\label{sec:vehicle_model_behaviour}

The first behaviour to consider is that of any vehicle travelling along a known path: the \emph{speed} at which a vehicle is travelling will affect where it ends up. Since speed, $\Vspeed$, is the derivative of distance travelled over time, that is if $x = d(t)$, then $\Vspeed = d'(t)$, which was shown visually in \cref{fig:vehicle_state}. It follows that we can predict a vehicle's future state, given its current state (distance travelled and speed) and system noise,
\begin{equation}
\label{eq:vehicle_model_newton}
\Vstate_{k|k-1} = f_{A1}\left(\Vstate_{k-1|k-1}\right) =
\begin{bmatrix}
\Vdist_k \\ \Vspeed_k
\end{bmatrix} =
\begin{bmatrix}
\Vdist_{k-1} + \Vtdiff_k\Vspeed_k \\
\Vspeed_{k-1} + v_k
\end{bmatrix},\quad
v_k \sim \TNormal{0}{\Vnoise}{-\Vspeed_{k-1}}{30 - \Vspeed_{k-1}}.
\end{equation}
In this case, the noise term is truncated to ensure the new speed is both positive and under 30~m/s, which is 108~km/h (the maximum road speed in Auckland is 100~km/h)
The resulting transition function, $\Vtrans_{A1}$, can quite simply be implemented by simulating, for each particle, a new speed before calculating the final state using \cref{eq:vehicle_model_newton}. A similar model was used by \cite{Cathey_2003,cn}.

% The variance of predicted distance travelled is
% \begin{equation}
% \label{eq:model_a1_var}
% \begin{split}
% \Var{\Vdist_k}
% &= \Var{\Vdist_{k-1} + \Vtdiff_k (\Vspeed_{k-1} + v_k)} \\
% &= \Var{\Vdist_{k-1}} + \Vtdiff_k^2\Var{\Vspeed_{k-1}} +
%     \Vtdiff_k^2\Vnoise
% \end{split}
% \end{equation}

\Cref{fig:transition_a1_demo} demonstrates transition model $\Vtrans_{A1}$ using a sample of $N=10$~particles which, at time $t_{k-1}$, take one of three unique states (due to resampling in the previous iteration). The points have been coloured by this initial state to demonstrate the effect of adding noise \emph{before} transitioning, and how the system noise controls how the state spreads. The interpretation of the noise parameter is \emph{the average change in speed, per second, between vehicle observations}. \textcolor{blue}{[[re-write para]]}

<<transition_a1_demo,echo=FALSE,fig.width=6,fig.height=4,out.width=".8\\textwidth",fig.cap="Simulated particle trajectories using transition model A1. Points have been coloured by their parent (after resampling) to demonstrate the affect of system noise.",fig.align="center">>=

suppressPackageStartupMessages(library(tidyverse))
set.seed(2483576)
X <- rbind(
    c(500, 8, 1),
    c(510, 9, -0.5),
    c(490, 7, 2)
)

d <- tibble(
    id = 1:10,
    parent = c(1L, 1L, 1L, 2L, 2L, 2L, 3L, 3L, 3L, 3L),
    time = rep(30L, 10),
    distance = X[parent, 1],
    speed = X[parent, 2]
)

sysnoise <- 5
d2 <- d %>%
    mutate(
        time = time + 30L,
        speed = truncnorm::rtruncnorm(n(), 0, 30, speed, sysnoise),
        distance = distance + 30L * speed
    )

d <- bind_rows(d, d2) %>%
    mutate(parent = as.character(parent))

ggplot(d, aes(time, distance, group = id, colour = parent)) +
    geom_point() +
    geom_path() +
    scale_x_continuous("Time (seconds)",
        breaks = c(30, 60),
        labels = c(expression(t[k-1]), expression(t[k]))
    ) +
    scale_y_continuous("Distance travelled (meters)"
    ) +
    theme_classic() +
    theme(legend.position = "none")

@

The main issue with this model is that it assumes constant speed between observations, which---given Auckland traffic---is unlikely to be the case. In \cref{fig:vehicle_state}, we showed speed varying over time, even between observations. To model this, we \emph{iteratively} update the vehicle's state\footnote{This is one advantage of the particle filter---we can easily perform iterative updates!} by reusing \cref{eq:vehicle_model_newton} $\Vtdiff_k$ times, setting $\Vtdiff_k=1$ in each iteration. \Cref{fig:transition_a2_demo} shows the effect this has on the particle's trajectories. Note, however, that in this model the system noise parameter is not the same, and has a slightly different interpretation: it is now \emph{the average change in speed per second} (no longer between observations).

% Under normal circumstances (and without the truncation) the variance of the predicted state is, for $z_m\sim\Normal{0}{\Vnoise}$,
% \begin{equation}
% \label{eq:model_a2_var}
% \begin{split}
% \Var{\Vdist_k}
% &= \Var{\Vdist_{k-1} + \sum_{n=0}^{\Vtdiff_k-1}(\Vspeed_{k-1} +
%     \textstyle\sum_{m=n}^{\Vtdiff_k} z_n)} \\
% &= \Var{\Vdist_{k-1} + \Vtdiff_k \Vspeed_{k-1} +
%     \textstyle\sum_{n=0}^{\Vtdiff_k-1} (\Vtdiff_k - n) z_n} \\
% &= \Var{\Vdist_{k-1}} + \Vtdiff_k^2\Var{\Vspeed_{k-1}} +
%     \Var{\textstyle\sum_{n=0}^{\Vtdiff_k-1} (\Vtdiff_k - n) z_n} \\
% &= \Var{\Vdist_{k-1}} + \Vtdiff_k^2\Var{\Vspeed_{k-1}} +
%     \textstyle\sum_{n=0}^{\Vtdiff_k-1} \Var{(\Vtdiff_k - n) z_n} \\
% &= \Var{\Vdist_{k-1}} + \Vtdiff_k^2\Var{\Vspeed_{k-1}} +
%     \textstyle\sum_{n=0}^{\Vtdiff_k-1} (\Vtdiff_k - n)^2\Vnoise  \\
% &= \Var{\Vdist_{k-1}} + \Vtdiff_k^2\Var{\Vspeed_{k-1}} +
%     \Vnoise \textstyle\sum_{n=1}^{\Vtdiff_k} n^2 \\
% &= \Var{\Vdist_{k-1}} + \Vtdiff_k^2\Var{\Vspeed_{k-1}} +
%     \Vnoise \frac{\Vtdiff_k(\Vtdiff_k+1)(2\Vtdiff_k+1)}{6}
% \end{split}
% \end{equation}
% which grows at a cubic rate, compared to the quadratic rate of $A1$. We must therefore take care when choosing the system noise when $\Vtdiff_k$ is large. To control the variance so it grows more linearly with $\Vtdiff_k$, we can multiply the system noise by $\frac{6\Vtdiff_k^2}{\Vtdiff_k(\Vtdiff_k+1)(2\Vtdiff_k+1)}}$, so now $A1$ and $A2$ have the same variance; however, we will use a larger value of $\Vnoise$ for $A2$ to allow for greater variance of trajectories.

<<transition_a2_demo,echo=FALSE,fig.width=6,fig.height=4,out.width=".8\\textwidth",fig.cap="Simulated particle trajectories using transition model A2. Points have been coloured by their parent (after resampling) to demonstrate the affect of system noise.",fig.align="center">>=

d <- tibble(
    id = 1:10,
    parent = c(1L, 1L, 1L, 2L, 2L, 2L, 3L, 3L, 3L, 3L),
    time = rep(30L, 10),
    distance = X[parent, 1],
    speed = X[parent, 2]
)
d2 <- d
delta <- 30
sysnoise2 <- sqrt(
    6 * sysnoise^2 * delta^2 / delta / (delta + 1) / (2 * delta + 1)
)
for (i in 1:30) {
    d2 <- d2 %>%
        mutate(
            time = time + 1L,
            speed = truncnorm::rtruncnorm(n(), 0, 30, speed, 2),
            distance = distance + speed
        )
    d <- bind_rows(d, d2)
}

d <- d %>% mutate(parent = as.character(parent))
ggplot(d, aes(time, distance, group = id, colour = parent)) +
    geom_point(data = d %>% filter(time %in% c(30, 60))) +
    geom_path() +
    scale_x_continuous("Time (seconds)",
        breaks = c(30, 60),
        labels = c(expression(t[k-1]), expression(t[k]))
    ) +
    scale_y_continuous("Distance travelled (meters)"
    ) +
    theme_classic() +
    theme(legend.position = "none")
@


Of course, if speed is the first derivative of the vehicle's trajectory function, then \emph{accerlation} is the second, $\Vaccel = d''(t)$. In this case, we add a third component to the vehicle's state, and consider speed similarly to distance; the transition function becomes
\begin{equation}
\label{eq:vehicle_model_newton_accel}
\Vstate_{k|k-1} = \Vtrans_{A3}\left(\Vstate_{k-1|k-1}\right) =
\begin{bmatrix}
\Vdist_k \\ \Vspeed_k \\ \Vaccel_k
\end{bmatrix} =
\begin{bmatrix}
\Vdist_{k-1} + \Vtdiff_k\Vspeed_k \\
\Vspeed_{k-1} + \Vaccel_k \\
\Vaccel_{k-1} + v_k
\end{bmatrix}
\end{equation}
with the system noise now applied to the acceleration term and truncated to ensure the speed remains positive and less than 30~m/s,
\begin{equation}
\label{eq:vehicle_model_accel_dist}
v_k \sim \TNormal{0}{\Vnoise}{-\Vspeed_{k-1} - \Vaccel_{k-1}}{30 - \Vspeed_{k-1} - \Vaccel_{k-1}}
\end{equation}
Again, we have displayed the resulting trajectories in \cref{fig:transition_a3_demo}. The main issue is that it is difficult to parameterize and constrain the acceleration to ensure speed remains in the desired region, \emph{and} that the function can still generate plausible trajectories.


<<transition_a3_demo,echo=FALSE,fig.width=6,fig.height=4,out.width=".8\\textwidth",fig.cap="Simulated particle trajectories using transition model A3. Points have been coloured by their parent (after resampling) to demonstrate the affect of system noise.",fig.align="center">>=

d <- tibble(
    id = 1:10,
    parent = c(1L, 1L, 1L, 2L, 2L, 2L, 3L, 3L, 3L, 3L),
    time = rep(30L, 10),
    distance = X[parent, 1],
    speed = X[parent, 2],
    accel = X[parent, 3]
)
d2 <- d
reject_sample <- Vectorize(
    function(x, sigma_target = c(1, 2), sigma_prop = 0.1,
             lower = -Inf, upper = Inf) {
        if (x < lower) x <- lower
        if (x > upper) x <- upper
        s <- ifelse(x > 0, sigma_target[1], sigma_target[2])
        xstar <- truncnorm::rtruncnorm(1, lower, upper, x, sigma_prop)
        sstar <- ifelse(xstar > 0, sigma_target[1], sigma_target[2])
        if (xstar < lower || xstar > upper) return(x)
        d1 <- dnorm(xstar, 0, sstar, log = TRUE) - dnorm(0, 0, sstar, log = TRUE)
        d2 <- dnorm(x, 0, s, log = TRUE) - dnorm(0, 0, s, log = TRUE)
        if (d1 > d2) return(xstar)
        alpha <- min(0, d1 - d2)
        if (runif(1) < exp(alpha)) return(xstar)
        x
    },
    c("x", "lower", "upper")
)
# X <- numeric(100000)
# for (i in 2:length(X)) X[i] <- reject_sample(X[i-1])
# plot(X, type = "l")
# h <- hist(X, freq=FALSE)
# plot(h, freq = FALSE)
# curve(max(h$density)*dnorm(x, 0, ifelse(x>0,1,2))/dnorm(0,0,ifelse(x>0,1,2)),
#     -15, 10, 1001,add=T)

for (i in 1:30) {
    d2 <- d2 %>%
        mutate(
            time = time + 1L,
            accel = reject_sample(accel,
                sigma_prop = 0.8,
                lower = -speed,
                upper = 30 - speed
            ),
            speed = speed + accel,
            distance = distance + speed
        )
    d <- bind_rows(d, d2)
}

d <- d %>% mutate(parent = as.character(parent))
ggplot(d, aes(time, distance, group = id, colour = parent)) +
    geom_point(data = d %>% filter(time %in% c(30, 60))) +
    geom_path() +
    scale_x_continuous("Time (seconds)",
        breaks = c(30, 60),
        labels = c(expression(t[k-1]), expression(t[k]))
    ) +
    scale_y_continuous("Distance travelled (meters)"
    ) +
    theme_classic() +
    theme(legend.position = "none")

@


\subsubsection{Nodes: bus stops and intersections}
\label{sec:vehicle_model_nodes}

\textcolor{red}{Re-write this section as a ``node''-based operation, with cases for stops or intersections.}

The main feature of transit vehicle behaviour that distinguishes it from other vehicle tracking applications is the presence of known stopping locations, or \emph{bus stops}, which are therefore an integral component of our model. However, modelling stopping behaviour in \rt{} is a difficult problem, particularly when the observations are sparse, or frequently observed (only) at bus stops (\cref{sec:realtime-data}).



The main difficulty here is related to how the data are observed, which was discussed in \cref{sec:vp_data}. It is quite common only to observe \GPS{} positions at bus stops, a location at which there is a positive probability of being. Thus, it makes sense that the maximum likelihood estimate of the trajectory between two bus stops puts the maximum possible time \emph{at the stop}, resulting in maximum speed between stops. Early iterations of our model succumbed to this problem until we implemented a likelihood function on the trip updates (see \cref{sec:lhood_trip}).



The typical behaviour at bus stops is that a bus stops if passengers are signalling to get on or off the bus. Probabilistically, we say that a bus servicing route $r$ stops at bus stop $m \in \{2, \ldots, \Nstop_r - 1\}$\footnote{the bus always stops at the first and last stops} with some unknown probability $\Prstop_m$. In situations where the bus does not stop, the behaviour follows model A; otherwise, it follows the following behaviour:
\begin{enumerate}
\item deceleration on approach to stop, doors open,
\item passengers alight and board, and
\item doors close, acceleration into the traffic flow.
\end{enumerate}
Following the work by \cite{Hans_2015}, steps 1 and 3 above are combined into a single constant parameter $\mindwell$, which represents the \emph{minimum dwell time} at a stop.



Step 2 is modelled as the service time of the stop; that is the time to allow passengers to alight and board. As we have no \rt{} data on passenger counts available in Auckland, we rely on the flexibility of the \pf{} to estimate dwell time in \rt{}. Using a truncated normal distribution with mean $\mindwell + \dwell_m$ and variance $\dwellvar_m$, with a point mass of $1-\Prstop_m$ on zero, as shown in \cref{fig:eta_dwell_times}.



<<eta_dwell_times, echo=FALSE, fig.height=3,fig.cap="Dwell time at bus stop $m$">>=
suppressPackageStartupMessages(library(tidyverse))
gamma <- 10
tau <- 20
omega <- 10
xx <- seq(gamma, 40, length.out = 1001)
yy <- dnorm(xx, tau, omega)
pi <- max(yy) * 0.8
tibble(x = xx, y = yy) %>%
    ggplot(aes(x, y)) +
    geom_path() +
    geom_segment(aes(x = 0, y = 0, xend = gamma, yend = 0), data = NULL) +
    geom_point(data = tibble(x = c(0, gamma), y = c(0, 0)),
        shape = 21, fill = "white") +
    geom_point(data = tibble(x = c(0, gamma), y = c(pi, yy[1])),
        shape = 19) +
    xlab("Dwell time") + ylab("Probability density") +
    scale_x_continuous(breaks = c(0, gamma, tau),
        labels = c(0, expression(gamma), expression(gamma + tau[m]))) +
    scale_y_continuous(breaks = c(0, pi),
        labels = c(0, expression(1 - pi[m]))) +
    theme_minimal() +
    theme(panel.grid = element_blank())
@

So, for a given vehicle approaching stop $m$, the dwell time associated with that stop can be expressed as a function of
\begin{equation}
\label{eq:stop_dwell_model}
\Istop_m \sim \Bern{\Prstop_m}\quad\text{and}\quad
\pserve_m \sim \TNormal{\dwell_m}{\dwellvar_m}{0}{\infty}
\end{equation}
giving the dwell time $\pdwell_m$ as
\begin{equation}
\label{eq:stop_dwell_time}
\pdwell_m = \Istop_m (\mindwell + \pserve_m)
\end{equation}




\subsubsection{Intersections}
\label{sec:vehicle_model_intersections}

Unlike route paths and bus stops which are known, intersections are, for the most part, unknown, as there is no readily available, up-to-date information about the locations of intersections. We can, however, develop our model to allow for intersections, which can then be created by
\begin{itemize}
\item importing from an external source,
\item detecting intersections using shapefiles (\cref{sec:route-segments}), or
\item using historical GPS data to find locations of high bus density.
\end{itemize}
Each of these methods has their benefits and downfalls, but this is not the topic of this thesis.


To model intersections, we use an approach similar to the one used for bus stops, but removing the minimum dwell time and using an exponential distribution for the wait times,
\begin{equation}
\Iint_\ell \sim \Bern{\rho_\ell}\quad\text{and}\quad
\pcwait_\ell \sim \Exp{\intwait_\ell^{-1}}
\end{equation}
giving the wait time $\pwait_\ell$ as
\begin{equation}
\label{eq:intersection_wait_time}
\pwait_\ell = \Iint_\ell \pcwait_\ell.
\end{equation}


Another complication with intersections is that it is possible for a vehicle to be stuck in a queue and need to wait for multiple light phases before getting through the intersection. While it should be sufficient to include this in the segment's travel time, due to the issues discussed in \cref{sec:vp_data}, it is possible for a vehicle to be queuing up and report its location as \emph{at the intersection}, rather than in the queue.


\textcolor{red}{
    The main point is to keep track of the bus by covering all possible
    trajectories.
}
