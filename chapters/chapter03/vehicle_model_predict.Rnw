\subsection{Predicting vehicle state: the transition function}
\label{sec:vehicle_model_trans}

The goal of the prediction step is to obtain a \emph{prior distribution} of the vehicle's state at time $\Vtime_k$ based on its previous state at time $\Vtime_{k-1}$. That is, we wish to estimate $p(\Vstate_k | \Vstate_{k-1})$. Using the model definition in \cref{eq:vehicle_model} along with the particle filter approximation of state in \cref{eq:vehicle_state_dirac}, we can write the prior prediction of the vehicle's state as
\begin{equation}
\label{eq:vehicle_pf_predict}
p(\Vstate_k | \Vstate_{k-1}) \approx
\sum_{i=1}^\Np
    \Pwt_{k-1}
    \dirac\left(\Vstate_k - f(\Vstate\vi_{k-1}, \Vtdiff_k, \Vnoise_k)\right),
\end{equation}
where $\Vtdiff_k = \Vtime_k - \Vtime_{k-1}$.

The transition function $\Vtrans$ is where we define the vehicle behaviours mentioned earlier (and others). In Kalman filter applications, one is limited to linear transformations of the state which can be expressed in a \emph{transition matrix}. However, we see in \cref{eq:vehicle_pf_predict} that, in the particle filter implementation, the transition function is applied to each particle independently, allowing for a lot more flexibility in $\Vtrans$. We now describe the various model components of $\Vtrans$, which we implemented as an algorithm in the \verb+transitr+ package (see \cref{sec:particle-filter} for details). The core components are vehicle motion (speed and acceleration along a known path), stopping behaviour at known locations (bus stops and intersections), and an overview of other scenarios we may need to include to avoid degeneration.


\subsubsection{General vehicle behaviour (Model A)}
\label{sec:vehicle_model_behaviour}

Since the \pf{} is applying the transition function to points, rather than distributions (as is the case with the \kf{}), each particle can be transitioned independently according to physics, in this case, a simple motion model, which allows us to predict the distance travelled of an object after travelling for $\Vtdiff_k$~seconds at a speed of $\Vspeed_k$,
\begin{equation}
\label{eq:vehicle_model_newton}
\Vdist_k = \Vdist_{k-1} + \Vtdiff_k\Vspeed_k.
\end{equation}
Previous work, such as that of \cite{Cathey_2003,cn}, used this same basic model.


The second part of the model to consider is the variance of the noise. Vehicles do not travel at a constant speed; instead, they accelerate and decelerate according to the traffic conditions, driver behaviour, and other factors (bus stops and intersections are explicitly examined later). Presented below are three increasingly generalised models, from a constant speed between observations and stops to random speed and random acceleration.


In the first model (A1) we assume a constant speed $\Vspeed_k$ in the interval $(\Vtime_{k-1}, \Vtime_k]$,
\begin{equation}
\Vspeed_k \sim \TNormal{\Vspeed_{k-1}}{\Vnoise}{0}{30}
\end{equation}
where $\TNormal{\mu}{\sigma}{a}{b}$ is the Normal distribution truncated to the interval $(a, b)$. In this case, vehicle speed was truncated to ensure it is both positive and under 30~m/s, which is 108~km/h (the maximum road speed in Auckland is 100~km/h). The truncation point could, of course, be reduced in a majority of roads throughout Auckland, but this information was not straightforward or free to obtain. Having sampled a new speed (to ensure system variability, see \cref{sec:pf}), the vehicle travels forward according to \cref{eq:vehicle_model_newton}.



To compute the vehicle's travel time along a road segment, the start and end times of travel along the segment, $\Vsegstart_\ell$ and $\Vsegend_\ell$, respectively, are interpolated. The end time of travel along segment $\ell - 1$ is the same as the start time of travel along segment $\ell$, so given segment $\ell$ begins at $\Tsegd_\ell$~meters along the route shape, then whenever $\Tsegd_\ell \in (\Vdist_{k-1},  \leq \Vdist_k]$, the relevant segment start and end times are computed as
\begin{equation}
\label{eq:vehicle_model_a1_tt_interp}
\Vsegend_{\ell-1} = \Vsegstart_\ell =
\Vtime_{k-1} + \frac{\Tsegd_\ell - \Vdist_{k-1}}{\Vspeed_k}.
\end{equation}


Travel times are straightforward to compute in this model after interpolating both start and end times of travel along a segment $\ell$,
\begin{equation}
\label{eq:vehicle_model_a1_tt}
\Vtt_\ell = \Vsegend_\ell - \Vsegstart_\ell.
\end{equation}



A second model (A2) allows the vehicle speed to follow a random walk between observations rather than remaining constant. That is,
\begin{equation}
\Vspeed_s \sim \TNormal{\Vspeed_{s-1}}{\Vnoise}{0}{30},\quad
\Vtime_s \in (\Vtime_{k-1}, \Vtime_k].
\end{equation}
In order to simultaneously compute segment travel times, the distance is iteratively updated once per second by modifying \cref{eq:vehicle_model_newton} (removing the $\Vtdiff_k$ parameter) for $s = \{t_{k-1}, t_{k-1} + 1, \ldots, t_k - 1, t_k \}$
\begin{equation}
\Vdist_s = \Vdist_{s-1} + \Vspeed_s.
\end{equation}
Once the particle enters segment $\ell$ ($\Vdist_s \geq \Tsegd_\ell$), the travel time $\Vtt_\ell$ is incremented by one second each iteration until the particle leaves the segment ($\Vdist_s \geq \Tsegd_\ell + \Tseglen_\ell$).



In the third model (A3), the process is generalised even further by adding another parameter to the vehicle state, the acceleration $\Vaccel_k$ at time $\Vtime_k$. This process allows more realistic modelling of vehicle behaviour, and it was this model we used to generate the simulated data below. Given an acceleration and again following the motion laws, the vehicle speed is updated by
\begin{equation}
\label{eq:vehicle_model_accel}
\Vspeed_s = \Vspeed_{s-1} + \Vaccel_{s}
\end{equation}

The acceleration noise distribution needed to be truncated in such a way as to ensure the vehicle's speed remained positive and less than 30~m/s, which from \cref{eq:vehicle_model_accel} yields the inequality
\begin{equation}
- \Vspeed_{s-1} \leq \Vaccel_s \leq 30 - \Vspeed_{s-1}
\end{equation}
resulting in the acceleration distribution
\begin{equation}
\Vaccel_s \sim \TNormal{\Vaccel_{s-1}}{\Vnoise}{-\Vspeed_{s-1}}{30 - \Vspeed_{s-1}}
\end{equation}

Computing the travel time of the vehicle along road segments
was done in the same way as for model A2.


\subsubsection{Nodes: bus stops and intersections}
\label{sec:vehicle_model_nodes}

\textcolor{red}{Re-write this section as a ``node''-based operation, with cases for stops or intersections.}

The main feature of transit vehicle behaviour that distinguishes it from other vehicle tracking applications is the presence of known stopping locations, or \emph{bus stops}, which are therefore an integral component of our model. However, modelling stopping behaviour in \rt{} is a difficult problem, particularly when the observations are sparse, or frequently observed (only) at bus stops (\cref{sec:realtime-data}).



The main difficulty here is related to how the data are observed, which was discussed in \cref{sec:vp_data}. It is quite common only to observe \GPS{} positions at bus stops, a location at which there is a positive probability of being. Thus, it makes sense that the maximum likelihood estimate of the trajectory between two bus stops puts the maximum possible time \emph{at the stop}, resulting in maximum speed between stops. Early iterations of our model succumbed to this problem until we implemented a likelihood function on the trip updates (see \cref{sec:lhood_trip}).



The typical behaviour at bus stops is that a bus stops if passengers are signalling to get on or off the bus. Probabilistically, we say that a bus servicing route $r$ stops at bus stop $m \in \{2, \ldots, \Nstop_r - 1\}$\footnote{the bus always stops at the first and last stops} with some unknown probability $\Prstop_m$. In situations where the bus does not stop, the behaviour follows model A; otherwise, it follows the following behaviour:
\begin{enumerate}
\item deceleration on approach to stop, doors open,
\item passengers alight and board, and
\item doors close, acceleration into the traffic flow.
\end{enumerate}
Following the work by \cite{Hans_2015}, steps 1 and 3 above are combined into a single constant parameter $\mindwell$, which represents the \emph{minimum dwell time} at a stop.



Step 2 is modelled as the service time of the stop; that is the time to allow passengers to alight and board. As we have no \rt{} data on passenger counts available in Auckland, we rely on the flexibility of the \pf{} to estimate dwell time in \rt{}. Using a truncated normal distribution with mean $\mindwell + \dwell_m$ and variance $\dwellvar_m$, with a point mass of $1-\Prstop_m$ on zero, as shown in \cref{fig:eta_dwell_times}.



<<eta_dwell_times, echo=FALSE, fig.height=3,fig.cap="Dwell time at bus stop $m$">>=
suppressPackageStartupMessages(library(tidyverse))
gamma <- 10
tau <- 20
omega <- 10
xx <- seq(gamma, 40, length.out = 1001)
yy <- dnorm(xx, tau, omega)
pi <- max(yy) * 0.8
tibble(x = xx, y = yy) %>%
    ggplot(aes(x, y)) +
    geom_path() +
    geom_segment(aes(x = 0, y = 0, xend = gamma, yend = 0), data = NULL) +
    geom_point(data = tibble(x = c(0, gamma), y = c(0, 0)),
        shape = 21, fill = "white") +
    geom_point(data = tibble(x = c(0, gamma), y = c(pi, yy[1])),
        shape = 19) +
    xlab("Dwell time") + ylab("Probability density") +
    scale_x_continuous(breaks = c(0, gamma, tau),
        labels = c(0, expression(gamma), expression(gamma + tau[m]))) +
    scale_y_continuous(breaks = c(0, pi),
        labels = c(0, expression(1 - pi[m]))) +
    theme_minimal() +
    theme(panel.grid = element_blank())
@

So, for a given vehicle approaching stop $m$, the dwell time associated with that stop can be expressed as a function of
\begin{equation}
\label{eq:stop_dwell_model}
\Istop_m \sim \Bern{\Prstop_m}\quad\text{and}\quad
\pserve_m \sim \TNormal{\dwell_m}{\dwellvar_m}{0}{\infty}
\end{equation}
giving the dwell time $\pdwell_m$ as
\begin{equation}
\label{eq:stop_dwell_time}
\pdwell_m = \Istop_m (\mindwell + \pserve_m)
\end{equation}




\subsubsection{Intersections}
\label{sec:vehicle_model_intersections}

Unlike route paths and bus stops which are known, intersections are, for the most part, unknown, as there is no readily available, up-to-date information about the locations of intersections. We can, however, develop our model to allow for intersections, which can then be created by
\begin{itemize}
\item importing from an external source,
\item detecting intersections using shapefiles (\cref{sec:route-segments}), or
\item using historical GPS data to find locations of high bus density.
\end{itemize}
Each of these methods has their benefits and downfalls, but this is not the topic of this thesis.


To model intersections, we use an approach similar to the one used for bus stops, but removing the minimum dwell time and using an exponential distribution for the wait times,
\begin{equation}
\Iint_\ell \sim \Bern{\rho_\ell}\quad\text{and}\quad
\pcwait_\ell \sim \Exp{\intwait_\ell^{-1}}
\end{equation}
giving the wait time $\pwait_\ell$ as
\begin{equation}
\label{eq:intersection_wait_time}
\pwait_\ell = \Iint_\ell \pcwait_\ell.
\end{equation}


Another complication with intersections is that it is possible for a vehicle to be stuck in a queue and need to wait for multiple light phases before getting through the intersection. While it should be sufficient to include this in the segment's travel time, due to the issues discussed in \cref{sec:vp_data}, it is possible for a vehicle to be queuing up and report its location as \emph{at the intersection}, rather than in the queue.


\textcolor{red}{
    The main point is to keep track of the bus by covering all possible
    trajectories.
}
