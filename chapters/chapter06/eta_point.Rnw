\subsection{Point estimate}
\label{sec:etas-point}

In a perfect world, it would be possible to predict precisely how long it would take a bus to arrive at a stop, and display this single number to passengers. Alas, as we saw in \cref{cha:prediction}, this is not a perfect world, and arrival time prediction inherently comes with significant uncertainty. Yet we still need to decide on the best single value to use as a point estimate of arrival time, since much of the infrastructure currently available only allows this. We also want to examine if it is possible to come up with a single statistic that performs well---on average---and, more importantly, better than the currently deployed method.



<<eta_load,echo=FALSE,cache=TRUE>>=
suppressPackageStartupMessages({
  library(tidyverse)
  library(RSQLite)
  library(dbplyr)
  library(patchwork)
})
# load("data/eta_smry.rda")
# q50_rmse <- sqrt(sum(eta_smry$err_gtfs^2))


qfile <- "data/eta_q.rda"
if (file.exists(qfile)) {
  load(qfile)
} else {
  con <- dbConnect(SQLite(), "data/eta_quantiles.sqlite")
  etas <- con %>% tbl("etas")

  # etas %>%
  #     select(trip_id, vehicle_id) %>%
  #     distinct() %>%
  #     group_by(trip_id) %>%
  #     tally() %>%
  #     filter(n > 1)
  # thedata <- etas %>%
  #   select(trip_id, stop_sequence, timestamp, gtfs_eta, time_until_arrival) %>%
  #   distinct() %>%
  #   collect() %>%
  #   mutate(gtfs_error = gtfs_eta - time_until_arrival)

  # thedata %>% filter(gtfs_error > -60*60 & gtfs_error < 2*60*60) %>%
  #   summarize(rmse = sqrt(mean(gtfs_error^2 / 60^2)))

  qx <- function(etas, q) {
    if (q < 0 | q > 1) stop("q should be between 0 and 1")
    etas %>%
      group_by(trip_id, stop_sequence, timestamp) %>%
      filter(quantile <= q) %>%
      summarize(
        pf = max(eta, na.rm = TRUE),
        gtfs = max(gtfs_eta, na.rm = TRUE),
        actual = max(time_until_arrival, na.rm = TRUE)
      ) %>%
      collect() %>%
      ungroup() %>%
      filter(gtfs - actual > -60*60 & gtfs - actual < 2*60*60) %>%
      mutate(
        gtfs = gtfs %/% 60,
        actual = actual / 60
      )

  }
  if (!exists("q90")) q90 <- qx(etas, 0.90)
  if (!exists("q75")) q75 <- qx(etas, 0.75)
  if (!exists("q60")) q60 <- qx(etas, 0.6)
  if (!exists("q50")) q50 <- qx(etas, 0.50)
  if (!exists("q40")) q40 <- qx(etas, 0.4)
  if (!exists("q25")) q25 <- qx(etas, 0.25)
  if (!exists("q05")) q05 <- qx(etas, 0.05)

  dbDisconnect(con)

  save(q90, q75, q60, q50, q40, q25, q05, file = qfile)
}
@

<<eta_overall_results,echo=FALSE,cache=TRUE,dependson="eta_load",fig.width=8,fig.height=5,out.width="\\textwidth",fig.align="center",fig.cap="Comparison of summary statistics for various quantiles of the predictive distribution, and the currently deployed GTFS method. Results are displayed for all day average, and off-peak (between 9h30 and 14h30).">>=

offpeak_times <- paste(
  format(as.POSIXct(q90$timestamp[1], origin = "1970-01-01"), "%Y-%m-%d"),
  c("09:30:00", "14:30:00")
) %>% as.POSIXct() %>% as.integer()

d_file <- "data/d_quantiles.rda"
if (file.exists(d_file)) {
  load(d_file)
} else {
  get_smry <- function(data, expr, cond = TRUE) {
    expr <- enquo(expr)
    cond <- enquo(cond)

    data %>% filter(!!cond) %>% summarise(x = !!expr) %>% pull(x)
  }
  rmse_all <- c(
    sapply(list(q90, q75, q60, q50, q40, q25, q05), get_smry,
      expr = sqrt(mean((pf - actual)^2)),
      cond = actual > 0
    ),
    get_smry(q50, sqrt(mean((gtfs - actual)^2)), cond = actual > 0)
  )
  rmse_offpeak <- c(
    sapply(list(q90, q75, q60, q50, q40, q25, q05), get_smry,
      expr = sqrt(mean((pf - actual)^2)),
      cond = actual > 0 & between(timestamp, offpeak_times[1], offpeak_times[2])
    ),
    get_smry(q50, sqrt(mean((gtfs - actual)^2)),
      cond = actual > 0 & between(timestamp, offpeak_times[1], offpeak_times[2])
    )
  )

  mae_all <- c(
    sapply(list(q90, q75, q60, q50, q40, q25, q05), get_smry,
      expr = mean(abs(pf - actual)),
      cond = actual > 0
    ),
    get_smry(q50, expr = mean(abs(gtfs - actual)), cond = actual > 0)
  )
  mae_offpeak <- c(
    sapply(list(q90, q75, q60, q50, q40, q25, q05), get_smry,
      expr = mean(abs(pf - actual)),
      cond = actual > 0 & between(timestamp, offpeak_times[1], offpeak_times[2])
    ),
    get_smry(q50,
      expr = mean(abs(gtfs - actual)),
      cond = actual > 0 & between(timestamp, offpeak_times[1], offpeak_times[2])
    )
  )

  mape_all <- c(
    sapply(list(q90, q75, q60, q50, q40, q25, q05), get_smry,
      expr = mean(abs((pf - actual) / actual)),
      cond = actual > 0
    ),
    get_smry(q50, expr = mean(abs((gtfs - actual) / actual)), cond = actual > 0)
  )
  mape_offpeak <- c(
    sapply(list(q90, q75, q60, q50, q40, q25, q05), get_smry,
      expr = mean(abs((pf - actual) / actual), na.rm = TRUE),
      cond = actual > 0 & between(timestamp, offpeak_times[1], offpeak_times[2])
    ),
    get_smry(q50,
      expr = mean(abs((gtfs - actual) / actual), na.rm = TRUE),
      cond = actual > 0 & between(timestamp, offpeak_times[1], offpeak_times[2])
    )
  )

  pcatch_all <- c(
    sapply(list(q90, q75, q60, q50, q40, q25, q05), get_smry,
      expr = mean(pf < actual),
      cond = actual > 0
    ),
    get_smry(q50, expr = mean(gtfs < actual), cond = actual > 0)
  )
  pcatch_offpeak <- c(
    sapply(list(q90, q75, q60, q50, q40, q25, q05), get_smry,
      expr = mean(pf < actual),
      cond = actual > 0 & between(timestamp, offpeak_times[1], offpeak_times[2])
    ),
    get_smry(q50,
      expr = mean(gtfs < actual),
      cond = actual > 0 & between(timestamp, offpeak_times[1], offpeak_times[2])
    )
  )

  ewait_all <- c(
    sapply(list(q90, q75, q60, q50, q40, q25, q05), get_smry,
      expr = mean(actual - pf),
      cond = actual > 0 & pf < actual
    ),
    get_smry(q50, expr = mean(actual - gtfs),
      cond = actual > 0 & gtfs < actual
    )
  )
  ewait_offpeak <- c(
    sapply(list(q90, q75, q60, q50, q40, q25, q05), get_smry,
      expr = mean(actual - pf),
      cond = actual > 0 & pf < actual &
        between(timestamp, offpeak_times[1], offpeak_times[2])
    ),
    get_smry(q50,
      expr = mean(actual - gtfs),
      cond = actual > 0 & gtfs < actual &
        between(timestamp, offpeak_times[1], offpeak_times[2])
    )
  )

  d <- tibble(
    m = c("PF90", "PF75", "PF60", "PF50",
      "PF40", "PF25", "PF05", "GTFS"),
    rmse = rmse_all,
    mae = mae_all,
    mape = 100 * mape_all,
    pcatch = 100 * pcatch_all,
    ewait = ewait_all,
    rmse_offpeak = rmse_offpeak,
    mae_offpeak = mae_offpeak,
    mape_offpeak = 100 * mape_offpeak,
    pcatch_offpeak = 100 * pcatch_offpeak,
    ewait_offpeak = ewait_offpeak
  )
  save(d, file = d_file)
}

pres <- function(d, var, var2, lab) {
  var <- enquo(var)
  var2 <- enquo(var2)
  d <- d %>%
    select(m, !!var, !!var2) %>%
    rename("allday" = !!var, "offpeak" = !!var2) %>%
    gather("time", "x", -1)

  ggplot(d %>% filter(time == "offpeak"), aes(x, m)) +
    #geom_col(position = "dodge") +
    geom_segment(
      aes(xend = 0, yend = m)
    ) +
    geom_point() +
    scale_x_continuous(lab) +
    #scale_fill_discrete("", labels = c("All day", "Off-peak only")) +
    #coord_flip() +
    scale_y_discrete("")
}

p1 <- pres(d, rmse, rmse_offpeak, "RMSE (minutes)")
p2 <- pres(d, mae, mae_offpeak, "MAE (minutes)")
p3 <- pres(d, mape, mape_offpeak, "MAPE (%)")
p4 <- pres(d, pcatch, pcatch_offpeak, "P(bus arrives after ETA) (%)")
p5 <- pres(d, ewait, ewait_offpeak, "Expected wait time (minutes)")

p1 + p2 + p3 + p4 + p5 + guide_area() +
  plot_layout(nrow = 2, guides = "collect") &
  theme_classic()

@


We calculated, for all stops, trips, and times, a range of arrival times quantiles ($q \in \{0.05, 0.25, 0.5, 0.6, 0.6, 0.75, 0.9\}$), and for each computed the \gls{rmse}, the probability of catching the bus given you arrive at the stated \gls{eta}, $\Pcatch$, and the expected waiting time given you catch the bus, $\Ewait$. The results are displayed in \cref{fig:eta_overall_results}, along with the same values computed used the \gls{gtfs} arrival time estimates. For the particle filter, the lowest \gls{rmse} value is achieved when using the 60\% quantile, which obtains a \Sexpr{round(d$pcatch[3])}\% probability of the bus arriving after the \gls{eta} and an expected waiting time of \Sexpr{round(d$ewait[3], 1)}~minutes. The coverage of the quantiles are being overestimated---we would expect the 60\% quantile to have an approximately 40\% success rate---which indicates that the current implementation of the particle filter is underestimating arrival times.


<<eta_headway_results,message=FALSE,warning=FALSE,echo=FALSE,cache=TRUE,dependson="eta_load",fig.width=8,fig.height=5,out.width="\\textwidth",fig.align="center",fig.cap="More ETA stuff">>=

# Use headway to estimate cost of missing the bus
# (just simple start-of-route headway, nothing too complex)
curd <- setwd("../../data")
source("load_data.R")
setwd(curd)


to_time <- function(x) {
  sapply(strsplit(x, ":"),
    function(z) {
      as.integer(z[1]) * 3600 +
      as.integer(z[2]) * 60 +
      as.integer(z[3])
    }
  )
}

con <- dbConnect(SQLite(), db)
trip_headway <- con %>% tbl("stop_times") %>%
  filter(stop_sequence == 1) %>%
  select(trip_id, departure_time) %>%
  left_join(
    con %>% tbl("trips") %>% select(trip_id, route_id),
    by = "trip_id"
  ) %>%
  group_by(route_id) %>%
  arrange(route_id, departure_time) %>%
  collect() %>%
  mutate(
    time = to_time(departure_time)
  ) %>%
  group_modify(~{
    .x %>% arrange(time) %>%
      mutate(
        headway = c(diff(time), NA)
      )
  }) %>%
  ungroup() %>%
  select(trip_id, headway)
dbDisconnect(con)

q_cost <- function(q) {
  nn <- q %>% left_join(trip_headway, by = "trip_id") %>%
    filter(headway >= 60) %>%
    mutate(
      headway_min = floor(headway / 60),
      catch = as.integer(pf < actual),
      wait = ifelse(catch,
        actual - pf,
        headway_min - (pf - actual) %% headway_min
      ),
    ) %>%
    group_by(headway_min) %>%
    summarize(
      p_catch = mean(catch),
      wait_catch = mean(ifelse(catch, wait, NA), na.rm = TRUE),
      wait_catch_low = quantile(ifelse(catch, wait, NA), 0.025, na.rm = TRUE),
      wait_catch_upp = quantile(ifelse(catch, wait, NA), 0.975, na.rm = TRUE),
      wait_miss = mean(ifelse(catch, NA, wait), na.rm = TRUE),
      wait_miss_low = quantile(ifelse(catch, NA, wait), 0.025, na.rm = TRUE),
      wait_miss_upp = quantile(ifelse(catch, NA, wait), 0.975, na.rm = TRUE),
      cost = mean(wait, na.rm = TRUE)
    )

  nn
}

if (file.exists("data/eta_q_cost.rda")) {
  load("data/eta_q_cost.rda")
}

if (!requireNamespace("transitr", silent=T)) c05 <- c25
if (!exists("c05")) c05 <- q_cost(q05)
if (!exists("c25")) c25 <- q_cost(q25)
if (!exists("c40")) c40 <- q_cost(q40)
if (!exists("c50")) c50 <- q_cost(q50)
if (!exists("c60")) c60 <- q_cost(q60)
if (!exists("c75")) c75 <- q_cost(q75)
if (!exists("c90")) c90 <- q_cost(q90)
save(c25, c40, c50, c60, c75, c90, file = "data/eta_q_cost.rda")

p1 <- ggplot(NULL, aes(headway_min, p_catch)) +
  scale_y_continuous("P(catch)")

p2 <- ggplot(NULL, aes(headway_min, wait_catch)) +
  scale_y_continuous("E(wait time | catch) (min)")

p3 <- ggplot(NULL, aes(headway_min, wait_miss)) +
  scale_y_continuous("E(wait time | miss) (min)")

p4 <- ggplot(NULL, aes(headway_min, cost)) +
  scale_y_continuous("E(wait time) (min)")


p1 + p2 + p3 + p4 + plot_layout(nrow = 2, guides = "collect") &
  geom_path(aes(colour = "05"), data = c05 %>% filter(headway_min <= 60)) &
  geom_path(aes(colour = "25"), data = c25 %>% filter(headway_min <= 60)) &
  geom_path(aes(colour = "40"), data = c40 %>% filter(headway_min <= 60)) &
  geom_path(aes(colour = "50"), data = c50 %>% filter(headway_min <= 60)) &
  geom_path(aes(colour = "60"), data = c60 %>% filter(headway_min <= 60)) &
  geom_path(aes(colour = "75"), data = c75 %>% filter(headway_min <= 60)) &
  geom_path(aes(colour = "90"), data = c90 %>% filter(headway_min <= 60)) &
  theme_classic() &
  theme(legend.position = "bottom") &
  scale_x_continuous("Trip headway (minutes)") &
  labs(colour = "ETA quantile (%)")


@

An important consideration is the cost of missing the bus. For each trip, we computed the scheduled time between the current trip and the subsequent one (which is termed \emph{headway}) to compute the expected waiting time if the bus arrives \emph{before} the predicted time. That is, if a bus is predicted to arrive in 5~minutes, but actually arrives in 3, and the time until the next bus (servicing the same trip) is 10~minutes, then the expected waiting time will be $10-5=5$~minutes (assuming the passenger arrives in 5~minutes). This \emph{headway} is an essential component to prediction cost.

The total expected wait time can be conditioned on whether or not the bus was caught,
\begin{equation}
\label{eq:eta_wait_conditional}
\begin{split}
\E{\text{wait}} &=
  \Pr{\text{catch}} \E{\text{wait}|\text{catch}} +
  (1 - \Pr{\text{catch}}) \E{\text{wait}|\text{miss}} \\
  &= \Pr{A \geq a} \E{A - a | A \geq a} +
  \Pr{A < a}\E{\text{headway} - a + A | A < a}
\end{split}
\end{equation}
where $a$ is the estimated arrival time, and $A$ is the actual. For simplicity, we assume headway is maintained (which it is not, \citet{})---that is, if a bus has 20~minute frequency and you miss the bus by 5~minutes, your expected waiting time is 15~minutes.

\Cref{fig:eta_headway_results} shows the values of $\Pcatch$, $\Ecatch$, $\Emiss$, and $\Ewait$ by headway (rounded down, in minutes). Capture probability is not so affected by headway, though it decreases slightly for longer headways. In contrast, expected wait times are very much affected. Most unexpectedly, $\Ecatch$ decreases with headway, which could be caused by a higher proportion of short headway at peak times when traffic is more congested, leading to more uncertainty (so the quantiles are more dispersed), or the buses take longer than expected. For $\Emiss$, the expected wait time is not unexpectedly strongly correlated with headway. Overall, the difference in $\Ewait$ between predictors is negligible for headways less than 10~minutes, after which time differences appear. Low frequency routes should prefer a low quantile to reduce the chance of missing the bus.


We did not examine time-until-arrival, which we saw in the previous chapter explained a lot of the variation in predictor performance. We would expect a similar result here, so if one wanted to develop a predictor based on both headway and time until arrival, that would be straightforward enough. However, it is clear that the choice of predictor is tightly linked with the cost of a bad prediction: is waiting at the bus stop too long more costly than missing it altogether?
