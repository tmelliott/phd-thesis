\section{Point estimate}
\label{sec:etas-point}

In a perfect world, it would be possible to predict exactly how long it would take a bus to arrive at a stop, and display this single number to passengers. Alas, as we saw in \cref{cha:prediction}, this is not a perfect world, and arrival time prediction inherently comes with a lot of uncertainty. Yet we still need to decide on the best single value to use as a point estimate of arrival time, since much of the infrastructure currently available only allows this. We also want to examine if it is possible to come up with a single statistic that performs well---on average---and, more importantly, better than the currently deployed method.


We have taken the arrival times estimates from \cref{cha:prediction} and, for each trip, stop, and time computed the \gls{cdf} of arrival time based on the particle, as in \cref{eq:pf_cdf_arrivaltime}. These \glspl{cdf} are combined with actual arrival data, as before, including the \gls{gtfs} estimate of arrival time.

<<eta_load,echo=FALSE,cache=TRUE>>=
suppressPackageStartupMessages({
  library(tidyverse)
  library(RSQLite)
  library(dbplyr)
  library(patchwork)
})
# load("data/eta_smry.rda")
# q50_rmse <- sqrt(sum(eta_smry$err_gtfs^2))


qfile <- "data/eta_q.rda"
if (file.exists(qfile)) {
  load(qfile)
}
con <- dbConnect(SQLite(), "data/eta_quantiles.sqlite")
etas <- con %>% tbl("etas")

# etas %>%
#     select(trip_id, vehicle_id) %>%
#     distinct() %>%
#     group_by(trip_id) %>%
#     tally() %>%
#     filter(n > 1)
# thedata <- etas %>%
#   select(trip_id, stop_sequence, timestamp, gtfs_eta, time_until_arrival) %>%
#   distinct() %>%
#   collect() %>%
#   mutate(gtfs_error = gtfs_eta - time_until_arrival)

# thedata %>% filter(gtfs_error > -60*60 & gtfs_error < 2*60*60) %>%
#   summarize(rmse = sqrt(mean(gtfs_error^2 / 60^2)))

qx <- function(etas, q) {
  if (q < 0 | q > 1) stop("q should be between 0 and 1")
  etas %>%
    group_by(trip_id, stop_sequence, timestamp) %>%
    filter(quantile <= q) %>%
    summarize(
      pf = max(eta, na.rm = TRUE),
      gtfs = max(gtfs_eta, na.rm = TRUE),
      actual = max(time_until_arrival, na.rm = TRUE)
    ) %>%
    collect() %>%
    ungroup() %>%
    filter(gtfs - actual > -60*60 & gtfs - actual < 2*60*60) %>%
    mutate(
      gtfs = gtfs %/% 60,
      actual = actual / 60
    )

}
if (!exists("q90")) q90 <- qx(etas, 0.90)
if (!exists("q75")) q75 <- qx(etas, 0.75)
if (!exists("q60")) q60 <- qx(etas, 0.6)
if (!exists("q50")) q50 <- qx(etas, 0.50)
if (!exists("q40")) q40 <- qx(etas, 0.4)
if (!exists("q25")) q25 <- qx(etas, 0.25)
if (!exists("q05")) q05 <- qx(etas, 0.05)

dbDisconnect(con)

save(q90, q75, q60, q50, q40, q25, q05, file = qfile)

@

<<eta_overal_results,echo=FALSE,cache=TRUE,dependson="eta_load",fig.width=10,fig.height=3,out.width="\\textwidth",fig.align="center",fig.cap="ETA stuff">>=
pf_rmse90 <- with(q90, sqrt(mean((pf - actual)^2)))
pf_rmse75 <- with(q75, sqrt(mean((pf - actual)^2)))
pf_rmse60 <- with(q60, sqrt(mean((pf - actual)^2)))
pf_rmse50 <- with(q50, sqrt(mean((pf - actual)^2)))
pf_rmse40 <- with(q40, sqrt(mean((pf - actual)^2)))
pf_rmse25 <- with(q25, sqrt(mean((pf - actual)^2)))
pf_rmse05 <- with(q05, sqrt(mean((pf - actual)^2)))
gtfs_rmse <- with(q50, sqrt(mean((gtfs - actual)^2)))
rmse <- c(pf_rmse90, pf_rmse75, pf_rmse60, pf_rmse50,
  pf_rmse40, pf_rmse25, pf_rmse05, gtfs_rmse)


pf_pcatch90 <- with(q90, mean(pf < actual))
pf_pcatch75 <- with(q75, mean(pf < actual))
pf_pcatch60 <- with(q60, mean(pf < actual))
pf_pcatch50 <- with(q50, mean(pf < actual))
pf_pcatch40 <- with(q40, mean(pf < actual))
pf_pcatch25 <- with(q25, mean(pf < actual))
pf_pcatch05 <- with(q05, mean(pf < actual))
gtfs_pcatch <- with(q50, mean(gtfs < actual))
pcatch <- c(pf_pcatch90, pf_pcatch75, pf_pcatch60, pf_pcatch50,
  pf_pcatch40, pf_pcatch25, pf_pcatch05, gtfs_pcatch)


pf_ewait90 <- with(q90 %>% filter(pf < actual), mean(actual - pf))
pf_ewait75 <- with(q75 %>% filter(pf < actual), mean(actual - pf))
pf_ewait60 <- with(q60 %>% filter(pf < actual), mean(actual - pf))
pf_ewait50 <- with(q50 %>% filter(pf < actual), mean(actual - pf))
pf_ewait40 <- with(q40 %>% filter(pf < actual), mean(actual - pf))
pf_ewait25 <- with(q25 %>% filter(pf < actual), mean(actual - pf))
pf_ewait05 <- with(q05 %>% filter(pf < actual), mean(actual - pf))
gtfs_ewait <- with(q50 %>% filter(gtfs < actual), mean(actual - gtfs))
ewait <- c(pf_ewait90, pf_ewait75, pf_ewait60, pf_ewait50,
  pf_ewait40, pf_ewait25, pf_ewait05, gtfs_ewait)

d <- tibble(
  m = c("PF90", "PF75", "PF60", "PF50",
    "PF40", "PF25", "PF05", "GTFS"),
  rmse = rmse, pcatch = pcatch, ewait = ewait
)

p1 <- ggplot(d, aes(rmse, m)) +
  geom_point() + geom_segment(aes(xend = 0, yend = m)) +
  scale_x_continuous("RMSE (minutes)")
p2 <- ggplot(d, aes(pcatch, m)) +
  geom_point() + geom_segment(aes(xend = 0, yend = m)) +
  scale_x_continuous("P(bus arrives after ETA)")
p3 <- ggplot(d, aes(ewait, m)) +
  geom_point() + geom_segment(aes(xend = 0, yend = m)) +
  scale_x_continuous("Expected wait time (minutes)")

p1 + p2 + p3 &
  scale_y_discrete("Predictor") &
  theme_classic()
@

\Cref{fig:eta_overal_results} shows the \gls{rmse}, catch probability, and expected wait time for a range of particle filter quantiles along with the \gls{gtfs} values. For the particle filter, the lowest \gls{rmse} value is achieved when using the 60\% quantile, which obtains a \Sexpr{round(100*d$pcatch[3])}\% probability of the bus arriving after the \gls{eta} and an expected waiting time of \Sexpr{round(d$ewait[3], 1)}~minutes. The coverage of the quantiles are being overestimated---we would expect the 60\% quantile to have an approximately 40\% success rate---which indicates that the current implementation of the particle filter is underestimating arrival times.


<<eta_headway_results,echo=FALSE,cache=TRUE,dependson="eta_load",fig.width=10,fig.height=10,out.width="\\textwidth",fig.align="center",fig.cap="More ETA stuff">>=

# Use headway to estimate cost of missing the bus
# (just simple start-of-route headway, nothing too complex)
curd <- setwd("../../data")
source("load_data.R")
setwd(curd)

to_time <- function(x) {
  sapply(strsplit(x, ":"),
    function(z) {
      as.integer(z[1]) * 3600 +
      as.integer(z[2]) * 60 +
      as.integer(z[3])
    }
  )
}

con <- dbConnect(SQLite(), db)
trip_headway <- con %>% tbl("stop_times") %>%
  filter(stop_sequence == 1) %>%
  select(trip_id, departure_time) %>%
  left_join(
    con %>% tbl("trips") %>% select(trip_id, route_id),
    by = "trip_id"
  ) %>%
  group_by(route_id) %>%
  arrange(route_id, departure_time) %>%
  collect() %>%
  mutate(
    time = to_time(departure_time)
  ) %>%
  group_modify(~{
    .x %>% arrange(time) %>%
      mutate(
        headway = c(diff(time), NA)
      )
  }) %>%
  ungroup() %>%
  select(trip_id, headway)
dbDisconnect(con)

q_cost <- function(q) {
  nn <- q %>% left_join(trip_headway, by = "trip_id") %>%
    filter(headway >= 60) %>%
    mutate(
      headway_min = floor(headway / 60),
      catch = as.integer(pf < actual),
      wait = ifelse(catch,
        actual - pf,
        headway_min - (pf - actual) %% headway_min
      ),
    ) %>%
    group_by(headway_min) %>%
    summarize(
      p_catch = mean(catch),
      wait_catch = mean(ifelse(catch, wait, NA), na.rm = TRUE),
      wait_catch_low = quantile(ifelse(catch, wait, NA), 0.025, na.rm = TRUE),
      wait_catch_upp = quantile(ifelse(catch, wait, NA), 0.975, na.rm = TRUE),
      wait_miss = mean(ifelse(catch, NA, wait), na.rm = TRUE),
      wait_miss_low = quantile(ifelse(catch, NA, wait), 0.025, na.rm = TRUE),
      wait_miss_upp = quantile(ifelse(catch, NA, wait), 0.975, na.rm = TRUE),
      cost = mean(wait, na.rm = TRUE)
    )

  nn
}

if (file.exists("data/eta_q_cost.rda")) {
  load("data/eta_q_cost.rda")
}

if (!exists("c25")) c25 <- q_cost(q25)
if (!exists("c40")) c40 <- q_cost(q40)
if (!exists("c50")) c50 <- q_cost(q50)
if (!exists("c60")) c60 <- q_cost(q60)
if (!exists("c75")) c75 <- q_cost(q75)
if (!exists("c90")) c90 <- q_cost(q90)
save(c25, c40, c50, c60, c75, c90, file = "data/eta_q_cost.rda")

p1 <- ggplot(NULL, aes(headway_min, p_catch)) +
  scale_y_continuous("Probability bus arrives after")

p2 <- ggplot(NULL, aes(headway_min, wait_catch)) +
  scale_y_continuous("E(wait time | bus arrives after ETA)")

p3 <- ggplot(NULL, aes(headway_min, wait_miss)) +
  scale_y_continuous("E(wait time | bus arrives before ETA)")

p4 <- ggplot(NULL, aes(headway_min, cost)) +
  scale_y_continuous("Expected wait time (minutes)")


p1 / p2 / p3 / p4 &
  geom_point(aes(colour = "25"), data = c25 %>% filter(headway_min <= 60)) &
  geom_point(aes(colour = "40"), data = c40 %>% filter(headway_min <= 60)) &
  geom_point(aes(colour = "50"), data = c50 %>% filter(headway_min <= 60)) &
  geom_point(aes(colour = "60"), data = c60 %>% filter(headway_min <= 60)) &
  geom_point(aes(colour = "75"), data = c75 %>% filter(headway_min <= 60)) &
  geom_point(aes(colour = "90"), data = c90 %>% filter(headway_min <= 60)) &
  theme_classic() &
  scale_x_continuous("Trip headway (minutes)") &
  labs(colour = "ETA quantile (%)")


@

An important consideration is the cost of missing the bus. For each trip, we computed the scheduled time between the current trip and the subsequent one (which is termed \emph{headway}) to compute the expected waiting time if the bus arrives \emph{before} the predicted time. That is, if a bus is predicted to arrive in 5~minutes, but actually arrives in 3, and the time until the next bus (servicing the same trip) is 10~minutes, then the expected waiting time will be $10-5=5$~minutes (assuming the passenger arrives in 5~minutes).
