\section{Journey planning}
\label{sec:etas-journey-planning}

<<formatting,echo=FALSE>>=
TIME_FMT <- "%l:%M~%P"
@

So far we have been concerned with the arrival time for a bus at a single stop with no consideration of the passenger's commute as a whole. The most straightforward journey consists of a single route choice, so the only decision is which trip to catch; a slightly more complex journey may offer two alternative routes (\cref{sec:journey_simple}) between which the passenger may choose. Finally, there may be no single route which goes from the passenger's start location to their destination, in which case a transfer between two (or more) different routes, or \emph{legs}, is necessary (\cref{sec:journey_transfer}).


Dynamic routing---the selection of candidate trips and real-time assessment of which is \emph{optimal}---is in itself a difficult problem to solve \citep{Hame_2013a,Hame_2013b,Zheng_2016}. There also exist implementations which can take a probabilistic model of arrival time (such as we can obtain by \glspl{cdf}) as input to determine the optimal route (including the selection of candidate routes), such as proposed by \citet{Berczi_2017}. Therefore, for this section we only consider choosing between pre-selected candidate journey options using the arrival time \glspl{cdf} obtained using our \pf{} model. These are compared to the results one might obtain using the currently deployed schedule-delay predictions, which only provide a binary (`Yes' or `No') prediction.


<<eta_journey_arrival_prep,echo=FALSE,cache=TRUE,message=FALSE,fig.height=5,out.width="\\textwidth",fig.cap="Route options",fig.align="center">>=

suppressPackageStartupMessages({
  library(tidyverse)
  library(ggmap)
  library(RSQLite)
})

curd <- setwd("../../data")
source("load_data.R")
setwd(curd)

# first find a trip to predict ...
start <- "125 Balmoral Drive, Auckland"
end <- "38 Princes Street, Auckland"

coords <- tibble(
  which = c("Start", "End"),
  lat = c(-36.888387, -36.852788),
  lon = c(174.754387, 174.768420)
)

routeA <- c("25B", "25L")
routeB <- c("27H", "27W")

stops <- tibble(
  which = c("Start", "End", "Start", "End"),
  option = paste("Option", c("A", "A", "B", "B")),
  id = c("8417", "7089", "8517", "7147"),
  walk = c(9, 2, 11, 3)
)

con <- dbConnect(SQLite(), db)
route_info <- con %>% tbl("routes") %>%
  filter(
    route_short_name %in% c(routeA, routeB) &
    version == 82.21 &
    (
      route_long_name %like% "%To Britomart%" |
      route_long_name %like% "%To City Centre%"
    )
  ) %>%
  select(route_id, route_short_name, route_long_name) %>%
  left_join(
    con %>% tbl("trips") %>% group_by(route_id) %>%
      summarize(shape_id = min(shape_id, na.rm = TRUE)),
    by = "route_id"
  ) %>%
  collect() %>%
  mutate(
    option = paste("Option", ifelse(route_short_name %in% routeA, "A", "B"))
  )
trip_info <- con %>% tbl("trips") %>%
  filter(route_id %in% !!route_info$route_id) %>%
  select(trip_id, route_id) %>%
  left_join(
    con %>% tbl("stop_times") %>% filter(stop_sequence == 1) %>%
      select(trip_id, departure_time) %>%
      rename(trip_start_time = departure_time),
    by = "trip_id"
  ) %>%
  collect() %>%
  mutate(
    trip_start_time = stringr::str_sub(trip_start_time, 1, 5)
  )
sids <- tapply(route_info$shape_id, route_info$option, function(x) x[1])
shapes <- con %>% tbl("shapes") %>%
  filter(shape_id %in% !!sids) %>%
  select(shape_id, shape_pt_lat, shape_pt_lon, shape_pt_sequence) %>%
  arrange(shape_id, shape_pt_sequence) %>%
  collect() %>%
  filter(
    shape_pt_lat > coords$lat[1] - 0.003 &
    shape_pt_lat < coords$lat[2] + 0.003
  ) %>%
  mutate(
    option = as.character(
      sapply(shape_id, function(id) names(sids)[which(sids == id)])
    )
  )
stop_info <- con %>% tbl("stops") %>%
  filter(stop_code %in% !!stops$id & version == 82.21) %>%
  select(stop_id, stop_code, stop_lon, stop_lat) %>%
  collect()
stops <- stops %>% left_join(stop_info, by = c("id" = "stop_code"))
route_info <- route_info %>%
  mutate(
    from_seq = c(23L, 19L, 28L, 29L),
    to_seq = c(34L, 30L, 42L, 43L)
  )
dbDisconnect(con)

xlim <- range(shapes$shape_pt_lon)
ylim <- range(shapes$shape_pt_lat)

TSTART <- as.POSIXct("2019-08-29 13:20:00")
TEND <- as.POSIXct("2019-08-29 14:00:00")

## Get a map:
map <- get_stamenmap(c(xlim[1], ylim[1], xlim[2], ylim[2]), zoom = 15)
ggmap(map) +
  geom_path(
    aes(shape_pt_lon, shape_pt_lat, group = option, colour = option),
    data = shapes,
    lwd = 2
  ) +
  geom_path(
    aes(shape_pt_lon, shape_pt_lat, group = option, colour = option),
    data = shapes %>% filter(option == "Option A"),
    lwd = 2,
    lty = 2
  ) +
  geom_segment(
    aes(lon, lat, xend = lon, yend = lat + 0.0015),
    data = coords
  ) +
  geom_point(aes(lon, lat),
    data = coords,
    size = 3
  ) +
  geom_label(aes(lon, lat, label = which),
    data = coords,
    nudge_y = 0.0015
  ) +
  geom_point(aes(stop_lon, stop_lat, colour = option),
    data = stops,
    shape = 21,
    fill = "white",
    size = 3,
    stroke = 2
  ) +
  theme_void() +
  labs(colour = "")

@

\subsection{Choosing between two alternative routes}
\label{sec:journey_simple}

In this scenario, a passenger lives within walking distance of two major roads, along which various routes travel into the central city, as displayed in \cref{fig:eta_journey_arrival_prep}. The passenger needs to decide which route option to take before leaving home and let's say they have an appointment in town at \Sexpr{format(TEND, TIME_FMT)}. At \Sexpr{format(TSTART, TIME_FMT)}, they consult the real-time app on their phone before deciding whether to walk to route option A or B. Factors that could influence their decision include:
\begin{itemize}
\item how long they will have to wait for the next bus;
\item the probability that they will arrive in time for the next bus, and how long until the bus after it;
\item the probability of arriving at their destination on-time, and how early they will be; and
\item the overall length of the journey.
\end{itemize}
We can provide information relating to these questions using the \glspl{cdf} of arrival time at the start and end stops. Walking times at either end of the journey can also be accounted for.


<<eta_journey_arrival,echo=FALSE,cache=TRUE,dependson="eta_journey_arrival_prep",message=FALSE,fig.width=8,fig.height=5,out.width="\\textwidth",fig.cap="ETA predictions for two route options. The coloured curves represent the CDF of arrival time for individual trips made at 7~am. The vertical black lines indicate the estimated walking time (according to Google Maps) from the Start location to each stop.",fig.align="center">>=

con <- dbConnect(SQLite(), "data/eta_quantiles.sqlite")
trip_etas <- con %>% tbl("etas")

trip_results <- lapply(seq_len(nrow(route_info)),
  function(i) {
    rid <- route_info$route_id[i]
    tids <- trip_info %>% filter(route_id == rid) %>% pull(trip_id)
    rseq <- c(route_info$from_seq[i], route_info$to_seq[i])
    trip_etas %>%
      filter(
        trip_id %in% tids &
        stop_sequence %in% rseq
      ) %>%
      collect()
  }
) %>%
  bind_rows() %>%
  mutate(timestamp = as.POSIXct(timestamp, origin = "1970-01-01")) %>%
  left_join(trip_info, by = "trip_id")
dbDisconnect(con)


# commuter ready to leave at 7am
trip_results_after_7 <- trip_results %>%
  group_by(trip_start_time) %>%
  filter(timestamp <= TSTART) %>%
  group_modify(~{
    .x %>% mutate(
      in_range = any(
        .x$timestamp + eta * 60 >= TSTART &
        .x$timestamp + eta * 60 <= TEND
      )
    )
  }) %>%
  ungroup() %>%
  filter(in_range) %>%
  select(trip_id, trip_start_time, stop_sequence, timestamp, eta, quantile,
    actual_arrival, time_until_arrival, gtfs_eta, route_id) %>%
  left_join(
    route_info %>% select(route_id, route_short_name, option, from_seq, to_seq),
    by = "route_id"
  ) %>%
  mutate(
    is_origin = as.integer(stop_sequence == from_seq),
    is_destination = as.integer(stop_sequence == to_seq)
  )

trip_eta_results <- trip_results_after_7 %>%
  filter(is_origin == 1 & time_until_arrival > 0) %>%
  group_by(trip_id) %>%
  group_modify(~{
    .x %>%
      filter(timestamp == max(.x$timestamp)) %>%
      mutate(
        keep_me = max(timestamp + eta * 60) >= TSTART
      ) %>%
      arrange(eta)
  }) %>%
  filter(keep_me) %>%
  left_join(stops %>% filter(which == "Start") %>% select(option, walk))

library(ggrepel)

ggplot(trip_eta_results, aes(timestamp + eta * 60, quantile,
  group = trip_id, colour = route_short_name)) +
  geom_step() +
  geom_label_repel(
    aes(y = 0, label = trip_start_time),
    data = trip_eta_results %>% filter(quantile == 0),
    ylim = c(NA, 0),
    direction = "x",
    nudge_y = -0.05,
    segment.colour = "gray",
    size = 3
  ) +
  facet_grid(option ~ .) +
  geom_vline(aes(xintercept = TSTART + walk * 60), lty = 2) +
  geom_vline(aes(xintercept = TSTART)) +
  geom_text_repel(
    aes(
      x = TSTART + walk * 60,
      y = 0.5,
      label = paste(walk, "min walk"),
      group = NULL,
      colour = NULL
    ),
    data = stops %>% filter(which == "Start"),
    angle = 90,
    nudge_x = -30
  ) +
  # geom_point(aes(timestamp + gtfs_eta, 0.5), pch = 4) +
  theme_classic() +
  theme(strip.background = element_blank()) +
  scale_x_datetime(
    sprintf("Estimated arrival time at %s:%s%s",
      as.integer(format(TSTART, "%H")),
      format(TSTART, "%M"),
      format(TSTART, "%P")
  )) +
  scale_y_continuous("P(A < a)",
    limits = c(-0.1, 1)
  ) +
  labs(colour = "Route")


@

<<cond_section,echo=FALSE,results="asis">>=
if (format(TSTART, "%H:%M") != "13:20") {
  cat("\\begin{itemize}\\item The time has changed since this was written!\\end{itemize}")
}
@

\Cref{fig:eta_journey_arrival} displays the \glspl{cdf} of all active trips\footnote{Our application currently only estimates arrival times for active trips.} along the two route options at \Sexpr{format(TSTART, TIME_FMT)} when the passenger is about to leave home (solid line), with dashed lines representing the passenger's arrival time at the stops (accounting for walking time). Below each \gls{cdf}, which are coloured by route number, is a label indicating the trip's start time, which is the simplest method of identifying trips. For option A, there appears to be a minimal chance of catching the 1:05~pm 25B, but a good chance of catching the 1:10~pm 25L, with the additional safety of another 25B not long after. As for option B, there is a slightly smaller chance of catching the 1:15~pm 27H, but if missed, it is unclear how long the wait for the next but will be.


<<eta_journey_arriveby,echo=FALSE,cache=TRUE,dependson="eta_journey_arrival",message=FALSE,fig.width=8,fig.height=5,out.width="\\textwidth",fig.cap="ETA predictions for two route options. The coloured curves represent the CDF of arrival time for individual trips made at 7~am. The vertical black lines indicate the estimated walking time (according to Google Maps) from the Start location to each stop.",fig.align="center">>=


# commuter ready to leave at 7am
trip_results_before_8 <- trip_results %>%
  group_by(trip_start_time) %>%
  filter(timestamp > TSTART) %>%
  filter(trip_id %in% trip_eta_results$trip_id) %>%
  select(trip_id, trip_start_time, stop_sequence, timestamp, eta, quantile,
    actual_arrival, time_until_arrival, gtfs_eta, route_id) %>%
  left_join(
    route_info %>% select(route_id, route_short_name, option, from_seq, to_seq),
    by = "route_id"
  ) %>%
  mutate(
    is_origin = as.integer(stop_sequence == from_seq),
    is_destination = as.integer(stop_sequence == to_seq)
  )


trip_eta_results2 <- trip_results_before_8 %>%
  filter(is_destination == 1) %>%
  group_by(trip_id) %>%
  group_modify(~{
    .x %>% filter(timestamp == min(.x$timestamp)) %>%
      arrange(eta)
  }) %>%
  left_join(stops %>% filter(which == "End") %>% select(option, walk))

ggplot(trip_eta_results2, aes(timestamp + eta * 60, quantile,
  group = trip_id, colour = route_short_name)) +
  geom_step() +
  geom_label(
    aes(label = trip_start_time),
    data = trip_eta_results2 %>% filter(quantile == 0)
  ) +
  facet_grid(option ~ .) +
  geom_vline(aes(xintercept = TEND - walk * 60), lty = 3) +
  geom_vline(aes(xintercept = TEND)) +
  #geom_vline(aes(xintercept = actual_arrival, colour = route_short_name)) +
  geom_text(
    aes(
      x = TEND - walk * 60,
      y = 0.5,
      label = paste(walk, "min walk"),
      group = NULL,
      colour = NULL
    ),
    data = stops %>% filter(which == "End"),
    angle = -90,
    nudge_x = 60
  ) +
  # geom_point(aes(timestamp + gtfs_eta, 0.5), pch = 4) +
  theme_classic() +
  theme(strip.background = element_blank()) +
  scale_x_datetime(
    sprintf("Estimated arrival time at %s:%s%s",
      as.integer(format(TSTART, "%H")),
      format(TSTART, "%M"),
      format(TSTART, "%P")
  )) +
  scale_y_continuous("P(A < a)") +
  labs(colour = "Route")


@

Based on the arrival results alone, I would choose to walk to option A as it has a good chance of a short wait time; however, the passenger also needs to consider their appointment at 9~am. \Cref{fig:eta_journey_arriveby} provides \glspl{cdf} of each trip's arrival time at the final stop, as well as vertical lines representing the appointment time (solid) and necessary arrival time to allow for walking time (dotted). None of the trips show definitive signs of being late, although the passenger would likely hope to catch the 1:10~pm 25L to maximise their chances of arriving on-time.


<<eta_journey_results,echo=FALSE,cache=TRUE,dependson="eta_journey_arriveby",message=FALSE,fig.width=8,fig.height=5,out.width="\\textwidth",fig.cap="Results of the journey planning application, including actual arrival times.">>=

if (interactive())
  trip_eta_results %>%
    group_by(trip_id) %>%
    summarize(
      timestamp = first(timestamp),
      trip_start_time = first(trip_start_time),
      route_short_name = first(route_short_name),
      option = first(option),
      walk = first(walk),
      eta_q05 = timestamp + max(eta[quantile <= 0.025]) * 60,
      eta_q50 = timestamp + max(eta[quantile <= 0.5]) * 60,
      eta_q95 = timestamp + max(eta[quantile <= 0.95]) * 60,
      actual = as.POSIXct(first(actual_arrival), origin = "1970-01-01"),
      gtfs = timestamp + first(gtfs_eta)
    ) %>%
    ggplot(aes(y = trip_start_time, colour = route_short_name)) +
      geom_point(aes(eta_q50)) +
      geom_segment(
        aes(
          x = eta_q05, xend = eta_q95, yend = trip_start_time
        )
      ) +
      facet_grid(option+route_short_name ~ ., scales = "free_y") +
      geom_vline(aes(xintercept = TSTART + walk * 60), lty = 3) +
      geom_vline(aes(xintercept = TSTART)) +
      geom_point(aes(actual), colour = "black") +
      geom_point(aes(gtfs), shape = 4)


if (interactive())
  trip_eta_results2 %>%
    group_by(trip_id) %>%
    summarize(
      timestamp = first(timestamp),
      trip_start_time = first(trip_start_time),
      route_short_name = first(route_short_name),
      option = first(option),
      walk = first(walk),
      eta_q05 = timestamp + max(eta[quantile <= 0.025]) * 60,
      eta_q50 = timestamp + max(eta[quantile <= 0.5]) * 60,
      eta_q95 = timestamp + max(eta[quantile <= 0.95]) * 60,
      actual = as.POSIXct(first(actual_arrival), origin = "1970-01-01"),
      gtfs = timestamp + first(gtfs_eta)
    ) %>%
    ggplot(aes(y = trip_start_time, colour = route_short_name)) +
      geom_point(aes(eta_q50)) +
      geom_segment(
        aes(
          x = eta_q05, xend = eta_q95, yend = trip_start_time
        )
      ) +
      facet_grid(option+route_short_name ~ ., scales = "free_y") +
      geom_vline(aes(xintercept = TEND - walk * 60), lty = 3) +
      geom_vline(aes(xintercept = TEND)) +
      geom_point(aes(actual), colour = "black") +
      geom_point(aes(gtfs), shape = 4)


e_wait <- function(x, q) {
  if (length(x) == 0) return(NA)
  # standardise
  q <- (q - min(q)) / diff(range(q))
  p <- c(0, diff(q))
  sum(x * p) / 60
}

trip_eta_results_comb <- bind_rows(trip_eta_results, trip_eta_results2) %>%
  select(trip_id, trip_start_time, timestamp, eta, quantile,
    actual_arrival, gtfs_eta, route_short_name, option, is_origin, walk) %>%
    mutate(
      eta_time = timestamp + 60 * eta,
      after_walk = ifelse(is_origin, eta_time >= TSTART + 60 * walk, NA),
      catch_wait = ifelse(is_origin,
        as.integer(eta_time) - as.integer(TSTART) - 60 * walk,
        NA
      ),
      before_walk = ifelse(is_origin, NA, eta_time <= TEND - 60 * walk),
      arrive_wait = ifelse(is_origin, NA,
        as.integer(TEND) -  60 * walk - as.integer(eta_time)
      )
    ) %>%
    group_by(trip_id) %>%
    summarize(
      option = first(option),
      walk_to = first(walk[is_origin]),
      walk_from = first(walk[!is_origin]),
      trip_start_time = first(trip_start_time),
      route_short_name = first(route_short_name),
      timestamp = first(timestamp),
      # P(catch | leave now)
      p_catch = round(1 - min(c(1, quantile[after_walk & is_origin])), 2),
      e_wait = round(e_wait(
        catch_wait[after_walk & is_origin],
        quantile[after_walk & is_origin]
      ), 1),
      journey_start = max(eta_time[quantile <= 0.5 & is_origin]),
      journey_end = max(eta_time[quantile <= 0.5 & !is_origin]),
      journey_length = round((as.integer(journey_end) - as.integer(journey_start)) / 60, 1),
      p_arrive = round(max(c(0, quantile[before_walk & !is_origin])), 2),
      gtfs_start = first((timestamp + gtfs_eta)[is_origin]),
      gtfs_end = first((timestamp + gtfs_eta)[!is_origin]),
      actual_start =
        as.POSIXct(first(actual_arrival[is_origin]), origin = "1970-01-01"),
      actual_end =
        as.POSIXct(first(actual_arrival[!is_origin]), origin = "1970-01-01")
    ) %>%
    arrange(option, trip_start_time) %>%
    select(option, walk_to, walk_from, route_short_name, trip_start_time,
      p_catch, journey_length, p_arrive, gtfs_start, gtfs_end,
      actual_start, actual_end) %>%
    mutate(
      did_catch = actual_start >= TSTART + 60 * walk_to,
      did_arrive = actual_end <= TEND - 60 * walk_from,
      gtfs_catch = gtfs_start >= TSTART + 60 * walk_to,
      gtfs_arrive = gtfs_end <= TEND - 60 * walk_from,
      gtfs_start = format(gtfs_start, "%H:%M"),
      gtfs_end = format(gtfs_end, "%H:%M"),
      actual_tt = as.integer(actual_end) - as.integer(actual_start),
      actual_start = format(actual_start, "%H:%M"),
      actual_end = format(actual_end, "%H:%M")
    )


tab <- trip_eta_results_comb %>%
  select(option, route_short_name, trip_start_time, p_catch, p_arrive,
    gtfs_catch, gtfs_arrive, did_catch, did_arrive) %>%
  mutate(
    option = gsub("Option ", "", option),
    gtfs_catch = ifelse(gtfs_catch, "Y", "N"),
    gtfs_arrive = ifelse(gtfs_arrive, "Y", "N"),
    did_catch = ifelse(did_catch, "Y", "N"),
    did_arrive = ifelse(did_arrive, "Y", "N")
  ) %>%
  rename(
    "Option" = option,
    "Route" = route_short_name,
    "Trip" = trip_start_time,
    "$P_\\text{catch}$" = p_catch,
    "$P_\\text{arrive}$" = p_arrive,
    "Catch" = gtfs_catch,
    "Arrive" = gtfs_arrive,
    "Caught" = did_catch,
    "Arrived" = did_arrive
  )

options(knitr.kable.NA = "")
lineAfter <- max(which(tab$Option == "A"))

tab$Option <- ifelse(
  seq_len(nrow(tab)) %in% tapply(seq_len(nrow(tab)), tab$Option, min),
  tab$Option, ""
)
knitr::kable(
    tab,
    format = "latex",
    booktabs = TRUE,
    caption = "Journey planning.",
    escape = FALSE,
    linesep = ""
) %>%
  kableExtra::row_spec(lineAfter, extra_latex_after = "\\midrule") %>%
  kableExtra::kable_styling(font_size = 8) %>%
  kableExtra::add_header_above(
    c("", "", "", "Particle filter" = 2,
    "GTFS" = 2, "Outcome" = 2)
  )
@


The \glspl{cdf} allow easy calculation of the predicted probability of success in each scenario, displayed in \cref{tab:eta_journey_results}. Additionally, the binary (`Yes' or `No') predictions made using the schedule-delay method are displayed for comparison, as well as the eventual outcome. That is, would the passenger have caught the bus and did it arrive on time? All of the predictions based on the \pf{} arrival time \glspl{cdf} are valid: small probabilities correspond to an outcome of `No' and large probabilities ($>0.8$) to `Yes'. There was a discrepancy for the 1:15~pm 25B, which arrived at the destination on time: the schedule-delay incorrectly predicted `No', while our method predicted an 81\% chance of success.


<<eta_journey_results_avg,echo=FALSE,cache=TRUE,dependson=-1,message=FALSE,fig.width=8,fig.height=2.5,out.width="\\textwidth",fig.cap=sprintf("Results of performing the same journey planning prediction with different starting times (from %s to %s), using the same start and end locations. Observations are whether or not the passenger would have arrived at the stop before the bus, jittered to better see each observation. Predictive probabilities of 0 and 1 that were correctly estimated have been removed.", format(min(tstart), TIME_FMT), format(max(tstart), TIME_FMT)),fig.align="center">>=

# 5-minute intervals from 6am--6pm:
tstart <-
  seq(as.POSIXct("2019-08-29 9:00:00"), as.POSIXct("2019-08-29 15:00:00"),
    by = 5 * 60)
# end time is 30-minute intervals (so 15-45 minute gaps)
tend <- rep(
  seq(min(tstart) - 30 * 60, max(tstart), by = 30 * 60) + 60 * 60,
  each = 6)[-(1:3)][seq_along(tstart)]

all_results_file <- "data/all_results.rda"
if (file.exists(all_results_file)) {
  load(all_results_file)
} else {
  all_results <- pbapply::pblapply(seq_along(tstart),
    function(i) {
      TSTART <- tstart[i]
      TEND <- tend[i]

      ## part 1: leave after
      res_leave_after <- trip_results %>%
        group_by(trip_start_time) %>%
        filter(timestamp <= TSTART) %>%
        group_modify(~{
          .x %>% mutate(
            in_range = any(
              .x$timestamp + eta * 60 >= TSTART &
              .x$timestamp + eta * 60 <= TEND
            )
          )
        }) %>%
        ungroup() %>%
        filter(in_range) %>%
        select(trip_id, trip_start_time, stop_sequence, timestamp, eta, quantile,
          actual_arrival, time_until_arrival, gtfs_eta, route_id) %>%
        left_join(
          route_info %>% select(route_id, route_short_name, option, from_seq, to_seq),
          by = "route_id"
        ) %>%
        mutate(
          is_origin = as.integer(stop_sequence == from_seq),
          is_destination = as.integer(stop_sequence == to_seq)
        )

      # summarize
      res_eta_results <- res_leave_after %>%
        filter(is_origin == 1 & time_until_arrival > 0) %>%
        group_by(trip_id) %>%
        group_modify(~{
          .x %>%
            filter(timestamp == max(.x$timestamp)) %>%
            mutate(
              keep_me = max(timestamp + eta * 60) >= TSTART
            ) %>%
            arrange(eta)
        }) %>%
        filter(keep_me) %>%
        left_join(
          stops %>% filter(which == "Start") %>% select(option, walk),
          by = "option"
        )


      ## Part 2: arrive by
      res_arrive_before <- trip_results %>%
        group_by(trip_start_time) %>%
        filter(timestamp > TSTART) %>%
        filter(trip_id %in% res_eta_results$trip_id) %>%
        select(trip_id, trip_start_time, stop_sequence, timestamp, eta, quantile,
          actual_arrival, time_until_arrival, gtfs_eta, route_id) %>%
        left_join(
          route_info %>% select(route_id, route_short_name, option, from_seq, to_seq),
          by = "route_id"
        ) %>%
        mutate(
          is_origin = as.integer(stop_sequence == from_seq),
          is_destination = as.integer(stop_sequence == to_seq)
        )


      res_eta_results2 <- res_arrive_before %>%
        filter(is_destination == 1) %>%
        group_by(trip_id) %>%
        group_modify(~{
          .x %>% filter(timestamp == min(.x$timestamp)) %>%
            arrange(eta)
        }) %>%
        left_join(
          stops %>% filter(which == "End") %>% select(option, walk),
          by = "option"
        )

      ## Part 3: summarize probabilities, actuals
      res_comb <- bind_rows(res_eta_results, res_eta_results2) %>%
        select(trip_id, trip_start_time, timestamp, eta, quantile,
          actual_arrival, gtfs_eta, route_short_name, option, is_origin, walk) %>%
          mutate(
            eta_time = timestamp + 60 * eta,
            after_walk = ifelse(is_origin, eta_time >= TSTART + 60 * walk, NA),
            catch_wait = ifelse(is_origin,
              as.integer(eta_time) - as.integer(TSTART) - 60 * walk,
              NA
            ),
            before_walk = ifelse(is_origin, NA, eta_time <= TEND - 60 * walk),
            arrive_wait = ifelse(is_origin, NA,
              as.integer(TEND) -  60 * walk - as.integer(eta_time)
            )
          ) %>%
          group_by(trip_id) %>%
          summarize(
            option = first(option),
            walk_to = first(walk[is_origin]),
            walk_from = first(walk[!is_origin]),
            trip_start_time = first(trip_start_time),
            route_short_name = first(route_short_name),
            timestamp = first(timestamp),
            # P(catch | leave now)
            p_catch = round(1 - min(c(1, quantile[after_walk & is_origin])), 2),
            e_wait = round(e_wait(
              catch_wait[after_walk & is_origin],
              quantile[after_walk & is_origin]
            ), 1),
            journey_start = max(eta_time[quantile <= 0.5 & is_origin]),
            journey_end = max(eta_time[quantile <= 0.5 & !is_origin]),
            journey_length = round((as.integer(journey_end) - as.integer(journey_start)) / 60, 1),
            p_arrive = round(max(c(0, quantile[before_walk & !is_origin])), 2),
            gtfs_start = first((timestamp + gtfs_eta)[is_origin]),
            gtfs_end = first((timestamp + gtfs_eta)[!is_origin]),
            actual_start =
              as.POSIXct(first(actual_arrival[is_origin]), origin = "1970-01-01"),
            actual_end =
              as.POSIXct(first(actual_arrival[!is_origin]), origin = "1970-01-01")
          ) %>%
          arrange(option, trip_start_time) %>%
          select(option, walk_to, walk_from, route_short_name, trip_start_time,
            p_catch, journey_length, p_arrive, gtfs_start, gtfs_end,
            actual_start, actual_end) %>%
          mutate(
            did_catch = actual_start >= TSTART + 60 * walk_to,
            did_arrive = actual_end <= TEND - 60 * walk_from,
            gtfs_catch = gtfs_start >= TSTART + 60 * walk_to,
            gtfs_arrive = gtfs_end <= TEND - 60 * walk_from,
            gtfs_start = format(gtfs_start, "%H:%M"),
            gtfs_end = format(gtfs_end, "%H:%M"),
            actual_start = format(actual_start, "%H:%M"),
            actual_end = format(actual_end, "%H:%M"),
          )


      list(
        leave_at = TSTART,
        arrive_by = TEND,
        cdf_leave = res_eta_results,
        cdf_arrive = res_eta_results2,
        summary = res_comb
      )
    }
  )
  save(all_results, file = all_results_file)
}

## Now plot p-catch versus did_catch
mdata <- map(all_results, "summary") %>%
  bind_rows %>%
  mutate(
    did_catch = as.integer(did_catch),
    did_arrive = as.integer(did_arrive),
    gtfs_catch = ifelse(gtfs_catch == 1, "Yes", "No"),
    gtfs_arrive = ifelse(gtfs_arrive == 1, "Yes", "No")
  )

library(patchwork)

pCATCH <- mdata %>%
  filter(
    (p_catch > 0 | did_catch) &
    (p_catch < 1 | !did_catch)
  ) %>%
  ggplot(aes(p_catch + rnorm(length(p_catch), 0, 0.01), did_catch)) +
    ggbeeswarm::geom_beeswarm(
      #aes(colour = gtfs_catch),
      groupOnX = FALSE,
      priority = "random"
    ) +
    #geom_smooth(colour = "gray") +
    theme_classic() +
    scale_x_continuous("Predictive probabilty of catching the bus") +
    scale_y_continuous("Capture outcome",
      breaks = 0:1,
      labels = c("No", "Yes")
    ) +
    labs(colour = "GTFS prediction")
    #facet_grid(gtfs_catch~.)

pARRIVE <- mdata %>%
  filter(
    (p_arrive > 0 | did_arrive) &
    (p_arrive < 1 | !did_arrive)
  ) %>%
  ggplot(aes(p_arrive + rnorm(length(p_arrive), 0, 0.01), did_arrive)) +
    ggbeeswarm::geom_beeswarm(
      #aes(colour = gtfs_arrive),
      groupOnX = FALSE,
      priority = "random"
    ) +
    #geom_smooth(colour = "gray") +
    theme_classic() +
    scale_x_continuous("Predictive probabilty of arriving on time") +
    scale_y_continuous("Arrival outcome",
      breaks = 0:1,
      labels = c("No", "Yes")
    ) +
    labs(colour = "GTFS prediction")
    #facet_grid(gtfs_arrive~.)

pCATCH + pARRIVE + plot_layout(guide = "collect") &
  theme(legend.position = "bottom")

gtfs_catch_tab <- table(
  gtfs = mdata$gtfs_catch,
  outcome = ifelse(mdata$did_catch, "Yes", "No")
)
gtfs_catch_pc <-
  round(sweep(gtfs_catch_tab, 1, rowSums(gtfs_catch_tab), "/"), 2)

gtfs_arrive_tab <- table(
  gtfs = mdata$gtfs_arrive,
  outcome = ifelse(mdata$did_arrive, "Yes", "No")
)
gtfs_arrive_pc <-
  round(sweep(gtfs_arrive_tab, 1, rowSums(gtfs_arrive_tab), "/"), 2)

tab <- cbind(
  "GTS Prediction" = c("No", "Yes"),
  format(gtfs_catch_pc, nsmall = 2L, digits = 2L),
  NA,
  format(gtfs_arrive_pc, nsmall = 2L, digits = 2L)
)

options(knitr.kable.NA = "")
knitr::kable(
  tab,
  row.names = FALSE,
  format = "latex",
  booktabs = TRUE,
  caption = "GTFS prediction results over all journeys, with the displayed values representing the proportion of outcomes in each cell (rows are conditioned by the GTFS prediction of Yes or No. ",
  escape = FALSE,
  linesep = ""
) %>%
  kableExtra::add_header_above(
    c(" ", "Catch bus" = 2, "", "Arrive on time" = 2)
  ) %>%
  kableExtra::add_header_above(
    c("", "Observed outcome" = 5)
  ) %>%
  kableExtra::kable_styling(font_size = 8)


## the same for GTFS?
#mdata %>%
  #ggplot(aes(gtfs_catch, did_catch)) +
  #  geom_col()

#mdata %>% select(p_catch, did_catch) %>% mutate(p_catch=as.integer(p_catch>0.25)) %>% table

## Some graph to show changing value of p_catch threshold and reliability
# (true positive vs false positive) compared to GTFS
# -> advantage is that we can change the threshold; GTFS cannot.

@

The results in \cref{fig:eta_journey_arrival,fig:eta_journey_arriveby} and \cref{tab:eta_journey_results} are based on \emph{one single forecast} made at \Sexpr{format(TSTART, TIME_FMT)}. To evaluate the overall performance of our prediction method, we repeated the process described above in 5~minute intervals over the off-peak period from \Sexpr{format(min(tstart), TIME_FMT)} to \Sexpr{format(max(tstart), TIME_FMT)}. For the appointment time, we used 30~minute intervals allowing for 15--45 minutes for the journey: leaving between 9:15~am and 9:45~am had a targetted arrival time of 8:00~am; 9:45~am--10:15~am targetted 8:30~am; and so on. The probabilities of catching the bus and arriving on time were calculated for each case. \Cref{fig:eta_journey_results_avg}, graphs the distribution of predicted probabilities for each of the two outcomes, for both catching the bus (left) and arriving on time (right). For most of the buses that arrived before the passenger, our method predicted capture probability below 50\%, though more buses which arrived after the passenger also had capture probabilities below 50\%. As for the arrival outcome, the maximum probability of arriving on time for buses which did not was 75\%, whereas a few buses which did arrive on time had small (< 50\%) probabilities of doing so.


For comparison, \cref{tab:eta_journey_results_avg} presents a two-way contingency table for the binary schedule-delay predictions, with the predicted outcomes in rows. Where the schedule-delay predicted that the bus would arrive after the passenger, it was correct \Sexpr{round(100 * gtfs_catch_pc[2,2])}\% of the time. When it predicted the bus would arrive first, it had a \Sexpr{round(100 * gtfs_catch_pc[1,1])}\% success rate. As for the arrival, in all cases that the schedule-delay predicted the bus would arrive on time, it was correct, versus only \Sexpr{round(100 * gtfs_arrive_pc[1,1])}\% when it predicted the bus would be late. Overall, the schedule-delay method correctly predicted the bus capture outcome in \Sexpr{round(100 * sum(diag(gtfs_catch_tab)) / sum(gtfs_catch_tab))}\% of cases and correctly predicted the on-time arrival outcome in \Sexpr{round(100 * sum(diag(gtfs_arrive_tab)) / sum(gtfs_arrive_tab))}\% of cases.


In both methods, predicting bus capture is more accurate than predicting on-time arrival, which is acceptable considering the difference in forecast length: about 10~minutes for bus capture versus about 30~minutes for arrival. The schedule-delay predictions have a 1-in-10 chance of missing the bus, while our \pf{} provides a less definite prediction (such as 75\%), opening up the opportunity for passengers to make more informed decisions based on these probabilities and the importance of their constraints. In contrast, the schedule-delay method provides, at best, the predicted arrival time as a singular point estimate with no associated uncertainty, allowing only a `Yes' or `No' prediction to be made.


\subsection{Planning a multi-stage journey}
\label{sec:journey_transfer}

A more complex scenario is one in which the passenger must transfer from one route to another. Transfer journeys are common among travellers commuting from further afield, and occur when there is no single route between their origin and destination, as is demonstrated in \cref{fig:eta_journey_arrival_prep}. In this scenario, the passenger must first catch a bus along route group A\footnote{We use route groups since there are several different routes which make the same journey, as can be seen with route group B in the south-west of \cref{fig:eta_journey_arrival_prep}.} to the stop marked ``Transfer'', at which point they disembark and wait for the next bus along route group B to get to their final destination.


<<eta_journey_transfer_prep,echo=FALSE,cache=TRUE,warning=FALSE,message=FALSE,fig.height=5,out.width="\\textwidth",fig.cap="Transfer options",fig.align="center">>=

suppressPackageStartupMessages({
  library(tidyverse)
  library(ggmap)
  library(RSQLite)
})

curd <- setwd("../../data")
source("load_data.R")
setwd(curd)


## Let's try that all again ...
DATE <- "2019-08-29"
routes <- c("27H", "27W", "24R", "24B", "22R", "22N")

stops <- tibble(
  which = c("Origin", "Transfer", "Destination"),
  id = c("8513", "7151", "1090"),
)

con <- dbConnect(SQLite(), db)
route_info <- con %>% tbl("routes") %>%
  filter(
    route_short_name %in% routes &
    version == 82.21 &
    (
      route_long_name %like% "%To Britomart%" |
      route_long_name %like% "%To City Centre%"
    ) &
    !route_long_name %like% "Blockhouse%"
  ) %>%
  select(route_id, route_short_name, route_long_name) %>%
  left_join(
    con %>% tbl("trips") %>% group_by(route_id) %>%
      summarize(shape_id = min(shape_id, na.rm = TRUE)),
    by = "route_id"
  ) %>%
  collect() %>%
  mutate(
    transfer = as.factor(ifelse(route_short_name %in% c("27H", "27W"), 1, 2))
  )
trip_info <- con %>% tbl("trips") %>%
  filter(route_id %in% !!route_info$route_id) %>%
  select(trip_id, route_id, service_id) %>%
  left_join(
    con %>% tbl("stop_times") %>% filter(stop_sequence == 1) %>%
      select(trip_id, departure_time) %>%
      rename(trip_start_time = departure_time),
    by = "trip_id"
  ) %>%
  left_join(
    con %>% tbl("calendar") %>% select(service_id, monday),
    by = "service_id"
  ) %>%
  filter(monday == 1) %>%
  select(-monday, -service_id) %>%
  collect() %>%
  mutate(
    trip_start_time = stringr::str_sub(trip_start_time, 1, 5),
    trip_start = as.POSIXct(paste(DATE, trip_start_time))
  )
shapes <- con %>% tbl("shapes") %>%
  filter(shape_id %in% !!route_info$shape_id) %>%
  select(shape_id, shape_pt_lat, shape_pt_lon, shape_pt_sequence) %>%
  arrange(shape_id, shape_pt_sequence) %>%
  collect() %>%
  left_join(route_info, by = "shape_id")
stop_info <- con %>% tbl("stops") %>%
  filter(stop_code %in% !!stops$id & version == 82.21) %>%
  select(stop_id, stop_code, stop_lon, stop_lat) %>%
  collect()
stops <- stops %>% left_join(stop_info, by = c("id" = "stop_code"))
trip_stops <- con %>% tbl("stop_times") %>%
  filter(
    trip_id %in% !!trip_info$trip_id &
    stop_id %in% !!stop_info$stop_id
  ) %>%
  collect()
dbDisconnect(con)


xlim <- extendrange(
  range(shapes %>% filter(route_short_name == "27W") %>% pull(shape_pt_lon)),
  f = 0.
)
ylim <- extendrange(range(stops$stop_lat), f = 0.1)

## Get a map:
map <- get_stamenmap(c(xlim[1], ylim[1], xlim[2], ylim[2]), zoom = 14)
ggmap(map) +
  geom_path(
    aes(shape_pt_lon, shape_pt_lat,
      group = route_short_name, colour = transfer),
    data = shapes %>% arrange(shape_pt_sequence),
    lwd = 2,
    na.rm = TRUE
  ) +
  geom_path(
    aes(shape_pt_lon, shape_pt_lat,
      group = route_short_name, colour = transfer),
    data = shapes %>% filter(route_short_name == "24B"),
    lwd = 2,
    lty = 2
  ) +
  geom_segment(
    aes(
      stop_lon, stop_lat,
      xend = stop_lon + c(-0.003, -0.004, 0),
      yend = stop_lat + c(0, 0, -0.0015)
    ),
    data = stops,
    lwd = 1.5
  ) +
  geom_label(aes(stop_lon, stop_lat, label = which),
    data = stops,
    nudge_x = c(-0.0035, -0.004, 0),
    nudge_y = c(0, 0, -0.0015)
  ) +
  geom_point(aes(stop_lon, stop_lat),
    data = stops,
    shape = 21,
    fill = "white",
    size = 3,
    stroke = 2
  ) +
  theme_void() +
  theme(legend.position = "bottom") +
  labs(colour = "Leg")

@



<<eta_journey_transfer_graph,echo=FALSE,cache=TRUE,dependson=-1,fig.height=6,fig.width=8,out.width="\\textwidth",fig.cap="Arrival times",fig.align="center">>=
library(ggrepel)

TSTART <- as.POSIXct(paste(DATE, "13:00:00"))
con <- dbConnect(SQLite(), "data/eta_quantiles.sqlite")
trip_etas <- con %>% tbl("etas") %>%
  filter(
    timestamp <= !!as.integer(TSTART) &
    trip_id %in% !!trip_info$trip_id
  ) %>%
  select(trip_id, stop_sequence, timestamp, eta, quantile,
    gtfs_eta, actual_arrival) %>%
  collect() %>%
  left_join(
    trip_stops %>% select(trip_id, stop_id, stop_sequence),
    by = c("trip_id", "stop_sequence")
  ) %>%
  filter(stop_id %in% stop_info$stop_id)
dbDisconnect(con)

all_stop_arrivals <- trip_etas %>%
  left_join(trip_info, by = "trip_id") %>%
  left_join(route_info, by = "route_id") %>%
  mutate(
    timestamp = as.POSIXct(timestamp, origin = "1970-01-01")
  ) %>%
  group_by(trip_id) %>%
  group_modify(~{
    .x <- .x %>%
      filter(timestamp == max(.x$timestamp))
    if (any(.x$timestamp + .x$eta * 60 > TSTART)) return(.x)
    .x %>% filter(FALSE)
  }) %>%
  ungroup() %>%
  arrange(trip_id, eta) %>%
  left_join(stops %>% select(stop_id, which), by = "stop_id") %>%
  mutate(
    which = factor(which, levels = c("Origin", "Transfer", "Destination"))
  )

# now filter out irrelevant trips...
trips_at_start <- all_stop_arrivals %>%
  filter(which == "Origin" & transfer == 1) %>%
  pull(trip_id) %>% unique
trips_at_transfer <- all_stop_arrivals %>%
  filter(
    which == "Transfer" &
    transfer == 2
  ) %>%
  pull(trip_id) %>% unique

stop_arrivals <- all_stop_arrivals %>%
  filter(trip_id %in% c(trips_at_start, trips_at_transfer)) %>%
  group_by(transfer) %>%
  group_modify(~{
    .x %>% mutate(
      trip_start_time = paste0(
        .y$transfer,
        LETTERS[as.integer(as.factor(trip_start_time))]
      )
    )
  }) %>%
  ungroup()

ggplot(stop_arrivals, aes(timestamp + eta * 60, quantile)) +
  geom_step(
    aes(group = trip_id, colour = transfer)
  ) +
  geom_text_repel(
    aes(y = 0, label = trip_start_time),
    data = stop_arrivals %>% filter(quantile == 0),
    ylim = c(NA, 0),
    direction = "x",
    nudge_y = -0.05,
    segment.colour = "gray",
    size = 3
  ) +
  facet_grid(which ~ .) +
  theme_classic() +
  theme(strip.background = element_blank()) +
  scale_x_datetime("Time") +
  scale_y_continuous("P(A < a)", limits = c(-0.05, 1)) +
  labs(colour = "Leg")

@


Similarly to the previous example, we take one single forecast of all trip arrivals at 1~pm. Walking time has been removed to simplify the example, but could easily be included if desired. \Cref{fig:eta_journey_transfer_graph} shows, for all active trips at \Sexpr{format(TSTART, TIME_FMT)}, their arrival time \glspl{cdf} at the start and transfer stops (for the first leg) and the transfer and end stops (for the second). Additional constraints, such as arrival by a specific time, could, of course, be added; in this instance, however, we are solely interested in how well we can predict a successful transfer from A to B.


Given \glspl{cdf} for two trips arriving at a stop, the probability that a transfer can successfully be made from A to B is calculated by
\begin{equation}
\label{eq:eta_total_prob}
\begin{split}
\Pcatch =
\Pr{A < B} &= \sum_{x=1}^{\infty} \Pr{A < B\,|\,B = x}\Pr{B=x} \\
  &= \sum_{x=1}^\infty
    \Pr{A < x} \Pr{B=x} \\
  &= \sum_{x=1}^\infty
    \Pr{A < x} \left[
      \Pr{B < x + 1} - \Pr{B < x}
    \right],
\end{split}
\end{equation}
which is easily computed from the arrival time \glspl{cdf} obtained from \cref{eq:pf_pdf_arrivaltime}. \Cref{tab:eta_journey_transfer_res} displays the prediction probabilities, along with the binary predictions using the schedule-delay method and the observed outcomes.


<<eta_journey_transfer_res,echo=FALSE,cache=TRUE,dependson=-1>>=

## calculate probability bus A arrives BEFORE bus B at transfer:
transfer_arrivals <- stop_arrivals %>%
  filter(which == "Transfer" & transfer == 1) %>%
  select(trip_id, trip_start_time, timestamp, eta, quantile,
    gtfs_eta, actual_arrival)
transfer_departures <- stop_arrivals %>%
  filter(which == "Transfer" & transfer == 2) %>%
  select(trip_id, trip_start_time, timestamp, eta, quantile,
    gtfs_eta, actual_arrival)

f <- Vectorize(
  function(a, b, what = 1, dat1, dat2) {
    ta <- dat1 %>% filter(trip_start_time == a)
    tb <- dat2 %>% filter(trip_start_time == b)

    if (what == 1) {
      etas <- 0:max(ta$eta, tb$eta)
      ea <- ifelse(etas < max(ta$eta), 0, 1)
      eb <- ifelse(etas < max(tb$eta), 1, 0)

      ea[ta$eta + 1] <- ta$quantile
      eb[tb$eta + 1] <- 1 - tb$quantile

      ea <- cummax(ea)
      eb <- cummin(eb)
      ea <- c(diff(ea), 0)
      return(sum(ea * eb))
    }

    if (what == 2) {
      # gtfs prediction (min between)
      ga <- ta$timestamp[1] + ta$gtfs_eta[1] * 60
      gb <- tb$timestamp[1] + tb$gtfs_eta[1] * 60
      if (ga < gb) return("Y") else return("N")
    }

    if (what == 3) {
      # actual outcome
      da <- ta$actual_arrival[1]
      db <- tb$actual_arrival[1]
      if (da < db) return("Y") else return("N")
    }
  },
  c("a", "b")
)

tab <- tibble(
  L1 = rep(
    sort(unique(transfer_arrivals$trip_start_time)),
    each = length(unique(transfer_departures$trip_start_time))
  ),
  L2 = rep(
    sort(unique(transfer_departures$trip_start_time)),
    length(unique(transfer_arrivals$trip_start_time))
  ),
  p_catch = round(f(L1, L2, 1, transfer_arrivals, transfer_departures), 2),
  gtfs_eta = f(L1, L2, 2, transfer_arrivals, transfer_departures),
  did_catch = f(L1, L2, 3, transfer_arrivals, transfer_departures)
) %>%
  rename(
    "$\\mathbb{P}_\\text{transfer}" = p_catch,
    "GTFS" = gtfs_eta,
    "Outcome" = did_catch,
    "Leg 1" = L1,
    "Leg 2" = L2
  )

nn <- length(unique(transfer_departures$trip_start_time))
tab[["Leg 1"]] <- ifelse(
  seq_len(nrow(tab)) %in% tapply(seq_len(nrow(tab)), tab[["Leg 1"]], min),
  tab[["Leg 1"]], ""
)
knitr::kable(tab,
  format = "latex",
  booktabs = TRUE,
  caption = "Transfer probabilities",
  escape = FALSE,
  linesep = ""
) %>%
  kableExtra::row_spec(nn, extra_latex_after = "\\midrule") %>%
  kableExtra::kable_styling(font_size = 8)


# 5-minute intervals from 6am--6pm:
tstart <- seq(
  as.POSIXct("2019-08-29 9:00:00"),
  as.POSIXct("2019-08-29 15:00:00"),
  by = 5 * 60
)

@


The particle filter predicts transfer probabilities with reasonable accuracy: low probabilities result in negative ('No') outcomes. In contrast, the schedule-delay predictions fail to correctly predict the outcome of a transfer between 1A and 2C: it incorrectly predicted a successful transfer while the particle filter predicted only a 32\% chance of success. Here a passenger could, where applicable, base their decision on how important it is they make the transfer which might depend on frequency or other constraints. While this example is somewhat trivial (it's a short wait for the next bus), there are situations where the headway between trips is 30--60~minutes, in which case---from personal experience---watching your next bus depart just as the one you are on arrives at the station is very frustrating. However, until our application has been updated to make predictions for upcoming (and not just active) trips, we are not yet able to make predictions for such scenarios.


<<eta_journey_transfer_many,echo=FALSE,cache=TRUE,dependson=-1,message=FALSE,fig.width=4,fig.height=2.5,out.width=".5\\textwidth",fig.cap=sprintf("Results of performing the same transfer journey planning prediction with different starting times (from %s to %s). Observations are whether or not the first bus would arrive at the transfer stop before the second bus, jittered to better see each observation. Additionally, predictive probabilities of 0 and 1 have been removed since, after checking, none or these were invalid and only served to distort the figure.", format(min(tstart), "%kh%M"), format(max(tstart), "%kh%M")),fig.align="center">>=


all_results_file <- "data/all_results_transfer.rda"
if (file.exists(all_results_file)) {
  load(all_results_file)
} else {
  all_results <- pbapply::pblapply(seq_along(tstart),
    function(i) {
      TSTART <- tstart[i]
      con <- dbConnect(SQLite(), "data/eta_quantiles.sqlite")
      trip_etas <- con %>% tbl("etas") %>%
        filter(
          timestamp <= !!as.integer(TSTART) &
          trip_id %in% !!trip_info$trip_id
        ) %>%
        select(trip_id, stop_sequence, timestamp, eta, quantile,
          gtfs_eta, actual_arrival) %>%
        collect() %>%
        left_join(
          trip_stops %>% select(trip_id, stop_id, stop_sequence),
          by = c("trip_id", "stop_sequence")
        ) %>%
        filter(stop_id %in% stop_info$stop_id)
      dbDisconnect(con)

      all_stop_arrivals <- trip_etas %>%
        left_join(trip_info, by = "trip_id") %>%
        left_join(route_info, by = "route_id") %>%
        mutate(
          timestamp = as.POSIXct(timestamp, origin = "1970-01-01")
        ) %>%
        group_by(trip_id) %>%
        group_modify(~{
          .x <- .x %>%
            filter(timestamp == max(.x$timestamp))
          if (any(.x$timestamp + .x$eta * 60 > TSTART)) return(.x)
          .x %>% filter(FALSE)
        }) %>%
        ungroup() %>%
        arrange(trip_id, eta) %>%
        left_join(stops %>% select(stop_id, which), by = "stop_id") %>%
        mutate(
          which = factor(which, levels = c("Origin", "Transfer", "Destination"))
        )

      # now filter out irrelevant trips...
      trips_at_start <- all_stop_arrivals %>%
        filter(which == "Origin" & transfer == 1) %>%
        pull(trip_id) %>% unique
      trips_at_transfer <- all_stop_arrivals %>%
        filter(
          which == "Transfer" &
          transfer == 2
        ) %>%
        pull(trip_id) %>% unique

      stop_arrivals <- all_stop_arrivals %>%
        filter(trip_id %in% c(trips_at_start, trips_at_transfer)) %>%
        group_by(transfer) %>%
        group_modify(~{
          .x %>% mutate(
            trip_start_time = paste0(
              .y$transfer,
              LETTERS[as.integer(as.factor(trip_start_time))]
            )
          )
        }) %>%
        ungroup()

      ## calculate probability bus A arrives BEFORE bus B at transfer:
      transfer_arrivals <- stop_arrivals %>%
        filter(which == "Transfer" & transfer == 1) %>%
        select(trip_id, trip_start_time, timestamp, eta, quantile,
          gtfs_eta, actual_arrival)
      transfer_departures <- stop_arrivals %>%
        filter(which == "Transfer" & transfer == 2) %>%
        select(trip_id, trip_start_time, timestamp, eta, quantile,
          gtfs_eta, actual_arrival)

      tab <- tibble(
        L1 = rep(
          sort(unique(transfer_arrivals$trip_start_time)),
          each = length(unique(transfer_departures$trip_start_time))
        ),
        L2 = rep(
          sort(unique(transfer_departures$trip_start_time)),
          length(unique(transfer_arrivals$trip_start_time))
        )
      ) %>% mutate(
        p_catch = round(f(L1, L2, 1, transfer_arrivals, transfer_departures), 2),
        gtfs_eta = f(L1, L2, 2, transfer_arrivals, transfer_departures),
        did_catch = f(L1, L2, 3, transfer_arrivals, transfer_departures)
      )

      list(
        leave_at = TSTART,
        tab = tab
      )

    }
  )
  save(all_results, file = all_results_file)
}

mdata <- map(all_results, "tab") %>%
  bind_rows

mdata %>%
  filter(
    (p_catch > 0 | did_catch == "Y") &
    (p_catch < 1 | did_catch == "N")
  ) %>%
  mutate(did_catch = ifelse(did_catch == "Y", 1, 0)) %>%
  ggplot(aes(p_catch + rnorm(length(p_catch), 0, 0.01), did_catch)) +
    ggbeeswarm::geom_beeswarm(
      # aes(colour = gtfs_eta),
      groupOnX = FALSE,
      priority = "random"
    ) +
    #geom_abline() +
    #geom_smooth(colour = "orangered") +
    theme_classic() +
    scale_x_continuous("Predictive probabilty of making transfer") +
    scale_y_continuous("Observed transfer outcome",
      breaks = 0:1,
      labels = c("No", "Yes")
    )

gtfs_tab <- table(
  gtfs = ifelse(mdata$gtfs_eta == "Y", "Yes", "No"),
  outcome = ifelse(mdata$did_catch == "Y", "Yes", "No")
)
gtfs_pc <- round(sweep(gtfs_tab, 1, rowSums(gtfs_tab), "/"), 2)

if (FALSE)
  knitr::kable(
    cbind("Prediction" = c("No", "Yes"), gtfs_pc),
    format = "latex",
    row.names = FALSE,
    booktabs = TRUE,
    caption = "GTFS prediction outcomes.",
    escape = FALSE,
    linesep = ""
  ) %>%
    kableExtra::kable_styling(font_size = 8)


pf_tab <- table(
  pred = ifelse(mdata$p_catch > 0.5, "Yes", "No"),
  outcome = ifelse(mdata$did_catch == "Y", "Yes", "No")
)
pf_pc <- round(sweep(pf_tab, 1, rowSums(pf_tab), "/"), 2)

pf_tab <- table(
  pred = ifelse(mdata$p_catch > 0.8, "Yes", "No"),
  outcome = ifelse(mdata$did_catch == "Y", "Yes", "No")
)
pf_pc2 <- round(sweep(pf_tab, 1, rowSums(pf_tab), "/"), 2)

pf_tab <- table(
  pred = ifelse(mdata$p_catch > 0.95, "Yes", "No"),
  outcome = ifelse(mdata$did_catch == "Y", "Yes", "No")
)
pf_pc3 <- round(sweep(pf_tab, 1, rowSums(pf_tab), "/"), 2)


options(knitr.kable.NA = "")
knitr::kable(
  cbind("Prediction" = c("No", "Yes"),
    gtfs_pc, NA, pf_pc, NA, pf_pc2, NA, pf_pc3),
  row.names = FALSE,
  format = "latex",
  booktabs = TRUE,
  caption = "Results of running the transfer prediction problem over the course of the day. Rows represent the predicted outcome (No, the transfer will be made, or Yes, it will) and the numbers represent the proportion of predictions with each observed outcome. The GTFS rule is binary, while the particle filter results are based on transfer probability of at least 0.5, 0.8, or 0.95 (as indicated).",
  escape = FALSE,
  linesep = ""
) %>%
  kableExtra::kable_styling(font_size = 8) %>%
  kableExtra::add_header_above(
    c("", "GTFS" = 2, "", "PF (P > 0.5)" = 2, "", "PF (P > 0.8)" = 2,
      "", "PF (P > 0.95)" = 2)
  ) %>%
  kableExtra::add_header_above(c("", "Outcome" = 11))



@



As before, the procedure was repeated in 5~minute intervals between \Sexpr{format(min(tstart), TIME_FMT)} and \Sexpr{format(max(tstart), TIME_FMT)}, and the probabilities of transfers computed for each. \Cref{fig:eta_journey_transfer_many} shows the predicted transfer probabilities grouped by the outcome. To complement these results, \cref{tab:eta_journey_transfer_many} shows the outcomes for the schedule-delay method along with particle filter predictions using three decision rules. For the schedule-delay method, in \Sexpr{round(100*gtfs_pc[2,1])}\% of cases, a predicted successful connection failed versus only \Sexpr{round(100*pf_pc[2,1])}\% using the particle filter with a decision rule of $\Pcatch > 0.5$. The false-positive rate was similar for both methods, although slightly higher for our own (\Sexpr{round(100*pf_pc[1,2])}\% versus \Sexpr{round(100*gtfs_pc[1,2])}\%). However, depending on the passenger's requirements, it is possible to reduce the false-positive rate under the particle filter by increasing the threshold.  \Cref{tab:eta_journey_transfer_many}  also shows the results using 0.8 and 0.95 as the decision rule, which results in a \Sexpr{round(100*pf_pc2[2,1])}\% and \Sexpr{round(100*pf_pc3[2,1])}\% false positive rate, respectively, though these result in quite a significant increase in the false-negative rate. By providing probabilities, the passenger has the option to decide what level of risk they are willing to take depending on personal constraints.


In this section, we have seen that having access to the full distribution of arrival times enables calculation of event probabilities as opposed to binary outcome predictions. Probabilities allow for more sophisticated decision making by travellers depending on their own needs, or by journey planning software and dynamic routing methods \citep{Berczi_2017}. A further advantage of using the \pf{} to estimate the \glspl{cdf} is that any improvements to the vehicle or network models will be integrated into the arrival prediction component, making future improvements simple to implement.
