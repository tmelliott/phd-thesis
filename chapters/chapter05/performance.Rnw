\section{Real-time performance}
\label{sec:prediction_performance}

The real-time performance of the our application has always been the main bottleneck, in that it needs to run in real-time and provide arrival time predictions as soon as possible after the data is received.Â During the simulation run to obtain the results from \cref{sec:prediction_model_comparison}, we also recorded the timings of individual parts of the program, of which overall averages are displayed in \cref{tab:prediction_timing}. In it, we have two timers: wall clock and CPU clock. Wall clock is the real-world time passed, while the CPU clock is the time spent on the processor.  We ran the simulation using four~cores, which affects the vehicle update (V) and \gls{eta} prediction (P) steps, as these are run in parallel. The other steps are not parallelised, so the wall and CPU timings are approximately similar, with the exception of the Load data (L) step, which involves calling the \gls{gtfs} \gls{api} and waiting for the data to download.


On average, the program takes less than five~seconds, which is well below our original target of 30~seconds. The most intensive component is updating of vehicle states, which involves updating 10,000 particles for each operating vehicle. This is followed by the \gls{eta} prediction step, which involves far fewer particles (we used 200 per trip), but each particle is required to estimate more per iteration [better wording]. However, the main advantage is that, in the vehicle update step, we perform a full weighted resample of the particles, which involves a full copy of all $\Np$ particles, plus sorting (if applicable). In the \gls{eta} step, we are able to use a single pointer to iterate over sampled particles, which completely avoids any copying.


<<prediction_timing,echo=FALSE,message=FALSE,warning=FALSE,cache=TRUE>>=
suppressPackageStartupMessages({
    library(tidyverse)
    library(knitr)
    library(kableExtra)
})
options(scipen = 10)

timings <- read_csv("data/timings.csv") %>% filter(iteration > 1)
tbl_times <- timings %>%
    group_by(what) %>%
    summarize(
        n = n(),
        wall_mean = mean(wall),
        wall_se = sd(wall) / sqrt(n),
        cpu_mean = mean(cpu),
        cpu_se = sd(cpu) / sqrt(n)
    ) %>%
    select(-n) %>%
    bind_rows(
    timings %>%
        group_by(iteration) %>%
        summarize(
            timestamp = first(timestamp),
            wall = sum(wall),
            cpu = sum(cpu)
        ) %>%
        ungroup() %>%
        summarize(
            what = "Total",
            n = n(),
            wall_mean = mean(wall),
            wall_se = sd(wall) / sqrt(n),
            cpu_mean = mean(cpu),
            cpu_se = sd(cpu) / sqrt(n)
        ) %>%
        select(-n)
    )


tbl_times <- tbl_times[c(1, 4, 5, 3, 2, 6, 7), ]
tbl_times <- tbl_times %>%
    mutate(
        wall_mean = format(signif(wall_mean, 3), drop0trailing = TRUE),
        wall_se = paste0("(", signif(wall_se, 2), ")"),
        cpu_mean = format(signif(cpu_mean, 3), drop0trailing = TRUE),
        cpu_se = paste0("(", signif(cpu_se, 2), ")")
    )
tbl_times$what <- c(
    "(L) Load data",
    "(U) Update vehicle information",
    "(V) Vehicle state update",
    "(N) Network state update",
    "(P) Predict ETAs",
    "(W) Write ETAs to protobuf feed",
    "(T) Total iteration time"
)
names(tbl_times) <- c("", "Wall clock", "(SE)", "CPU time", "(SE)")
kable(
    tbl_times,
    align = "lrlrl",
    booktabs = TRUE,
    caption = "Time taken during various parts of the program, running on a single core."
) %>%
    row_spec(6, extra_latex_after = "\\midrule")
@


However, there is a high level of variability in the number of buses operating at any given time (figure X), so in \cref{fig:prediction_timing_time} we have displayed the timings for each individual iteration over the course of the day. We again see the peak hour effect, where there are upwards of 1000~vehicles operating. This pushes the total iteration time to a between 10 and 15~seconds, which is still well within our target of 30~seconds. We could slightly increase the number of particles, although it is worth remembering that the \emph{resampling} step of the particle filter has a computational complexity of $\mathcal{O}(N\log N)$, so for example we cannot double the number of particles and expect to remain under the 30~second target.
\textcolor{red}{Note to self: re-run simulations overnight, when you're not also using the CPU cores for other tasks, which should remove the oddity between about 9am and 2pm.}


<<prediction_timing_time,warning=FALSE,echo=FALSE,cache=F,dependson=c(-1),fig.width=9,fig.height=4,out.width="\\textwidth",fig.cap="Timing results over time for various stages of the program: (L) Load data, (O) Update vehicles information, (V) Vehicle state update, (N) Network state update, (P) Predict ETAs, (W) Write ETAs to protobuf feed, (T) Total iteration time.">>=
# totals:
total_time <- timings %>%
    group_by(timestamp) %>%
    summarize(wall = sum(wall), cpu = sum(cpu), what = "total")
timings %>%
    bind_rows(total_time) %>%
    mutate(
        timestamp = as.POSIXct(timestamp, origin = "1970-01-01"),
        Stage = factor(what,
            levels = sort(unique(what))[c(1, 5, 6, 4, 2, 7, 3)],
            labels = c("L", "U", "V", "N", "P", "W", "T")
        )
    ) %>%
    arrange(timestamp) %>%
    ggplot(aes(timestamp)) +
        geom_path(aes(y = wall, colour = Stage, group = Stage)) +
        theme_classic() +
        xlab("Time") + ylab("Iteration timing (seconds, wall clock)")
@
