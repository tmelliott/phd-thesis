\subsection{Normal approximation}
\label{sec:prediction_arrival_time_normal}

Due to the computational demand of the particle filter, significant speed improvements can be obtained if we were to use a normal approximation instead. The network state is a multivariate normal random variable already; hence, the issue lies with stop dwell times having a point mass at zero, which leads to a mixture predictive distribution. For each stop the vehicle passes, there are twice as many components, so after $m$ stops, there would be $2^m$ components. Fortunately, these mostly converge after a few stops as shown in \cref{fig:normal_approx}.

<<normal_approx,cache=TRUE,echo=FALSE,fig.width=6,fig.height=2,fig.subcap=c("One intermediate stop", "Two intermediate stops", "Three intermediate stops", "Eight intermediate stops"),fig.ncol=1,fig.colsep=rep("\\\\",5),fig.cap="Normal approximation for a series of stops ahead. The true distribution is shown by the histogram with the underlying components (dashed curves). The red vertical lines represent the sample quantiles, while the dashed blue lines represent the approximated quantiles using the optimisation algorithm. Finally, the green curve and corresponding vertical lines represent the single normal approximation.",out.width=".8\\textwidth",fig.align="center">>=
suppressPackageStartupMessages(library(tidyverse))
napprox <- function(n, pi = rep(0.8, n), t = c(80, 15),
                    mu = rep(20, n), sigma = rep(5, n)) {
    # indicator of stopping:
    d <- do.call(expand.grid, lapply(1:n, function(i) 0:1))
    pi <- apply(
        sapply(1:n, function(i) ifelse(d[,i], pi[i], 1 - pi[i])),
        1,
        prod
    )
    mu <- apply(
        sapply(1:n, function(i) t[1] + ifelse(d[,i], mu[i], 0)),
        1,
        sum
    )
    sigma <- sqrt(
        apply(
            sapply(1:n, function(i) t[2] + ifelse(d[,i], sigma[i]^2, 0)),
            1,
            sum
        )
    )

    daytah <- tibble(
        z = apply(rmultinom(1e6, 1, pi), 2, function(x) which(x == 1)),
        x = rnorm(1e6, mu[z], sigma[z])
    )

    px <- ggplot(daytah) +
        geom_histogram(aes(x, stat(density)), bins = 50, fill = "lightgray")

    xx <- seq(min(daytah$x), max(daytah$x), length = 1001)
    curves <- lapply(1:nrow(d),
        function(i) {
            geom_path(
                aes(x, y),
                data = tibble(
                    x = xx,
                    y = dnorm(xx, mu[i], sigma[i]) * pi[i]
                ),
                lty = 2
            )
        }
    )

    px <- Reduce("+", c(list(px), curves))

    ## Can we calculate the quantiles?
    q <- quantile(daytah$x, prob = c(0.05, 0.5, 0.95))
    px <- px + geom_vline(xintercept = q, colour = "orangered", lwd = 1)

    f <- function(x, q = 0.95) {
        (sum(pi * pnorm(x, mu, sigma)) - q)^2
    }
    qq <- sapply(c(0.05, 0.5, 0.95),
        function(q) optimize(f, range(daytah$x), q = q)$minimum
    )
    px <- px + geom_vline(xintercept = qq, colour = "blue", lty = 2)

    ## mean and var
    mean <- sum(pi * mu)

    EVarX <- sum(pi * sigma^2)
    VarEX <- sum(pi * mu^2) - sum(pi * mu)^2
    sd <- sqrt(EVarX + VarEX)

    px <- px + geom_path(
        aes(x, y),
        data = tibble(
            x = xx,
            y = dnorm(xx, mean, sd)
        ),
        colour = "green4"
    )

    ## Compare quantiles of single normal vs mixture
    qx <- qnorm(c(0.05, 0.5, 0.95), mean, sd)
    px <- px + geom_vline(xintercept = qx, colour = "green4")

    ## prettify the plot
    px <- px +
        theme_classic() +
        scale_x_continuous(
            "ETA (minutes)",
            breaks = function(x) pretty(x / 60) * 60,
            labels = function(x) x / 60
        ) +
        scale_y_continuous("Probability density")
    print(px)

    invisible(
        list(
            x = daytah$x,
            pi = pi, mu = mu, sigma = sigma,
            error = sum((qx - qq)^2)
        )
    )
}
napprox(1, pi = 0.8, mu = 30, sigma = 20, t = c(30, 5))
napprox(2, pi = c(0.8, 0.5), mu = c(30, 20), sigma = c(20, 10), t = c(70, 15))
napprox(3, pi = c(0.5, 0.5, 0.5), mu = c(30, 20, 40),
    sigma = c(20, 10, 20), t = c(120, 20))
#napprox(5, pi = c(0.5, 0.5, 0.5, 0.5, 0.3), mu = c(30, 20, 40, 20, 6),
#    sigma = c(20, 10, 20, 10, 5), t = c(200, 40))
napprox(8,
    pi = c(0.5, 0.5, 0.5, 0.5, 0.3, 0.5, 0.5, 0.5),
    mu = c(30, 20, 40, 20, 6, 20, 20, 20),
    sigma = c(20, 10, 20, 10, 5, 5, 5, 5),
    t = c(200, 40)
)
@


To use a mixture of normals to incorporate stopping uncertainty, we express the mean and uncertainty as vectors $\tilde\mu$ and $\tilde\sigma^2$, respectively, along with a third vector $\tilde\pi$ denoting the $\tilde N$ mixture weights\footnote{We are using the tilde over parameters, e.g., $\tilde x$, to help distinguish them from others used throughout the thesis}, such that
\begin{equation}
\label{eq:ch5:mixture_weight_spec}
\tilde\pi_i > 0, i = 1, \ldots, \tilde N
\text{ and } \sum_{i=1}^{\tilde N} \tilde\pi_i = 1.
\end{equation}
The arrival time at stop $j + n$ is given by
\begin{equation}
\label{eq:arrival_time_normal_approx}
\Tarr_{j+n} | \tilde\mu, \tilde\sigma^2, \tilde\pi, \RouteNWstate =
\sum_{\ell=j}^{j+n-1} \RouteNWstateseg_\ell +
\sum_{i=1}^{\tilde N} \tilde\pi_i z_i,\quad
z_i \sim \Normal{\tilde\mu_i}{\tilde\sigma^2_i}.
\end{equation}


Each component $i$ has an indicator of whether or not it stopped at stop $m$, $I_{im} = \{0,1\}$, giving the total dwell time as
\begin{equation}
\label{eq:mixture_dwell_times}
\begin{split}
\tilde\mu_i &= \sum_{m=j}^{j+n} I_{im} \dwell_m \\
\tilde\sigma_i^2 &= \sum_{m=j}^{j+n} I_{im} \dwellvar_m
\end{split}
\end{equation}
which assumes dwell times at individual stops are independent of each other.

The vector of indicators is a branching tree for each stop; all current components get duplicated, and one is assigned $I_{i,m+1} = 1$ and the other 0.


Finally, mixture weights are obtained through the stopping probability at each stop, $\pi_j$:
\begin{equation}
\label{eq:ch5:mixture_weights}
\begin{split}
\tilde\pi_i &= \prod_{m=j}^{j+n} \tilde p_{im} \\
\tilde p_{im} &=
\begin{cases}
\pi_m & \text{if } I_{im} = 1 \\
1 - \pi_m & \text{otherwise.}
\end{cases}
\end{split}
\end{equation}


The mixture approximation works okay for a few stops ahead, but after some time the mixture weights become small and the components combine into more-or-less a single one, as shown in \cref{fig:normal_approx}. To prevent $\tilde N$ from becoming too large, the full distribution is simplified into a single component with mean and variance
\begin{equation}
\label{eq:mixture_mean}
\begin{split}
\E{\Tarr_m | \tilde\pi, \tilde\mu, \tilde\sigma^2, \RouteNWstate} &=
\E{\sum_{\ell=j}^{j+n-1} \RouteNWstateseg_\ell +
  \sum_{i=1}^{\tilde N} \tilde\pi_i z_i}
= \sum_{\ell=j}^{j+n-1} \E{\RouteNWstateseg_\ell} +
  \sum_{i=1}^{\tilde N} \tilde\pi_i \E{z_i} \\
&= \sum_{\ell=j}^{j+n-1} \hat\RouteNWstateseg_\ell +
  \sum_{i=1}^{\tilde N} \tilde\pi_i \tilde\mu_i
\end{split}
\end{equation}
and
\begin{equation}
\label{eq:mixture_variance}
\begin{split}
\Var{\Tarr_m | \tilde\pi, \tilde\mu, \tilde\sigma^2, \RouteNWstate} &=
\Var{\sum_{\ell=j}^{j+n-1} \RouteNWstateseg_\ell +
  \sum_{i=1}^{\tilde N} \tilde\pi_i z_i}
= \sum_{\ell=j}^{j+n-1} \Var{\RouteNWstateseg_\ell} +
  \sum_{i=1}^{\tilde N} \tilde\pi_i^2 \Var{z_i} \\
&= \sum_{\ell=j}^{j+n-1} \hat\RouteNWstatesegvar_\ell +
  \sum_{i=1}^{\tilde N} \tilde\pi_i \tilde\sigma_i^2
\end{split}
\end{equation}
respectively, assuming segment travel time and dwell time are independent---assuming otherwise makes this model impossible to work with; indeed, this model versus the particle filter (which makes no such assumption) is effectively testing the viability of this assumption.


For quantiles $q_\alpha$ we need to use an optimisation algorithm to solve
\begin{equation}
\label{eq:mixture_quadratic}
\left[
  p\left(\Tarr_m | \tilde\pi, \tilde\mu, \tilde\sigma^2, \RouteNWstate\right) - q_\alpha
\right]^2 = 0
\end{equation}
which is straightforward using Brent's Algorithm \citep{Brent_1971}, which is implemented in the Boost C++ library \citep{cn}.


However, after eight stops, the number of components is $2^8 = \Sexpr{2^8}$, after which point it would be more efficient to use the particle filter. Instead, we use a simplification criteria such that, when passed, a single new component is close enough in approximation to the set of components that it can replace them. We have chosen to compare quantiles, and if the maximum absolute difference is less than one minute\footnote{When providing \glspl{eta} to commuters, they are rounded to the nearest minute, anyway.}, we replace the set of components with a single new one with mean and variance as specified in \cref{eq:mixture_mean,eq:mixture_variance}. At subsequent stops, the process repeats, and we iteratively check if a single distribution is an adequate approximation.


We also need to prevent the mixture from becoming too large: if $\tilde N > 8$, we combine components with $\tilde\pi_i < \frac{1}{2}\max_i(\pi_i)$, using appropriately modified versions of \cref{eq:mixture_mean,eq:mixture_variance}. In practice, after about five stops the distribution is approximately normal, and the error is minimal. \textcolor{red}{a figure for this}
