\section{Assessing predictive performance}
\label{sec:prediction_model_comparison}

To compare the four prediction methods, we implemented the first two in the \pkg{transitr} application. The program estimated and saved all arrival time estimates over a full day of data, along with uncertainty and the 5\% and 90\% quantiles. The accuracy of each method is assessed by comparison with the reported arrival times using \gls{rmse}, \gls{mae}, and \gls{mape} (details in \cref{app:error-functions}). Since predictions change over time, we also computed the summary values by \emph{time until (actual) arrival}, allowing the comparison of models at different time points, as well as by stop sequence and time of day.


Another useful criteria is the \gls{picp}, which is only available for the three methods that provide an 85\% \gls{ppi}: for the particle filter, this is achieved by sorting the particles in order of arrival time and taking the $\lfloor 0.05 N^\star\rfloor^{\text{th}}$ particle as the lower bound, and the $\lceil 0.9 N^\star\rceil^{\text{th}}$ particle as the upper bound (more details in \cref{app:particle-summaries}). For the Normal approximation and historical arrival methods, the inverse \gls{cdf} provides the required quantiles. The results are displayed in \cref{tab:model_results_rmse} and \cref{fig:model_results_rmse_time,fig:model_results_rmse_stopn,fig:model_results_rmse_timeofday} and described in \cref{sec:prediction_model_comp_stats}.


Additionally, we want to compare the reliability of the various forecast methods, namely \emph{the probability of arriving before the bus}, and hence not missing it, as well as the expected waiting time given a passenger arrives at the stop by a certain time. \Cref{tab:model_results_pr_miss} and \cref{fig:model_results_pr_gtfs,fig:model_results_pr_time,fig:model_results_pr_stop,fig:model_results_pr_timeofday} use the point estimate (mean or median, depending on the forecast method) and the 5\% quantile to calculate the probability that the bus arrives after each estimate. \Cref{sec:prediction_model_comp_probs} discusses these results.

<<model_colours,echo=FALSE,cache=TRUE>>=
pal <- RColorBrewer::brewer.pal(4, "Set1")
names(pal) <- c("pf", "normal", "historical", "schedule-delay")
options(knitr.kable.NA = '')
@

<<model_results_load,echo=FALSE,message=FALSE,warning=FALSE,cache=TRUE,cache.lazy=FALSE>>=
suppressPackageStartupMessages({
    library(tidyverse)
})


eta_files <- list.files("data",
    pattern = "eta_results.\\.rda",
    full.names = TRUE
)
eta_results_all <-
    do.call(bind_rows,
        lapply(eta_files, function(f) {
            load(f)
            etai
        })
    ) %>% mutate(
        hist_error = historical_mean - time_until_arrival,
        hist_ci = as.integer(
            historical_lower <= time_until_arrival &
            time_until_arrival <= historical_upper
        )
    ) %>%
    ungroup()

# routes_to_keep <-
# c("1", "101", "105", "106", "110", "111", "112", "114", "120",
# "126", "131", "132", "133", "134", "138", "141", "142", "143",
# "146", "14T", "14W", "152", "154", "161", "162", "170", "172",
# "18", "186", "191", "195", "2", "20", "22A", "22N", "22R", "24B",
# "24R", "25B", "25L", "27H", "27T", "27W", "295", "298", "30",
# "309", "31", "313", "314", "32", "321", "323", "324", "325",
# "326", "33", "35", "351", "352", "353", "355", "361", "362",
# "365", "366", "371", "372", "373", "376", "377", "378", "380",
# "391", "392", "393", "650", "66", "670", "68", "711", "712",
# "714", "72C", "72M", "72X", "734", "735", "739", "743", "744",
# "747", "75", "751", "755", "762", "774", "781", "782", "783",
# "801", "814", "82", "83", "843", "845", "856", "861", "865",
# "871", "883", "884", "885", "889", "901", "906", "907", "917",
# "923", "924", "926", "928", "931", "933", "941", "942", "95B",
# "95C", "97B", "97R", "981", "982", "983", "985", "998", "CTY",
# "INN", "NX1", "NX2", "OUT", "SKY", "TMK")

eta_results <- eta_results_all #%>% filter(route_short_name %in% routes_to_keep)
@

<<model_results_rmse,echo=FALSE,message=FALSE,warning=FALSE,cache=TRUE,dependson=c("model_results_load","model_colours"),cache.lazy=FALSE>>=
mat <- eta_results %>%
    filter(time_until_arrival > 0) %>%
    summarize(
        pf_rmse = sqrt(mean(pf_error^2)),
        pf_mae = mean(abs(pf_error)),
        pf_mape = mean(abs(pf_error / time_until_arrival)),
        pf_ci_cov = mean(pf_ci),
        pf_ci_width = mean(pf_upper - pf_lower),
        pf_ci_lower = quantile(pf_upper - pf_lower, 0.025),
        pf_ci_upper = quantile(pf_upper - pf_lower, 0.975),
        normal_rmse = sqrt(mean(normal_error^2)),
        normal_mae = mean(abs(normal_error)),
        normal_mape = mean(abs(normal_error / time_until_arrival)),
        normal_ci_cov = mean(normal_ci),
        normal_ci_width = mean(normal_upper - normal_lower),
        normal_ci_lower = quantile(normal_upper - normal_lower, 0.025),
        normal_ci_upper = quantile(normal_upper - normal_lower, 0.975),
        hist_rmse = sqrt(mean(hist_error^2, na.rm = TRUE)),
        hist_mae = mean(abs(hist_error), na.rm = TRUE),
        hist_mape = mean(abs(hist_error / time_until_arrival), na.rm = TRUE),
        hist_ci_cov = mean(hist_ci, na.rm = TRUE),
        hist_ci_width = mean(historical_upper - historical_lower, na.rm = TRUE),
        hist_ci_lower = quantile(historical_upper - historical_lower, 0.025, na.rm = TRUE),
        hist_ci_upper = quantile(historical_upper - historical_lower, 0.975, na.rm = TRUE),
        gtfs_rmse = sqrt(mean(gtfs_error^2)),
        gtfs_mae = mean(abs(gtfs_error)),
        gtfs_mape = mean(abs(gtfs_error / time_until_arrival))
    ) %>%
    with(
        data.frame(
            rmse = round(c(pf_rmse, normal_rmse, hist_rmse, gtfs_rmse)),
            mae = round(c(pf_mae, normal_mae, hist_mae, gtfs_mae)),
            mape = round(100 * c(pf_mape, normal_mape, hist_mape, gtfs_mape)),
            ci_cov = round(100 * c(pf_ci_cov, normal_ci_cov, hist_ci_cov, NA))
            #ci_width = round(c(pf_ci_width, normal_ci_width, hist_ci_width, NA) / 60),
            #ci_ci = c(
            #    glue::glue("({round(pf_ci_lower/60, 1)}, {round(pf_ci_upper/#60, 1)})"),
            #    glue::glue("({round(normal_ci_lower/60, 1)}, {round#(normal_ci_upper/60, 1)})"),
           #     glue::glue("({round(hist_ci_lower/60, 1)}, {round(hist_ci_upper/60, 1)})"),
            #    NA
            #)
        )
    )
row.names(mat) <- paste0(
    "\\F", c("pf", "norm", "hist", "sched"), "{}: ",
    c(
        "Particle filter",
        "Normal approximation",
        "Historical delays",
        "Schedule-delay"
    )
)
names(mat) <- c(
    "RMSE (s)",
    "MAE (s)",
    "MAPE (\\%)",
    "PICP (\\%)"
    #"\\multicolumn{2}{c}{PPI width (m)}",
    #"SKIP"
)
options(knitr.kable.NA = "")
tbl <- knitr::kable(
    mat,
    format = "latex",
    booktabs = TRUE,
    caption = "Comparison of the predictive performance of the four methods after estimating arrival times for a full day of historical data. RMSE, MAE, and MAPE measure the accuracy of the mean or median, and PICP measures the accuracy of the distribution: the nominal coverage is 85\\% (PICP is not available for the schedule-delay method).",
    caption.short = "Comparison of the predictive performance of the four methods after estimating arrival times for a full day of historical data",
    escape = FALSE
)
#tbl <- gsub("& SKIP", "", tbl)
tbl %>% kableExtra::kable_styling(font_size = 8)

@




\subsection{Comparing the accuracy of arrival time prediction}
\label{sec:prediction_model_comp_stats}

The accuracy measurements (\gls{rmse}, \gls{mae}, and \gls{mape}) shown in \cref{tab:model_results_rmse} immediately show that the Normal approximation (\Fnorm{}) estimates are, on average, about half as accurate as the other methods. Overall, the \pf{} (\Fpf{}) demonstrates the greatest accuracy by all criteria, indicating that its estimates are (on average) closer to the true value in both absolute and relative terms. The historical delays approach (\Fhist{}) has similar accuracy to the schedule-delay approach (\Fsched{}) in absolute terms (\gls{rmse} and \gls{mae}), but the least accurate overall in relative terms (\gls{mape}). This indicates that \Fhist{} has worse accuracy for short-term forecasts, which is not surprising as it uses only historical data, ignoring \rt{} information about vehicle location and network state.


As for the \gls{picp}, the theoretical coverage is 85\%. \Fpf{} underestimates arrival time uncertainty, indicating that the model is not capturing enough uncertainty: this could be any combination of dwell time, travel time, or the unknown. Conversely, \Fnorm{} overestimates uncertainty by about 5\%. \Fhist{} has close to the desired \gls{picp}, which demonstrates that arrival time delays at each stop show a certain level of consistency from day-to-day.


The main finding of \cref{tab:model_results_rmse} is that the Normal approximation is inadequate for this problem. However, this was not unexpected: in previous chapters, I emphasised the non-Gaussian nature of a vehicle's state. We now explore the effects of time-until-arrival, stop sequence, and time-of-day on prediction accuracy to more closely inspect the relative performance of the methods.


\subsubsection{Time until actual arrival}

We would expect arrival time predictions for a given stop to become more accurate as the bus approaches. To assess this, arrival time estimates were binned into one-minute intervals, and for each, the summary statistics were estimated, which are displayed in \cref{fig:model_results_rmse_time}. Note the use of log scales for \gls{rmse}, \gls{mae}, and \gls{mape}.


<<model_results_rmse_time,warning=FALSE,echo=FALSE,cache=TRUE,dependson=c("model_results_load","model_colours"),cache.lazy=FALSE,fig.width=8,fig.height=4,out.width="\\textwidth",fig.cap="Model comparative statistics as a function of time until arrival. Note the log-scale for RMSE, MAE, and MAPE. The dashed line in the graph of PICP indicates the nominal coverage of 85\\%.">>=
# tidyverse is loaded!
res_min <- eta_results %>%
    mutate(
        min = time_until_arrival %/% 60
    ) %>%
    filter(time_until_arrival > 0) %>%
    group_by(min) %>%
    summarize(
        pf_rmse = sqrt(mean(pf_error^2)),
        pf_mae = mean(abs(pf_error)),
        pf_mape = mean(abs(pf_error / time_until_arrival)),
        pf_ci_cov = mean(pf_ci),
        pf_ci_width = mean(pf_upper - pf_lower),
        pf_ci_lower = quantile(pf_upper - pf_lower, 0.025),
        pf_ci_upper = quantile(pf_upper - pf_lower, 0.975),
        normal_rmse = sqrt(mean(normal_error^2)),
        normal_mae = mean(abs(normal_error)),
        normal_mape = mean(abs(normal_error / time_until_arrival)),
        normal_ci_cov = mean(normal_ci),
        normal_ci_width = mean(normal_upper - normal_lower),
        normal_ci_lower = quantile(normal_upper - normal_lower, 0.025),
        normal_ci_upper = quantile(normal_upper - normal_lower, 0.975),
        hist_rmse = sqrt(mean(hist_error^2, na.rm = TRUE)),
        hist_mae = mean(abs(hist_error), na.rm = TRUE),
        hist_mape = mean(abs(hist_error / time_until_arrival), na.rm = TRUE),
        hist_ci_cov = mean(hist_ci, na.rm = TRUE),
        hist_ci_width = mean(historical_upper - historical_lower, na.rm = TRUE),
        hist_ci_lower = quantile(historical_upper - historical_lower, 0.025, na.rm = TRUE),
        hist_ci_upper = quantile(historical_upper - historical_lower, 0.975, na.rm = TRUE),
        gtfs_rmse = sqrt(mean(gtfs_error^2)),
        gtfs_mae = mean(abs(gtfs_error)),
        gtfs_mape = mean(abs(gtfs_error / time_until_arrival))
    ) %>% arrange(min) %>%
    filter(min < 40)

plot_base <- ggplot(res_min, aes(min)) +
    theme_classic() +
    theme(legend.position = "none") +
    scale_colour_manual(values = pal, name = "model") +
    xlab("Time until arrival (minutes)")

plot_rmse <- plot_base +
    geom_path(aes(y = pf_rmse, colour = "pf")) +
    geom_path(aes(y = normal_rmse, colour = "normal")) +
    geom_path(aes(y = hist_rmse, colour = "historical")) +
    geom_path(aes(y = gtfs_rmse, colour = "schedule-delay")) +
    scale_y_continuous(
        "RMSE (s)",
        trans = "log10"
    ) +
    theme(legend.position = "bottom")

plot_mae <- plot_base +
    geom_path(aes(y = pf_mae, colour = "pf")) +
    geom_path(aes(y = normal_mae, colour = "normal")) +
    geom_path(aes(y = hist_mae, colour = "historical")) +
    geom_path(aes(y = gtfs_mae, colour = "schedule-delay")) +
    scale_y_continuous(
        "MAE (s)",
        trans = "log10"
    )

plot_mape <- plot_base +
    geom_path(aes(y = 100 * pf_mape, colour = "pf")) +
    geom_path(aes(y = 100 * normal_mape, colour = "normal")) +
    geom_path(aes(y = 100 * hist_mape, colour = "historical")) +
    geom_path(aes(y = 100 * gtfs_mape, colour = "schedule-delay")) +
    scale_y_continuous(
        "MAPE (%)",
        trans = "log10"
    )
    #ylab("MAPE (%)") + ylim(0, 160)

plot_ci <- plot_base +
    geom_hline(aes(yintercept = 85), lty = 2) +
    geom_path(aes(y = 100 * pf_ci_cov, colour = "pf")) +
    geom_path(aes(y = 100 * normal_ci_cov, colour = "normal")) +
    geom_path(aes(y = 100 * hist_ci_cov, colour = "historical")) +
    scale_y_continuous(
        name = "PICP (%)"
    )

plot_width <- plot_base +
    geom_ribbon(
        aes(
            ymin = pmax(0, pf_ci_lower),
            ymax = pmin(60 * 60, pf_ci_upper),
            fill = "pf"
        ),
        alpha = 0.2
    ) +
    geom_ribbon(
        aes(
            ymin = pmax(0, normal_ci_lower),
            ymax = pmin(60 * 60, normal_ci_upper),
            fill = "normal"
        ),
        alpha = 0.2
    ) +
    geom_ribbon(
        aes(
            ymin = pmax(0, hist_ci_lower),
            ymax = pmin(60 * 60, hist_ci_upper),
            fill = "historical"
        ),
        alpha = 0.2
    ) +
    geom_path(aes(y = pf_ci_width, colour = "pf")) +
    geom_path(aes(y = normal_ci_width, colour = "normal")) +
    geom_path(aes(y = hist_ci_width, colour = "historical")) +
    scale_y_continuous(
        name = "PPI width (m)",
        breaks = function(x) pretty(x / 60) * 60,
        labels = function(x) x / 60,
        limits = c(0, 60) * 60
    ) +
    scale_fill_manual(values = pal, name = "model")

library(patchwork)


plot_rmse + plot_mae +
    plot_mape + plot_ci +
    #plot_width +
    guide_area() +
    plot_layout(
        #ncol = 2,
        #byrow = FALSE,
        guides = "collect",
        design = "
            13
            24
            55
        ",
        heights = c(1, 1, 0.1)
    )

@

The \gls{rmse} and \gls{mae} for all methods increase with time until arrival as expected. The rate of this increase, however, varies between them. The three methods that use \rt{} information (\Fpf{}, \Fnorm{}, and \Fsched{}) demonstrate small absolute error when the bus is near, which increases the farther out the bus gets, while \Fhist{} shows a more constant error and far poorer accuracy when the bus is less than 5--10~minutes away. \Fpf{} has the lowest error up until 20~minutes before arrival and has greater accuracy than \Fsched{} up until 25--30~minutes. This indicates that the current delay is only a useful predictor when the bus has almost arrived, and that accounting for \rt{} traffic conditions does improve the accuracy of arrival time prediction. \Fnorm{} quickly shows large prediction errors for all but the nearest buses.


<<route_length_times,echo=FALSE,message=FALSE,warning=FALSE,cache=TRUE>>=
library(tidyverse)

here <- setwd("../../data")
source("load_data.R")
setwd(here)

to_int <- function(x) {
    sapply(strsplit(x, ":"),
        function(z) {
            sum(as.integer(z) * c(60 * 60, 60, 1))
        }
    )
}

con <- dbConnect(SQLite(), db)
trip_lengths <- con %>% tbl("stop_times") %>%
    filter(trip_id %like% "%_v82.21") %>%
    arrange(trip_id, stop_sequence) %>%
    group_by(trip_id) %>%
    summarize(
        start = min(departure_time, na.rm = TRUE),
        end = max(arrival_time, na.rm = TRUE),
        n_stop = max(stop_sequence, na.rm = TRUE)
    ) %>%
    collect() %>%
    mutate(
        length = to_int(end) - to_int(start)
    )
dbDisconnect(con)

@
The \gls{mape} for all methods decreases with time until arrival, with \Fhist{} showing the highest relative error when the bus is less than about 5~minutes away. \Fnorm{} remains somewhat constant with a relative error of about 50\%. Again, for the first 20~minutes, \Fpf{} has the smallest relative error, and outperforms \Fsched{} up until the bus is 25--30~minutes away. After 30~minutes, \Fpf{} converges with slightly lower accuracy than \Fhist{} and \Fsched{}, which may continue to decrease beyond 40~minutes. However, \Sexpr{round(100*mean(trip_lengths$length < 60*60))}\% of routes in Auckland are less than one hour, so the number of arrival time predictions made when the bus is more than 40~minutes away is small so results will be strongly affected by individual routes.


The \gls{picp} is not available for \Fsched{} since that method only provides point estimates. The coverage for the three remaining methods is reasonably constant across time until arrival (\cref{fig:model_results_rmse_time}). As seen earlier, \Fpf{} underestimates arrival time uncertainty, noted by lower than expected coverage. \Fnorm{} overestimates uncertainty when the bus is more than a few minutes away, and thoroughly underestimates uncertainty when the bus is near, likely because it does not account for enough vehicle state uncertainty. \Fhist{} exhibits good coverage, although this drops slightly as time-until-arrival increases.


\subsubsection{Stop sequence}

\Cref{fig:model_results_rmse_stopn} shows the \gls{rmse}, \gls{mae}, \gls{mape}, and \gls{picp} grouped by stop sequence. The first stop is excluded since arrival times are only predicted once the bus begins the trip. Early stops along a route seldom have long until the bus arrives since \glspl{eta} are only made once the trip starts. Stop sequence is truncated to 50 (\Sexpr{round(100 * mean(trip_lengths$n_stop <= 50))}\% of trips have fewer than that many stops).


<<model_results_rmse_stopn,warning=FALSE,echo=FALSE,cache=TRUE,dependson=c("model_results_load","model_colours"),cache.lazy=FALSE,fig.width=8,fig.height=4,out.width="\\textwidth",fig.cap="Model comparative statistics as a function of stop sequence. RMSE, MAE, and MAPE once more use a log-scale. The dashed line in the graph of PICP indicates 85\\% nominal coverage.">>=
# library(patchwork)
# tidyverse is loaded!
res_stop <- eta_results %>%
    mutate(
        min = time_until_arrival %/% 60
    ) %>%
    filter(time_until_arrival > 0 & stop_sequence > 1) %>%
    group_by(stop_sequence) %>%
    summarize(
        pf_rmse = sqrt(mean(pf_error^2)),
        pf_mae = mean(abs(pf_error)),
        pf_mape = mean(abs(pf_error / time_until_arrival)),
        pf_ci_cov = mean(pf_ci),
        pf_ci_width = mean(pf_upper - pf_lower),
        pf_ci_lower = quantile(pf_upper - pf_lower, 0.025),
        pf_ci_upper = quantile(pf_upper - pf_lower, 0.975),
        normal_rmse = sqrt(mean(normal_error^2)),
        normal_mae = mean(abs(normal_error)),
        normal_mape = mean(abs(normal_error / time_until_arrival)),
        normal_ci_cov = mean(normal_ci),
        normal_ci_width = mean(normal_upper - normal_lower),
        normal_ci_lower = quantile(normal_upper - normal_lower, 0.025),
        normal_ci_upper = quantile(normal_upper - normal_lower, 0.975),
        hist_rmse = sqrt(mean(hist_error^2, na.rm = TRUE)),
        hist_mae = mean(abs(hist_error), na.rm = TRUE),
        hist_mape = mean(abs(hist_error / time_until_arrival), na.rm = TRUE),
        hist_ci_cov = mean(hist_ci, na.rm = TRUE),
        hist_ci_width = mean(historical_upper - historical_lower, na.rm = TRUE),
        hist_ci_lower = quantile(historical_upper - historical_lower, 0.025, na.rm = TRUE),
        hist_ci_upper = quantile(historical_upper - historical_lower, 0.975, na.rm = TRUE),
        gtfs_rmse = sqrt(mean(gtfs_error^2)),
        gtfs_mae = mean(abs(gtfs_error)),
        gtfs_mape = mean(abs(gtfs_error / time_until_arrival))
    ) %>%
    filter(stop_sequence <= 50) %>%
    arrange(stop_sequence)

plot_base <- ggplot(res_stop, aes(stop_sequence)) +
    theme_classic() +
    theme(legend.position = "none") +
    scale_colour_manual(values = pal, name = "model") +
    xlab("Stop sequence")

plot_rmse <- plot_base +
    geom_path(aes(y = pf_rmse, colour = "pf")) +
    geom_path(aes(y = normal_rmse, colour = "normal")) +
    geom_path(aes(y = hist_rmse, colour = "historical")) +
    geom_path(aes(y = gtfs_rmse, colour = "schedule-delay")) +
    scale_y_continuous(
        "RMSE (s)",
        trans = "log10"
    ) +
    theme(legend.position = "bottom")

plot_mae <- plot_base +
    geom_path(aes(y = pf_mae, colour = "pf")) +
    geom_path(aes(y = normal_mae, colour = "normal")) +
    geom_path(aes(y = hist_mae, colour = "historical")) +
    geom_path(aes(y = gtfs_mae, colour = "schedule-delay")) +
    scale_y_continuous(
        "MAE (s)",
        trans = "log10"
    )

plot_mape <- plot_base +
    geom_path(aes(y = 100 * pf_mape, colour = "pf")) +
    geom_path(aes(y = 100 * normal_mape, colour = "normal")) +
    geom_path(aes(y = 100 * hist_mape, colour = "historical")) +
    geom_path(aes(y = 100 * gtfs_mape, colour = "schedule-delay")) +
    scale_y_continuous(
        "MAPE (%)",
        trans = "log10"
    )

plot_ci <- plot_base +
    geom_hline(aes(yintercept = 85), lty = 2) +
    geom_path(aes(y = 100 * pf_ci_cov, colour = "pf")) +
    geom_path(aes(y = 100 * normal_ci_cov, colour = "normal")) +
    geom_path(aes(y = 100 * hist_ci_cov, colour = "historical")) +
    scale_y_continuous(
        name = "PICP (%)"
    )

plot_width <- plot_base +
    geom_ribbon(
        aes(
            ymin = pmax(0, pf_ci_lower),
            ymax = pmin(60 * 60, pf_ci_upper),
            fill = "pf"
        ),
        alpha = 0.2
    ) +
    geom_ribbon(
        aes(
            ymin = pmax(0, normal_ci_lower),
            ymax = pmin(60 * 60, normal_ci_upper),
            fill = "normal"
        ),
        alpha = 0.2
    ) +
    geom_ribbon(
        aes(
            ymin = pmax(0, hist_ci_lower),
            ymax = pmin(60 * 60, hist_ci_upper),
            fill = "historical"
        ),
        alpha = 0.2
    ) +
    geom_path(aes(y = pf_ci_width, colour = "pf")) +
    geom_path(aes(y = normal_ci_width, colour = "normal")) +
    geom_path(aes(y = hist_ci_width, colour = "historical")) +
    scale_y_continuous(
        name = "PPI width (m)",
        breaks = function(x) pretty(x / 60) * 60,
        labels = function(x) x / 60,
        limits = c(0, 60) * 60
    ) +
    scale_fill_manual(values = pal, name = "model")

library(patchwork)

plot_rmse + plot_mae +
    plot_mape + plot_ci +
    guide_area() +
    plot_layout(
        guides = "collect",
        design = "
            13
            24
            55
        ",
        heights = c(1, 1, 0.1)
    )

@

Both \gls{rmse} and \gls{mae} increase with stop sequence for all models. \Fnorm{} shows much higher errors than the other three methods, and \Fpf{} exhibits higher prediction accuracy than \Fhist{} and \Fsched{} up until about stop 30, at which point there is no clear difference between these three methods. However, in terms of relative error (\gls{mape}), \Fpf{} outperforms the others for all stops, while \Fhist{} shows the poorest accuracy, particularly for early stops.


\Gls{picp} shows much the same trend as before with \Fpf{} underestimating arrival time uncertainty at all stops, while \Fnorm{} overestimates for all but the first few stops---it performs poorly for those. \Fhist{} has the desired coverage for all stops.


\subsubsection{Time of day}

Observations were binned into 15-minute intervals and summary statistics calculated for each. The results, displayed in \cref{fig:model_results_rmse_timeofday}, differ from those seen previously, now revealing the peak-hour traffic effect. There is a single morning peak at around 8~am (school and work begin at about the same time) and two evening peaks: one for schools at about 3~pm, and another for workers at around 5~pm.


<<model_results_rmse_timeofday,warning=FALSE,echo=FALSE,cache=TRUE,dependson=c("model_results_load","model_colours"),cache.lazy=FALSE,fig.width=8,fig.height=4,out.width="\\textwidth",fig.cap="Model comparative statistics as a function of time of day. RMSE, MAE, and MAPE use log-scales, and the dashed line in the graph of PICP indicates 85\\% nominal coverage.">>=
res_timeofday <- eta_results %>%
    mutate(
        hour = timestamp %>% format("%H") %>% as.integer,
        minute = timestamp %>% format("%M") %>% as.integer,
        hour = hour + (floor(minute / 15) * 15 / 60)
    ) %>%
    filter(time_until_arrival > 0) %>%
    group_by(hour) %>%
    summarize(
        pf_rmse = sqrt(mean(pf_error^2)),
        pf_mae = mean(abs(pf_error)),
        pf_mape = mean(abs(pf_error / time_until_arrival)),
        pf_ci_cov = mean(pf_ci),
        pf_ci_width = mean(pf_upper - pf_lower),
        pf_ci_lower = quantile(pf_upper - pf_lower, 0.025),
        pf_ci_upper = quantile(pf_upper - pf_lower, 0.975),
        normal_rmse = sqrt(mean(normal_error^2)),
        normal_mae = mean(abs(normal_error)),
        normal_mape = mean(abs(normal_error / time_until_arrival)),
        normal_ci_cov = mean(normal_ci),
        normal_ci_width = mean(normal_upper - normal_lower),
        normal_ci_lower = quantile(normal_upper - normal_lower, 0.025),
        normal_ci_upper = quantile(normal_upper - normal_lower, 0.975),
        hist_rmse = sqrt(mean(hist_error^2, na.rm = TRUE)),
        hist_mae = mean(abs(hist_error), na.rm = TRUE),
        hist_mape = mean(abs(hist_error / time_until_arrival), na.rm = TRUE),
        hist_ci_cov = mean(hist_ci, na.rm = TRUE),
        hist_ci_width = mean(historical_upper - historical_lower, na.rm = TRUE),
        hist_ci_lower = quantile(historical_upper - historical_lower, 0.025, na.rm = TRUE),
        hist_ci_upper = quantile(historical_upper - historical_lower, 0.975, na.rm = TRUE),
        gtfs_rmse = sqrt(mean(gtfs_error^2)),
        gtfs_mae = mean(abs(gtfs_error)),
        gtfs_mape = mean(abs(gtfs_error / time_until_arrival))
    ) %>% arrange(hour)


plot_base <- ggplot(res_timeofday, aes(hour)) +
    theme_classic() +
    theme(legend.position = "none") +
    scale_colour_manual(values = pal, name = "model") +
    xlab("Time of day (hour)")

plot_rmse <- plot_base +
    geom_path(aes(y = pf_rmse, colour = "pf")) +
    geom_path(aes(y = normal_rmse, colour = "normal")) +
    geom_path(aes(y = hist_rmse, colour = "historical")) +
    geom_path(aes(y = gtfs_rmse, colour = "schedule-delay")) +
    scale_y_continuous(
        "RMSE (s)",
        trans = "log10"
    ) +
    theme(legend.position = "bottom")

plot_mae <- plot_base +
    geom_path(aes(y = pf_mae, colour = "pf")) +
    geom_path(aes(y = normal_mae, colour = "normal")) +
    geom_path(aes(y = hist_mae, colour = "historical")) +
    geom_path(aes(y = gtfs_mae, colour = "schedule-delay")) +
    scale_y_continuous(
        "MAE (s)",
        trans = "log10"
    )

plot_mape <- plot_base +
    geom_path(aes(y = 100 * pf_mape, colour = "pf")) +
    geom_path(aes(y = 100 * normal_mape, colour = "normal")) +
    geom_path(aes(y = 100 * hist_mape, colour = "historical")) +
    geom_path(aes(y = 100 * gtfs_mape, colour = "schedule-delay")) +
    scale_y_continuous(
        "MAPE (%)",
        trans = "log10"
    )

plot_ci <- plot_base +
    geom_hline(aes(yintercept = 85), lty = 2) +
    geom_path(aes(y = 100 * pf_ci_cov, colour = "pf")) +
    geom_path(aes(y = 100 * normal_ci_cov, colour = "normal")) +
    geom_path(aes(y = 100 * hist_ci_cov, colour = "historical")) +
    scale_y_continuous(
        name = "PICP (%)"
    )

plot_width <- plot_base +
    geom_ribbon(
        aes(
            ymin = pmax(0, pf_ci_lower),
            ymax = pmin(60 * 60, pf_ci_upper),
            fill = "pf"
        ),
        alpha = 0.2
    ) +
    geom_ribbon(
        aes(
            ymin = pmax(0, normal_ci_lower),
            ymax = pmin(60 * 60, normal_ci_upper),
            fill = "normal"
        ),
        alpha = 0.2
    ) +
    geom_ribbon(
        aes(
            ymin = pmax(0, hist_ci_lower),
            ymax = pmin(60 * 60, hist_ci_upper),
            fill = "historical"
        ),
        alpha = 0.2
    ) +
    geom_path(aes(y = pf_ci_width, colour = "pf")) +
    geom_path(aes(y = normal_ci_width, colour = "normal")) +
    geom_path(aes(y = hist_ci_width, colour = "historical")) +
    scale_y_continuous(
        name = "PPI width (m)",
        breaks = function(x) pretty(x / 60) * 60,
        labels = function(x) x / 60,
        limits = c(0, 60) * 60
    ) +
    scale_fill_manual(values = pal, name = "model")

library(patchwork)

plot_rmse + plot_mae +
    plot_mape + plot_ci +
    guide_area() +
    plot_layout(
        guides = "collect",
        design = "
            13
            24
            55
        ",
        heights = c(1, 1, 0.1)
    )
@

During off-peak (about 9:30~am until 2:30~pm) \Fpf{} shows the smallest error (\gls{rmse} and \gls{mae}), with \Fhist{} and \Fsched{} exhibiting slightly larger errors. \Fnorm{} again has much poorer accuracy\footnote{Remember to note the log scale.}. During peak times, all methods show an increase in prediction error as traffic conditions worsen and become more unreliable. \Fsched{} is least affected by the peak effect since the schedules do account somewhat for peak congestion, while the current implementation of our method only uses the \emph{current} traffic state; however, as discussed in \cref{sec:nw_hist_model}, improvements could be achieved by implementing a better forecast method.

In terms of relative error (\gls{mape}), we see a less accentuated peak effect, and now \Fpf{} demonstrates the best accuracy throughout the day. During peak time, traffic can quickly become more or less congested, so long-term predictions are prone to inaccuracy as we saw in \cref{fig:model_results_rmse_time}. Therefore, peak traffic has a noticeable effect on \gls{rmse} and \gls{mae}, but less so on \gls{mape}. \Gls{mape} for \Fsched{} and \Fhist{} seems unaffected by peak hour.


Finally, we look to \gls{picp}, where we can truly see the effect of peak traffic on the predicted arrival time distributions, particularly when obtained using \Fpf{}. During off-peak, \Fpf{} has very close to the desired coverage of 85\%; during peak time, however, coverage drops quite significantly. This drop is likely caused by travel times quickly increasing as congestion builds, meaning initial predictions are too early, and then as travel times decrease again once peak time has passed, the predictions are too late. Our \pf{} appears to be able to estimate travel times accurately, but it would benefit from the forecasting improvement described in \cref{sec:nw_hist_model}.\footnote{Which we were, unfortunately, unable to complete at this time.}




\subsection{Assessing the reliability of arrival time prediction}
\label{sec:prediction_model_comp_probs}

\Gls{rmse}, \gls{mae}, and \gls{mape} measure the predictive accuracy of the methods, but do not account for the costs associated with inaccurate predictions. In this section, we evaluate the \emph{reliability} of arrival time distributions by examining:
\begin{enumerate}
\item the wait time at the bus stop; and
\item the probability of missing the target bus.
\end{enumerate}
In most cases, the latter incurs a much higher cost, but depends entirely on time until the \emph{next} bus arrival: for high-frequency routes, this is small; for low-frequency ones, however, it can become quite high.\footnote{Some routes only run hourly!} In this section, I do not differentiate between high and low-frequency routes (I do in \cref{sec:eta_estimates}, however).


The three statistics we compare across the methods are:
\begin{itemize}
\item $\mathbb{P}_m = \Pr{\Varr_m \geq \hat\Tarr_m}$, the probability that the vehicle arrives after the point estimate, $\hat\Tarr_m$, indicating that were a passenger to arrive at the stop by $\hat\Tarr_m$, they would catch the bus with probability $\mathbb{P}_m$;
\item $\mathbb{P}_\ell = \Pr{\Varr_m \geq \hat\alpha_{m,\text{lower}}}$, the probability that the vehicles arrives after the lower bound of the \gls{ppi}; and
\item $\mathbb{E}_\ell = \E{\Varr_m - \hat\alpha_{m,\text{lower}} | \Varr_m \geq \hat\alpha_{m,\text{lower}}}$, the expected waiting time for a passenger arriving at the lower predictive bound, given that the bus arrives after it (that is, conditional on catching the bus).
\end{itemize}


<<model_results_pr_miss,echo=FALSE,message=FALSE,warning=FALSE,cache=TRUE,dependson=c("model_results_load","model_colours"),cache.lazy=FALSE>>=
pr_smry <- eta_results %>%
    mutate(
        # bus arrives after point estimate
        pf_catch = as.integer(time_until_arrival > pf_mean),
        normal_catch = as.integer(time_until_arrival > normal_mean),
        hist_catch = as.integer(time_until_arrival > historical_mean),
        gtfs_catch = as.integer(time_until_arrival > gtfs_eta),
        # bus arrives after lower bound
        pf_lower_catch = as.integer(time_until_arrival > pf_lower),
        normal_lower_catch = as.integer(time_until_arrival > normal_lower),
        hist_lower_catch = as.integer(time_until_arrival > historical_lower),
        # expected wait time | arrive at lower bound & don't miss bus
        pf_wait = ifelse(pf_lower_catch, time_until_arrival - pf_lower, NA),
        normal_wait = ifelse(normal_lower_catch, time_until_arrival - normal_lower, NA),
        hist_wait = ifelse(hist_lower_catch, time_until_arrival - historical_lower, NA),
    ) %>%
    summarize(
        pf_catch = mean(pf_catch),
        normal_catch = mean(normal_catch),
        hist_catch = mean(hist_catch, na.rm = TRUE),
        gtfs_catch = mean(gtfs_catch),
        pf_lower_catch = mean(pf_lower_catch),
        normal_lower_catch = mean(normal_lower_catch),
        hist_lower_catch = mean(hist_lower_catch, na.rm = TRUE),
        pf_wait_lower = quantile(pf_wait, 0.05, na.rm = TRUE),
        pf_wait_upper = quantile(pf_wait, 0.9, na.rm = TRUE),
        normal_wait_lower = quantile(normal_wait, 0.05, na.rm = TRUE),
        normal_wait_upper = quantile(normal_wait, 0.9, na.rm = TRUE),
        hist_wait_lower = quantile(hist_wait, 0.05, na.rm = TRUE),
        hist_wait_upper = quantile(hist_wait, 0.9, na.rm = TRUE),
        pf_wait = mean(pf_wait, na.rm = TRUE),
        normal_wait = mean(normal_wait, na.rm = TRUE),
        hist_wait = mean(hist_wait, na.rm = TRUE)
    )
pr_mat <- with(pr_smry,
    data.frame(
        pr_catch =
            round(100 * c(pf_catch, normal_catch, hist_catch, gtfs_catch)),
        pr_lower_catch =
            round(100 *
                c(pf_lower_catch, normal_lower_catch, hist_lower_catch, NA)
            ),
        exp_wait =
            round(c(pf_wait, normal_wait, hist_wait, NA) / 60, 1),
        exp_ci = c(
            glue::glue("{round(pf_wait_lower/60, 1)}--{round(pf_wait_upper/60, 1)}"),
            glue::glue("{round(normal_wait_lower/60, 1)}--{round(normal_wait_upper/60, 1)}"),
            glue::glue("{round(hist_wait_lower/60, 1)}--{round(hist_wait_upper/60, 1)}"),
            NA
        )
    )
)

options(knitr.kable.NA = "")
row.names(pr_mat) <- paste0(
    "\\F", c("pf", "norm", "hist", "sched"), "{}: ",
    c(
        "Particle filter",
        "Normal approximation",
        "Historical delays",
        "Schedule-delay"
    )
)
names(pr_mat) <- c(
    "$\\mathbb{P}_m$ (\\%)",
    "$\\mathbb{P}_\\ell$ (\\%)",
    "$\\mathbb{E}_\\ell$ (m)",
    "5--90\\% CI"
)
knitr::kable(
    pr_mat,
    booktabs = TRUE,
    caption = "Comparison of the reliability of the four prediction methods based on the results of estimating arrival times for a full day of historical data. $\\mathbb{P}_m$ and $\\mathbb{P}_\\ell$ are proportions of observed events, and $\\mathbb{E}_\\ell$ and its associated interval are based on the mean and quantiles.",
    caption.short = "Comparison of the reliability of the four prediction methods based on the results of estimating arrival times for a full day of historical data",
    escape = FALSE
) %>%
    kableExtra::kable_styling(font_size = 8)
@

The overall results are displayed in \cref{tab:model_results_pr_miss}. If a passenger, at any time, looks at the \gls{eta} of their bus \emph{once} and arrives at the stop by the indicated time, then using \Fpf{} the probability of catching the bus is \Sexpr{round(pr_mat[1,1])}\% versus only \Sexpr{round(pr_mat[4,1])}\% using \Fsched{}. For \Fhist{}, $\mathbb{P}_m$ is about 50\%, while for \Fnorm{} it is over 95\%, indicating that the Normal approximation is underestimating arrival times.


The concept behind examining the accuracy of the lower quantile, $\mathbb{P}_\ell$, is that this value should give passengers the best chance of catching the bus. We used the 2.5\% quantile for the lower estimate, so we would expect the bus to arrive after the predicted time 97.5\% of the time. This is the case for \Fnorm{} and \Fhist{}, but \Fpf{} has a slightly lower probability that expected. Associated with the lower bound is the expected wait time until the bus arrives, conditional on not having missed it ($\mathbb{E}_\ell$). \Fpf{} has the shortest expected wait followed closely by \Fhist{}, while the wait time using \Fnorm{} is about four times as long as that of \Fpf{}.


Since \Fsched{} provides only a point estimate, we cannot compare it directly to the other methods, in particular, \Fpf{}. To do so, we can \emph{indirectly} compare these methods by proposing that a passenger arrives $x$~minutes before the arrival time predicted by \Fsched{}, similar to the method described by \citet{Cathey_2003}, and calculating the probability of capture and expected wait time. The resulting curves for arriving 4--12~minutes before the stated arrival are shown in \cref{fig:model_results_pr_gtfs}, with the values for the other three methods overlaid as dashed lines.


<<model_results_pr_gtfs,echo=FALSE,message=FALSE,warning=FALSE,cache=TRUE,dependson=c("model_results_load","model_results_pr_miss"),cache.lazy=FALSE,fig.width=8,fig.height=3,out.width="\\textwidth",fig.align="center",fig.cap="Capture probability and expected wait times for a traveller arriving $x$ minutes before the schedule-delay prediction. The relevant values for the three other methods are displayed by dashed lines.",fig.scap="Capture probability and expected wait times for schedule-delay predictions">>=
# the equivalent values for GTFS
ers <- eta_results %>% select(timestamp, stop_sequence, time_until_arrival, gtfs_eta)
smrys <- do.call(rbind,
    lapply(4:12, function(mins) {
        ers %>%
            mutate(
                gtfs_catch = as.integer(time_until_arrival > gtfs_eta - mins * 60),
                gtfs_wait = ifelse(gtfs_catch, time_until_arrival - gtfs_eta + mins * 60, NA)
            ) %>%
            summarize(
                gtfs_catch = mean(gtfs_catch, na.rm = TRUE),
                gtfs_wait = mean(gtfs_wait, na.rm = TRUE)
            ) %>%
            mutate(min_before = mins)
    })
)

plot_base <- ggplot(smrys, aes(min_before)) +
    theme_classic(base_family = "Helvetica") +
    scale_colour_manual(values = pal, name = "model") +
    scale_x_continuous(
        name = "Time before schedule-delay ETA (minutes)",
        breaks = seq(4, 12, by = 2)
    )

plotA <- plot_base +
    geom_hline(
        aes(yintercept = 100 * pr_smry$pf_lower_catch, colour = "pf"),
        lty = 2
    ) +
    geom_hline(
        aes(yintercept = 100 * pr_smry$normal_lower_catch, colour = "normal"),
        lty = 2
    ) +
    geom_hline(
        aes(yintercept = 100 * pr_smry$hist_lower_catch, colour = "historical"),
        lty = 2
    ) +
    geom_path(aes(y = 100 * gtfs_catch, colour = "schedule-delay")) +
    #ylab(expression("\u2119"["\u2113"]~"(%)"))
    ylab(expression(P[l]~"(%)"))

plotB <- plot_base +
    geom_hline(aes(yintercept = pr_smry$pf_wait / 60, colour = "pf"), lty = 2) +
    geom_hline(aes(yintercept = 10 * NA, colour = "normal"), lty = 2) +
    geom_hline(aes(yintercept = pr_smry$hist_wait / 60, colour = "historical"), lty = 2) +
    geom_path(aes(y = gtfs_wait / 60, colour = "schedule-delay")) +
    ylab(expression(E[l]~"(minutes)"))

library(patchwork)
plotA + plotB + plot_layout(guides = "collect") &
    theme(legend.position = "bottom")

@



First, let us consider the probability of the bus arriving after the estimated arrival time, $\mathbb{P}_\ell$. Based on the data collected, a passenger would need to arrive at least 10~minutes before the \gls{eta} predicted by \Fsched{} to have a 97.5\% probability of catching the bus. To obtain the same probability as \Fpf{}, this would be a little more than 6~minutes before arrival. Now for the expected waiting time: to achieve the targetted 97.5\% chance of catching the bus, the passenger would arrive 10 minutes before the stated \gls{eta} which, from the figure on the right, has an expected waiting time of about 9~minutes. Arriving 6~minutes before yields an expected wait time of about 6~minutes, which is longer than the expected wait time under \Fpf{} (a little over 4~minutes), despite having the same probability of catching the bus.


We can also consider the reverse: a passenger would need to arrive no more than 4~minutes before the stated arrival time to have the same expected wait as \Fpf{}, giving them an 85\% chance of catching the bus compared to 93\% for \Fpf{}. For the remainder of this section, we use 6~minutes before the specified \gls{eta} to obtain a lower bound for \Fsched{}, and once more compare the probabilities as a function of time until arrival, stop sequence, and time of day.



\subsubsection{Time until arrival}

\Cref{fig:model_results_pr_time} shows $\mathbb{P}_m$, $\mathbb{P}_\ell$, and $\mathbb{E}_\ell$ computed at one-minute intervals for each of the four methods. \Fsched{} used a lower bound of $\hat\Tarr - 300$ (6~minutes before the point estimate). For the expected wait time, 5\% and 90\% quantiles are displayed as shaded regions. The dotted line in the expected waiting time graph represents the maximum possible waiting time; that is, the waiting time for a passenger already at the stop, given the bus is 10~minutes away, is 10~minutes.


<<model_results_pr_time,echo=FALSE,message=FALSE,warning=FALSE,cache=TRUE,dependson=c("model_results_load","model_results_pr_miss"),cache.lazy=FALSE,fig.width=8,fig.height=4,out.width="\\textwidth",fig.cap="Capture probabilities and expected wait times for the models by time until the bus's actual arrival. Expected wait time (right) includes a shaded region for the 5 and 90\\% quantiles of wait times.">>=
pr_smry_time <- eta_results %>%
    mutate(
        # bus arrives after point estimate
        pf_catch = as.integer(time_until_arrival > pf_mean),
        normal_catch = as.integer(time_until_arrival > normal_mean),
        hist_catch = as.integer(time_until_arrival > historical_mean),
        gtfs_catch = as.integer(time_until_arrival > gtfs_eta),
        # bus arrives after lower bound
        pf_lower_catch = as.integer(time_until_arrival > pf_lower),
        normal_lower_catch = as.integer(time_until_arrival > normal_lower),
        hist_lower_catch = as.integer(time_until_arrival > historical_lower),
        gtfs_lower_catch = as.integer(time_until_arrival > gtfs_eta - 8 * 60),
        # expected wait time | arrive at lower bound & don't miss bus
        pf_wait = ifelse(pf_lower_catch, time_until_arrival - pf_lower, NA),
        normal_wait = ifelse(normal_lower_catch, time_until_arrival - normal_lower, NA),
        hist_wait = ifelse(hist_lower_catch, time_until_arrival - historical_lower, NA),
        gtfs_wait = ifelse(gtfs_lower_catch, time_until_arrival - gtfs_eta + 8 * 60, NA),
        min = time_until_arrival %/% 60
    ) %>%
    group_by(min) %>%
    summarize(
        pf_catch = mean(pf_catch),
        normal_catch = mean(normal_catch),
        hist_catch = mean(hist_catch, na.rm = TRUE),
        gtfs_catch = mean(gtfs_catch),
        pf_lower_catch = mean(pf_lower_catch),
        normal_lower_catch = mean(normal_lower_catch),
        hist_lower_catch = mean(hist_lower_catch, na.rm = TRUE),
        gtfs_lower_catch = mean(gtfs_lower_catch, na.rm = TRUE),
        pf_wait_lower = quantile(pf_wait, 0.05, na.rm = TRUE),
        pf_wait_upper = quantile(pf_wait, 0.9, na.rm = TRUE),
        normal_wait_lower = quantile(normal_wait, 0.05, na.rm = TRUE),
        normal_wait_upper = quantile(normal_wait, 0.9, na.rm = TRUE),
        hist_wait_lower = quantile(hist_wait, 0.05, na.rm = TRUE),
        hist_wait_upper = quantile(hist_wait, 0.9, na.rm = TRUE),
        gtfs_wait_lower = quantile(gtfs_wait, 0.05, na.rm = TRUE),
        gtfs_wait_upper = quantile(gtfs_wait, 0.9, na.rm = TRUE),
        pf_wait = mean(pf_wait, na.rm = TRUE),
        normal_wait = mean(normal_wait, na.rm = TRUE),
        hist_wait = mean(hist_wait, na.rm = TRUE),
        gtfs_wait = mean(gtfs_wait, na.rm = TRUE)
    ) %>%
    filter(min < 40 & min > 0) %>% arrange(min)


plot_base <- ggplot(pr_smry_time, aes(min)) +
    theme_classic() +
    scale_colour_manual(values = pal, name = "model") +
    xlab("Time until arrival (minutes)")

plotA <- plot_base +
    #geom_hline(yintercept = 0.5, lty = 2) +
    geom_path(aes(y = pf_catch, colour = "pf")) +
    geom_path(aes(y = normal_catch, colour = "normal")) +
    geom_path(aes(y = hist_catch, colour = "historical")) +
    geom_path(aes(y = gtfs_catch, colour = "schedule-delay")) +
    ylab(expression(P[m]))

plotB <- plot_base +
    #geom_hline(yintercept = 0.975, lty = 2) +
    geom_path(aes(y = pf_lower_catch, colour = "pf")) +
    geom_path(aes(y = normal_lower_catch, colour = "normal")) +
    geom_path(aes(y = hist_lower_catch, colour = "historical")) +
    geom_path(aes(y = gtfs_lower_catch, colour = "schedule-delay")) +
    ylab(expression(P[l]))

plotC <- plot_base +
    #geom_abline(lty = 3) +
    geom_ribbon(
        aes(
            ymin = pmin(30, pmin(min, pf_wait_lower / 60)),
            ymax = pmin(30, pmin(min, pf_wait_upper / 60)),
            fill = "pf"
        ),
        alpha = 0.2
    ) +
    geom_ribbon(
        aes(
            ymin = pmin(30, pmin(min, normal_wait_lower / 60)),
            ymax = pmin(30, pmin(min, normal_wait_upper / 60)),
            fill = "normal"
        ),
        alpha = 0.2
    ) +
    geom_ribbon(
        aes(
            ymin = pmin(30, pmin(min, hist_wait_lower / 60)),
            ymax = pmin(30, pmin(min, hist_wait_upper / 60)),
            fill = "historical"
        ),
        alpha = 0.2
    ) +
    geom_ribbon(
        aes(
            ymin = pmin(30, pmin(min, gtfs_wait_lower / 60)),
            ymax = pmin(30, pmin(min, gtfs_wait_upper / 60)),
            fill = "schedule-delay"
        ),
        alpha = 0.2
    ) +
    geom_path(aes(y = pmin(min, pf_wait / 60), colour = "pf")) +
    geom_path(aes(y = pmin(min, normal_wait / 60), colour = "normal")) +
    geom_path(aes(y = pmin(min, hist_wait / 60), colour = "historical")) +
    geom_path(aes(y = pmin(min, gtfs_wait / 60), colour = "schedule-delay")) +
    scale_y_continuous(
        expression(E[l] (m)),
        limits = c(0, 30)
    ) +
    theme(legend.position = "none") +
    scale_fill_manual(values = pal, name = "model", guide = FALSE)

library(patchwork)
plotA + plotB + plotC + guide_area() +
    plot_layout(
        guides = "collect",
        design = "
            13
            24
        ",
        heights = c(1, 1)
    )
@


The probability that the bus arrives after the point estimate (mean or median), $\mathbb{P}_m$, is more or less constant with a slight decrease as the bus nears the stop. \Fpf{} and \Fnorm{} are above the expected value of 50\%, though the latter is significantly higher. \Fnorm{} performs reasonably well, though it tends to underestimate arrival time the farther out the bus is, while \Fsched{} overestimates arrival time such that there is less than a 40\% chance of catching the bus if it is less than 20~minutes away.


For $\mathbb{P}_\ell$, we observe a different trend: \Fpf{} and \Fhist{} increase the further out the vehicle is; on the other hand with \Fsched{}, the probability decreases, an artefact of using a fixed lower bound. Once the bus is about 15~minutes away, the lower bound of \mbox{$\hat\Tarr - 300$} (\Fsched{} minus 6~minutes) is increasingly likely to result in a caught bus, while under \Fpf{} this probability is lower since the width of the interval decreases as fewer sources of variability remain.


Finally, we examine the expected waiting time, given a passenger arrives at the lower bound \emph{and} the bus arrives after it. \Fpf{} has a consistently shorter waiting time, though by about 30~minutes until arrival the three methods (excluding \Fnorm{}) are approximately the same. We see that the expected waiting time for \Fsched{} is more or less independent of time until arrival, which is to be expected since the width is fixed. The shaded reasons represent 5\% and 90\% quantiles of waiting time, revealing that \Fpf{} results in shorter waits, on average, when the bus is less than 10~minutes away. The Normal approximation tends towards overestimation of arrival time uncertainty, so expected waiting time is considerable if arriving at the lower estimate, indicating that \Fnorm{} is not a reliable choice for arrival time prediction.


\subsubsection{Stop sequence}

The same values were computed by stop sequence and displayed in \cref{fig:model_results_pr_stop}. \Fhist{} achieves the target probability of 50\%, while \Fpf{} is slightly above at about 60\%. Most notable is the steady decline in the reliability of \Fsched{}, dropping to about a one in three chance of catching the bus after stop 40 (assuming you arrive at the predicted \gls{eta}).


<<model_results_pr_stop,echo=FALSE,message=FALSE,warning=FALSE,cache=TRUE,dependson=c("model_results_load","model_results_pr_miss"),cache.lazy=FALSE,fig.width=8,fig.height=4,out.width="\\textwidth",fig.cap="Capture probabilities and expected wait times for the models by stop sequence. Expected wait time (right) includes a shaded region for the 5 and 90\\% quantiles of wait times.">>=
pr_smry_stop <- eta_results %>%
    mutate(
        # bus arrives after point estimate
        pf_catch = as.integer(time_until_arrival > pf_mean),
        normal_catch = as.integer(time_until_arrival > normal_mean),
        hist_catch = as.integer(time_until_arrival > historical_mean),
        gtfs_catch = as.integer(time_until_arrival > gtfs_eta),
        # bus arrives after lower bound
        pf_lower_catch = as.integer(time_until_arrival > pf_lower),
        normal_lower_catch = as.integer(time_until_arrival > normal_lower),
        hist_lower_catch = as.integer(time_until_arrival > historical_lower),
        gtfs_lower_catch = as.integer(time_until_arrival > gtfs_eta - 8 * 60),
        # expected wait time | arrive at lower bound & don't miss bus
        pf_wait = ifelse(pf_lower_catch, time_until_arrival - pf_lower, NA),
        normal_wait = ifelse(normal_lower_catch, time_until_arrival - normal_lower, NA),
        hist_wait = ifelse(hist_lower_catch, time_until_arrival - historical_lower, NA),
        gtfs_wait = ifelse(gtfs_lower_catch, time_until_arrival - gtfs_eta + 8 * 60, NA),
        min = time_until_arrival %/% 60
    ) %>%
    group_by(stop_sequence) %>%
    summarize(
        pf_catch = mean(pf_catch),
        normal_catch = mean(normal_catch),
        hist_catch = mean(hist_catch, na.rm = TRUE),
        gtfs_catch = mean(gtfs_catch),
        pf_lower_catch = mean(pf_lower_catch),
        normal_lower_catch = mean(normal_lower_catch),
        hist_lower_catch = mean(hist_lower_catch, na.rm = TRUE),
        gtfs_lower_catch = mean(gtfs_lower_catch, na.rm = TRUE),
        pf_wait_lower = quantile(pf_wait, 0.05, na.rm = TRUE),
        pf_wait_upper = quantile(pf_wait, 0.9, na.rm = TRUE),
        normal_wait_lower = quantile(normal_wait, 0.05, na.rm = TRUE),
        normal_wait_upper = quantile(normal_wait, 0.9, na.rm = TRUE),
        hist_wait_lower = quantile(hist_wait, 0.05, na.rm = TRUE),
        hist_wait_upper = quantile(hist_wait, 0.9, na.rm = TRUE),
        gtfs_wait_lower = quantile(gtfs_wait, 0.05, na.rm = TRUE),
        gtfs_wait_upper = quantile(gtfs_wait, 0.9, na.rm = TRUE),
        pf_wait = mean(pf_wait, na.rm = TRUE),
        normal_wait = mean(normal_wait, na.rm = TRUE),
        hist_wait = mean(hist_wait, na.rm = TRUE),
        gtfs_wait = mean(gtfs_wait, na.rm = TRUE)
    ) %>%
    filter(stop_sequence <= 50) %>%
    arrange(stop_sequence)


plot_base <- ggplot(pr_smry_stop, aes(stop_sequence)) +
    theme_classic() +
    scale_colour_manual(values = pal, name = "model") +
    xlab("Stop sequence")

plotA <- plot_base +
    geom_path(aes(y = pf_catch, colour = "pf")) +
    geom_path(aes(y = normal_catch, colour = "normal")) +
    geom_path(aes(y = hist_catch, colour = "historical")) +
    geom_path(aes(y = gtfs_catch, colour = "schedule-delay")) +
    ylab(expression(P[m]))

plotB <- plot_base +
    geom_path(aes(y = pf_lower_catch, colour = "pf")) +
    geom_path(aes(y = normal_lower_catch, colour = "normal")) +
    geom_path(aes(y = hist_lower_catch, colour = "historical")) +
    geom_path(aes(y = gtfs_lower_catch, colour = "schedule-delay")) +
    ylab(expression(P[l]))

plotC <- plot_base +
    geom_ribbon(
        aes(
            ymin = pmin(30, pf_wait_lower / 60),
            ymax = pmin(30, pf_wait_upper / 60),
            fill = "pf"
        ),
        alpha = 0.2
    ) +
    geom_ribbon(
        aes(
            ymin = pmin(30, normal_wait_lower / 60),
            ymax = pmin(30, normal_wait_upper / 60),
            fill = "normal"
        ),
        alpha = 0.2
    ) +
    geom_ribbon(
        aes(
            ymin = pmin(30, hist_wait_lower / 60),
            ymax = pmin(30, hist_wait_upper / 60),
            fill = "historical"
        ),
        alpha = 0.2
    ) +
    geom_ribbon(
        aes(
            ymin = pmin(30, gtfs_wait_lower / 60),
            ymax = pmin(30, gtfs_wait_upper / 60),
            fill = "schedule-delay"
        ),
        alpha = 0.2
    ) +
    geom_path(aes(y = pf_wait / 60, colour = "pf")) +
    geom_path(aes(y = normal_wait / 60, colour = "normal")) +
    geom_path(aes(y = hist_wait / 60, colour = "historical")) +
    geom_path(aes(y = gtfs_wait / 60, colour = "schedule-delay")) +
    ylab(expression(E[l]~(m))) + ylim(0, 30) +
    theme(legend.position = "none") +
    scale_fill_manual(values = pal, name = "model")

library(patchwork)
plotA + plotB + plotC + guide_area() +
    plot_layout(
        guides = "collect",
        design = "
            13
            24
        ",
        heights = c(1, 1)
    )
@

Moving on to the lower 2.5\% quantile, $\mathbb{P}_\ell$, we expect 97.5\% probability of capture. We see that, as before, \Fpf{} overestimates arrival time slightly, with $\mathbb{P}_\ell$ of about 90\%, while for \Fsched{} it decreases with stop sequence. The associated wait time, $\mathbb{E}_\ell$, increases for all methods with increasing stop sequence \emph{except} for \Fsched{}, which decreases (remembering that the width is fixed). \Fpf{} has the lowest expected wait time, and the upper 90\% interval is lower than the mean for \Fsched{} for the first 20~stops. However, many stops with low indices are serviced within the first 5--10~minutes of the trip, thus inflating $\mathbb{P}_\ell$ under \Fsched{}.


\subsubsection{Time of day}

The probabilities and expected waiting time were calculated for 15~minute intervals for each of the models, as shown in \cref{fig:model_results_pr_timeofday}. The peak hour effects are one more visible and associated with an increased probability of arriving before the bus under \Fpf{} for both the median and 2.5\% quantile. For \Fsched{}, the probability of arriving before the bus decreases slightly during peak time. In the evening, we see the performance of \Fpf{} drop rapidly, likely due to the much-reduced probability of stopping (many evening services have low occupancy). Future work implementing more specific dwell time models could help to improve this.


<<model_results_pr_timeofday,echo=FALSE,message=FALSE,warning=FALSE,cache=TRUE,dependson=c("model_results_load","model_results_pr_miss"),cache.lazy=FALSE,fig.width=8,fig.height=4.5,out.width="\\textwidth",fig.cap="Capture probabilities and expected wait times for the models by time of day. Expected wait time (right) includes a shaded region for the 5 and 90\\% quantiles of wait times.">>=
pr_smry_timeofday <- eta_results %>%
    mutate(
        # bus arrives after point estimate
        pf_catch = as.integer(time_until_arrival > pf_mean),
        normal_catch = as.integer(time_until_arrival > normal_mean),
        hist_catch = as.integer(time_until_arrival > historical_mean),
        gtfs_catch = as.integer(time_until_arrival > gtfs_eta),
        # bus arrives after lower bound
        pf_lower_catch = as.integer(time_until_arrival > pf_lower),
        normal_lower_catch = as.integer(time_until_arrival > normal_lower),
        hist_lower_catch = as.integer(time_until_arrival > historical_lower),
        gtfs_lower_catch = as.integer(time_until_arrival > gtfs_eta - 8 * 60),
        # expected wait time | arrive at lower bound & don't miss bus
        pf_wait = ifelse(pf_lower_catch, time_until_arrival - pf_lower, NA),
        normal_wait = ifelse(normal_lower_catch, time_until_arrival - normal_lower, NA),
        hist_wait = ifelse(hist_lower_catch, time_until_arrival - historical_lower, NA),
        gtfs_wait = ifelse(gtfs_lower_catch, time_until_arrival - gtfs_eta + 8 * 60, NA),
        hour = timestamp %>% format("%H") %>% as.integer,
        minute = timestamp %>% format("%M") %>% as.integer,
        hour = hour + (floor(minute / 15) * 15 / 60)
    ) %>%
    group_by(hour) %>%
    summarize(
        pf_catch = mean(pf_catch),
        normal_catch = mean(normal_catch),
        hist_catch = mean(hist_catch, na.rm = TRUE),
        gtfs_catch = mean(gtfs_catch),
        pf_lower_catch = mean(pf_lower_catch),
        normal_lower_catch = mean(normal_lower_catch),
        hist_lower_catch = mean(hist_lower_catch, na.rm = TRUE),
        gtfs_lower_catch = mean(gtfs_lower_catch, na.rm = TRUE),
        pf_wait_lower = quantile(pf_wait, 0.05, na.rm = TRUE),
        pf_wait_upper = quantile(pf_wait, 0.9, na.rm = TRUE),
        normal_wait_lower = quantile(normal_wait, 0.05, na.rm = TRUE),
        normal_wait_upper = quantile(normal_wait, 0.9, na.rm = TRUE),
        hist_wait_lower = quantile(hist_wait, 0.05, na.rm = TRUE),
        hist_wait_upper = quantile(hist_wait, 0.9, na.rm = TRUE),
        gtfs_wait_lower = quantile(gtfs_wait, 0.05, na.rm = TRUE),
        gtfs_wait_upper = quantile(gtfs_wait, 0.9, na.rm = TRUE),
        pf_wait = mean(pf_wait, na.rm = TRUE),
        normal_wait = mean(normal_wait, na.rm = TRUE),
        hist_wait = mean(hist_wait, na.rm = TRUE),
        gtfs_wait = mean(gtfs_wait, na.rm = TRUE)
    ) %>%
    arrange(hour)


plot_base <- ggplot(pr_smry_timeofday, aes(hour)) +
    theme_classic() +
    scale_colour_manual(values = pal, name = "model") +
    xlab("Time of day")

plotA <- plot_base +
    geom_path(aes(y = pf_catch, colour = "pf")) +
    geom_path(aes(y = normal_catch, colour = "normal")) +
    geom_path(aes(y = hist_catch, colour = "historical")) +
    geom_path(aes(y = gtfs_catch, colour = "schedule-delay")) +
    ylab(expression(P[m]))

plotB <- plot_base +
    geom_path(aes(y = pf_lower_catch, colour = "pf")) +
    geom_path(aes(y = normal_lower_catch, colour = "normal")) +
    geom_path(aes(y = hist_lower_catch, colour = "historical")) +
    geom_path(aes(y = gtfs_lower_catch, colour = "schedule-delay")) +
    ylab(expression(P[l]))

plotC <- plot_base +
    geom_ribbon(
        aes(
            ymin = pmin(30, pf_wait_lower / 60),
            ymax = pmin(30, pf_wait_upper / 60),
            fill = "pf"
        ),
        alpha = 0.2
    ) +
    geom_ribbon(
        aes(
            ymin = pmin(30, normal_wait_lower / 60),
            ymax = pmin(30, normal_wait_upper / 60),
            fill = "normal"
        ),
        alpha = 0.2
    ) +
    geom_ribbon(
        aes(
            ymin = pmin(30, hist_wait_lower / 60),
            ymax = pmin(30, hist_wait_upper / 60),
            fill = "historical"
        ),
        alpha = 0.2
    ) +
    geom_ribbon(
        aes(
            ymin = pmin(30, gtfs_wait_lower / 60),
            ymax = pmin(30, gtfs_wait_upper / 60),
            fill = "schedule-delay"
        ),
        alpha = 0.2
    ) +
    geom_path(aes(y = pf_wait / 60, colour = "pf")) +
    geom_path(aes(y = normal_wait / 60, colour = "normal")) +
    geom_path(aes(y = hist_wait / 60, colour = "historical")) +
    geom_path(aes(y = gtfs_wait / 60, colour = "schedule-delay")) +
    ylab(expression(E[l] (m))) + ylim(0, 30) +
    theme(legend.position = "none") +
    scale_fill_manual(values = pal, name = "model")

library(patchwork)
plotA + plotB + plotC + guide_area() +
    plot_layout(
        guides = "collect",
        design = "
            13
            24
        ",
        heights = c(1, 1)
    )
@


We see much the same pattern with the expected wait time $\mathbb{E}_\ell$, which increase by a few minutes under \Fpf{} during peak times. There is little noticeable change for \Fsched{} and \Fhist{}. Even so, \Fpf{} consistently provides shorter expected wait times than \Fsched{}.


\subsection{Result summary}
\label{sec:prediction_model_comp_summary}

The results in \cref{sec:prediction_model_comp_stats,sec:prediction_model_comp_probs} demonstrate the relative accuracy and reliability of four methods of predicting the arrival time distribution at a stop. The particle filter (\Fpf{}) uses a sample of weighted particles representing the vehicle's state, along with the \rt{} traffic state, to approximate the distribution. On average, it is slightly more accurate than the currently used method (\Fsched{}), particularly when the bus is within 20~minutes of arriving and during the daytime off-peak period, and captures most of the uncertainty during this period (as per \gls{picp}).

As for the reliability of the estimates---that is, their use as an \gls{eta} for commuters---the \pf{} tends to underestimate arrival time, whereas the current method tends to \emph{overestimate} it. In terms of the application, the former is preferred, often resulting in a 30\% higher probability of catching the bus. The \pf{} provides an estimate of the arrival time distribution, allowing easy estimation of quantiles. We have seen that the lower bound is typically an overestimate, indicating that perhaps not enough variability is being included, or perhaps that more particles are needed. The presented results used $\tilde N = 200$, but future work could involve modifying this depending on the number of stops remaining along a route. However, the lower bound still gives a 90--95\% chance of catching the bus in most cases and has a significantly shorter wait time compared to the current method (assuming one arrives 6~minutes before the specified time). This difference indicates that the \pf{}, as well as providing improved prediction accuracy, can offer more reliability for passengers.


We saw that there were a few scenarios that could be attributed to much of the \pf{}'s weaker performance, namely peak times and evenings. Further work could be performed, particularly on forecasting network travel times, to improve these predictions. We also presented two other models. The Normal approximation (\Fnorm{}) demonstrated inferior performance in that it tended to overestimate arrival time uncertainty, a likely result of combining the mixtures. Historical data (\Fhist{}), in which the arrival time prediction distribution was based purely on the distribution of arrival time delays at stops along a route, performed admirably. It estimated the distribution quantiles well, but its reliability (at least compared to the other methods) decreased once the trip was underway and \rt{} information was available. It does, however, suggest that historical data should be used for prior predictions of arrival time: before a trip has registered with the \rt{} service, the best prediction of arrival time is \Fhist{}.
