\section{Assessing predictive performance}
\label{sec:prediction_model_comparison}


To compare the four prediction methods, we implemented the first two in the \textsf{transitr} application and, using a single day of data, run the program, storing all arrival time estimates, the uncertainty, as well as the 5\% and 90\% quantiles\footnote{Initially we used a symmetric 95\% prediction interval, but this was often highly skewed by a few very late particles.}. The actual (reported) arrival times are then used to compare the accuracy of each method. For the historical data, we compare the mean with the actual arrival time. For the schedule-delay method, the arrival time for all upcoming stops was predicted after each new observation, and the prediction error computed.

\begin{itemize}
\item yes, rewrite the above para to make more sense please.
\item and, the below might need some more words about MAE/MAPE \ldots
\end{itemize}

We used \gls{rmse}, \gls{mae}, and \gls{mape} as comparison criteria (see \cref{app:error-functions}).
\Gls{rmse} is the mean squared difference (in seconds) between the predicted and actual arrival times. Of course, since predictions change over time, we also compute \gls{rmse} by \emph{time until (actual) arrival}, allowing us to compare the models at different time points, as well as by stop sequence and time of day.


Another criteria we are interested in is the \gls{picp}, which is only available for the three methods for which we can construct an 85\% \gls{ppi}: for the particle filter, this is achieved by sorting the particles in order of arrival time, and then taking the $\lfloor q_\text{lower} N^\star\rfloor^{\text{th}}$ particle as the lower bound, and the $\lceil q_{\text{upper}} N^\star\rceil^{\text{th}}$ particle as the upper bound (more details in \cref{app:particle_summaries}). For the 85\% interval, we used $q_\text{lower} = 0.05$ and $q_\text{upper} = 0.9$. For the normal approximation and historical arrival methods, the inverse \gls{cdf} provides the required quantiles. The results are displayed in \cref{tab:model_results_rmse} and \cref{fig:model_results_rmse_time,fig:model_results_rmse_stopn,fig:model_results_rmse_timeofday} (described in \cref{sec:prediction_model_comp_stats}).


\begin{itemize}
\item predictive power, or `reliability'?
\end{itemize}

Additionally, we also want to compare the predictive power of the various forecast methods, namely \emph{the probability of arriving before the bus}, and hence not missing it, as well as the expected waiting time given a passenger arrives at the stop by a certain time. In table \cref{tab:model_results_pr_miss} and \cref{fig:model_results_pr_gtfs,fig:model_results_pr_time,fig:model_results_pr_stop,fig:model_results_pr_timeofday}, we use the point estimate (mean or median, depending on the forecast method), as well as the 5\% quantile, and for each calculate the probability that the bus arrives after the specified time. We also calculate the expected waiting time for a passenger arriving at a certain time \emph{and the bus arrives after the specified time} (i.e., the passenger catches the bus). \Cref{sec:prediction_model_comp_probs} discusses these results.


<<model_colours,echo=FALSE,cache=TRUE>>=
pal <- RColorBrewer::brewer.pal(4, "Set1")
names(pal) <- c("pf", "normal", "historical", "gtfs")
options(knitr.kable.NA = '')
@

<<model_results_load,echo=FALSE,message=FALSE,warning=FALSE,cache=TRUE,cache.lazy=FALSE>>=
suppressPackageStartupMessages({
    library(tidyverse)
})


eta_files <- list.files("data",
    pattern = "eta_results.\\.rda",
    full.names = TRUE
)
eta_results_all <-
    do.call(bind_rows,
        lapply(eta_files, function(f) {
            load(f)
            etai
        })
    ) %>% mutate(
        hist_error = historical_mean - time_until_arrival,
        hist_ci = as.integer(
            historical_lower <= time_until_arrival &
            time_until_arrival <= historical_upper
        )
    ) %>%
    ungroup()

# routes_to_keep <-
# c("1", "101", "105", "106", "110", "111", "112", "114", "120",
# "126", "131", "132", "133", "134", "138", "141", "142", "143",
# "146", "14T", "14W", "152", "154", "161", "162", "170", "172",
# "18", "186", "191", "195", "2", "20", "22A", "22N", "22R", "24B",
# "24R", "25B", "25L", "27H", "27T", "27W", "295", "298", "30",
# "309", "31", "313", "314", "32", "321", "323", "324", "325",
# "326", "33", "35", "351", "352", "353", "355", "361", "362",
# "365", "366", "371", "372", "373", "376", "377", "378", "380",
# "391", "392", "393", "650", "66", "670", "68", "711", "712",
# "714", "72C", "72M", "72X", "734", "735", "739", "743", "744",
# "747", "75", "751", "755", "762", "774", "781", "782", "783",
# "801", "814", "82", "83", "843", "845", "856", "861", "865",
# "871", "883", "884", "885", "889", "901", "906", "907", "917",
# "923", "924", "926", "928", "931", "933", "941", "942", "95B",
# "95C", "97B", "97R", "981", "982", "983", "985", "998", "CTY",
# "INN", "NX1", "NX2", "OUT", "SKY", "TMK")

eta_results <- eta_results_all #%>% filter(route_short_name %in% routes_to_keep)
@

<<model_results_rmse,echo=FALSE,message=FALSE,warning=FALSE,cache=TRUE,dependson=c("model_results_load","model_colours"),cache.lazy=FALSE>>=
mat <- eta_results %>%
    filter(time_until_arrival > 0) %>%
    summarize(
        pf_rmse = sqrt(mean(pf_error^2)),
        pf_mae = mean(abs(pf_error)),
        pf_mape = mean(abs(pf_error / time_until_arrival)),
        pf_ci_cov = mean(pf_ci),
        pf_ci_width = mean(pf_upper - pf_lower),
        pf_ci_lower = quantile(pf_upper - pf_lower, 0.025),
        pf_ci_upper = quantile(pf_upper - pf_lower, 0.975),
        normal_rmse = sqrt(mean(normal_error^2)),
        normal_mae = mean(abs(normal_error)),
        normal_mape = mean(abs(normal_error / time_until_arrival)),
        normal_ci_cov = mean(normal_ci),
        normal_ci_width = mean(normal_upper - normal_lower),
        normal_ci_lower = quantile(normal_upper - normal_lower, 0.025),
        normal_ci_upper = quantile(normal_upper - normal_lower, 0.975),
        hist_rmse = sqrt(mean(hist_error^2, na.rm = TRUE)),
        hist_mae = mean(abs(hist_error), na.rm = TRUE),
        hist_mape = mean(abs(hist_error / time_until_arrival), na.rm = TRUE),
        hist_ci_cov = mean(hist_ci, na.rm = TRUE),
        hist_ci_width = mean(historical_upper - historical_lower, na.rm = TRUE),
        hist_ci_lower = quantile(historical_upper - historical_lower, 0.025, na.rm = TRUE),
        hist_ci_upper = quantile(historical_upper - historical_lower, 0.975, na.rm = TRUE),
        gtfs_rmse = sqrt(mean(gtfs_error^2)),
        gtfs_mae = mean(abs(gtfs_error)),
        gtfs_mape = mean(abs(gtfs_error / time_until_arrival))
    ) %>%
    with(
        data.frame(
            rmse = round(c(pf_rmse, normal_rmse, hist_rmse, gtfs_rmse)),
            mae = round(c(pf_mae, normal_mae, hist_mae, gtfs_mae)),
            mape = round(100 * c(pf_mape, normal_mape, hist_mape, gtfs_mape)),
            ci_cov = round(100 * c(pf_ci_cov, normal_ci_cov, hist_ci_cov, NA))
            #ci_width = round(c(pf_ci_width, normal_ci_width, hist_ci_width, NA) / 60),
            #ci_ci = c(
            #    glue::glue("({round(pf_ci_lower/60, 1)}, {round(pf_ci_upper/#60, 1)})"),
            #    glue::glue("({round(normal_ci_lower/60, 1)}, {round#(normal_ci_upper/60, 1)})"),
           #     glue::glue("({round(hist_ci_lower/60, 1)}, {round(hist_ci_upper/60, 1)})"),
            #    NA
            #)
        )
    )
row.names(mat) <- paste0(
    "\\F", c("pf", "norm", "hist", "sched"), "{}: ",
    c(
        "Particle filter",
        "Normal approximation",
        "Historical delays",
        "Schedule-delay"
    )
)
names(mat) <- c(
    "RMSE (s)",
    "MAE (s)",
    "MAPE (\\%)",
    "PICP (\\%)"
    #"\\multicolumn{2}{c}{PPI width (m)}",
    #"SKIP"
)
options(knitr.kable.NA = "")
tbl <- knitr::kable(
    mat,
    format = "latex",
    booktabs = TRUE,
    caption = "Predictive model comparison of RMSE and MAE, in seconds, MAPE (\\%), and PICP (\\%).",
    escape = FALSE
)
#tbl <- gsub("& SKIP", "", tbl)
tbl %>% kableExtra::kable_styling(font_size = 8)

@




\subsection{Comparing the accuracy of arrival time prediction}
\label{sec:prediction_model_comp_stats}

The accuracy measurements (\gls{rmse}, \gls{mae}, and \gls{mape}) shown in \cref{tab:model_results_rmse} immediately show that the normal approximation (\Fnorm{}) estimates are, on average, about half as accurate as the other methods. Overall, the \pf{} (\Fpf{}) demonstrates the greatest accuracy by all criteria, indicating that its estimates are (on average) closer to the true value in both absolute and relative terms. The historical delays approach (\Fhist{}) has similar accuracy to the schedule-delay approach (\Fsched{}) in absolute terms (\gls{rmse} and \gls{mae}), but the least accurate over all in realtive terms (\gls{mape}), indicating that it has poorer accuracy for short-term forecasts; this is not surprising as it uses purely historical data, so \rt{} information about vehicle location and network state are ignored.


As for the \gls{picp}, the theoretical coverage is 85\%. \Fpf{} seems to underestimate arrival time uncertainty, which indicates that not enough uncertainty is being captured by the model: this could be any combination of dwell time, travel time, or the unknown. Conversely, \Fnorm{} overestimates uncertainty by about 5\%. \Fhist{} has close to the desired \gls{picp}, which demonstrates that arrival time delays at each stop show a certain level of consistency.



From the simple, overall summary in \cref{tab:model_results_rmse}, it is difficult to comment on the relative performance of the methods, except that the normal approximation seems to be ill-suited to the task. However, this was not unexpected: throughout the previous chapters, we have commented on the non-Gaussian nature of transit vehicle state. We now explore the effects of time until arrival, stop sequence, and time of day on prediction accuracy.


\subsubsection{Time until actual arrival}

We would expect arrival time predictions for a given stop to become more accurate as the bus approaches it. To assess this, arrival time estimates for binned into one-minute intervals, and for each interval the same summary statistics were estimated and displayed in \cref{fig:model_results_rmse_time}. Note the use of log scales for \gls{rmse}, \gls{mae}, and \gls{mape}.



<<model_results_rmse_time,warning=FALSE,echo=FALSE,cache=TRUE,dependson=c("model_results_load","model_colours"),cache.lazy=FALSE,fig.width=8,fig.height=4,out.width="\\textwidth",fig.cap="Model comparative statistics as a function of time until arrival. Note the log-scale for RMSE, MAE, and MAPE.">>=
# tidyverse is loaded!
res_min <- eta_results %>%
    mutate(
        min = time_until_arrival %/% 60
    ) %>%
    filter(time_until_arrival > 0) %>%
    group_by(min) %>%
    summarize(
        pf_rmse = sqrt(mean(pf_error^2)),
        pf_mae = mean(abs(pf_error)),
        pf_mape = mean(abs(pf_error / time_until_arrival)),
        pf_ci_cov = mean(pf_ci),
        pf_ci_width = mean(pf_upper - pf_lower),
        pf_ci_lower = quantile(pf_upper - pf_lower, 0.025),
        pf_ci_upper = quantile(pf_upper - pf_lower, 0.975),
        normal_rmse = sqrt(mean(normal_error^2)),
        normal_mae = mean(abs(normal_error)),
        normal_mape = mean(abs(normal_error / time_until_arrival)),
        normal_ci_cov = mean(normal_ci),
        normal_ci_width = mean(normal_upper - normal_lower),
        normal_ci_lower = quantile(normal_upper - normal_lower, 0.025),
        normal_ci_upper = quantile(normal_upper - normal_lower, 0.975),
        hist_rmse = sqrt(mean(hist_error^2, na.rm = TRUE)),
        hist_mae = mean(abs(hist_error), na.rm = TRUE),
        hist_mape = mean(abs(hist_error / time_until_arrival), na.rm = TRUE),
        hist_ci_cov = mean(hist_ci, na.rm = TRUE),
        hist_ci_width = mean(historical_upper - historical_lower, na.rm = TRUE),
        hist_ci_lower = quantile(historical_upper - historical_lower, 0.025, na.rm = TRUE),
        hist_ci_upper = quantile(historical_upper - historical_lower, 0.975, na.rm = TRUE),
        gtfs_rmse = sqrt(mean(gtfs_error^2)),
        gtfs_mae = mean(abs(gtfs_error)),
        gtfs_mape = mean(abs(gtfs_error / time_until_arrival))
    ) %>% arrange(min) %>%
    filter(min < 40)

plot_base <- ggplot(res_min, aes(min)) +
    theme_classic() +
    theme(legend.position = "none") +
    scale_colour_manual(values = pal, name = "model") +
    xlab("Time until arrival (minutes)")

plot_rmse <- plot_base +
    geom_path(aes(y = pf_rmse, colour = "pf")) +
    geom_path(aes(y = normal_rmse, colour = "normal")) +
    geom_path(aes(y = hist_rmse, colour = "historical")) +
    geom_path(aes(y = gtfs_rmse, colour = "gtfs")) +
    scale_y_continuous(
        "RMSE (s)",
        trans = "log10"
    ) +
    theme(legend.position = "bottom")

plot_mae <- plot_base +
    geom_path(aes(y = pf_mae, colour = "pf")) +
    geom_path(aes(y = normal_mae, colour = "normal")) +
    geom_path(aes(y = hist_mae, colour = "historical")) +
    geom_path(aes(y = gtfs_mae, colour = "gtfs")) +
    scale_y_continuous(
        "MAE (s)",
        trans = "log10"
    )

plot_mape <- plot_base +
    geom_path(aes(y = 100 * pf_mape, colour = "pf")) +
    geom_path(aes(y = 100 * normal_mape, colour = "normal")) +
    geom_path(aes(y = 100 * hist_mape, colour = "historical")) +
    geom_path(aes(y = 100 * gtfs_mape, colour = "gtfs")) +
    scale_y_continuous(
        "MAPE (%)",
        trans = "log10"
    )
    #ylab("MAPE (%)") + ylim(0, 160)

plot_ci <- plot_base +
    geom_hline(aes(yintercept = 85), lty = 2) +
    geom_path(aes(y = 100 * pf_ci_cov, colour = "pf")) +
    geom_path(aes(y = 100 * normal_ci_cov, colour = "normal")) +
    geom_path(aes(y = 100 * hist_ci_cov, colour = "historical")) +
    scale_y_continuous(
        name = "PICP (%)"
    )

plot_width <- plot_base +
    geom_ribbon(
        aes(
            ymin = pmax(0, pf_ci_lower),
            ymax = pmin(60 * 60, pf_ci_upper),
            fill = "pf"
        ),
        alpha = 0.2
    ) +
    geom_ribbon(
        aes(
            ymin = pmax(0, normal_ci_lower),
            ymax = pmin(60 * 60, normal_ci_upper),
            fill = "normal"
        ),
        alpha = 0.2
    ) +
    geom_ribbon(
        aes(
            ymin = pmax(0, hist_ci_lower),
            ymax = pmin(60 * 60, hist_ci_upper),
            fill = "historical"
        ),
        alpha = 0.2
    ) +
    geom_path(aes(y = pf_ci_width, colour = "pf")) +
    geom_path(aes(y = normal_ci_width, colour = "normal")) +
    geom_path(aes(y = hist_ci_width, colour = "historical")) +
    scale_y_continuous(
        name = "PPI width (m)",
        breaks = function(x) pretty(x / 60) * 60,
        labels = function(x) x / 60,
        limits = c(0, 60) * 60
    ) +
    scale_fill_manual(values = pal, name = "model")

library(patchwork)


plot_rmse + plot_mae +
    plot_mape + plot_ci +
    #plot_width +
    guide_area() +
    plot_layout(
        #ncol = 2,
        #byrow = FALSE,
        guides = "collect",
        design = "
            13
            24
            55
        ",
        heights = c(1, 1, 0.1)
    )

@


The \gls{rmse} and \gls{mae} for all methods increase with time until arrival as expected, but the rate at which this occurs varies. The three methods that use \rt{} information (\Fpf{}, \Fnorm{}, and \Fsched{}) demonstrate small absolute error when the bus is near, which increases the farther out the bus gets, while \Fhist{} shows a more constant error and far poorer accuracy when the bus is less than 50--10~minutes away. \Fpf{} has the lowest error up until 20~minutes before arrival, and has greater accuracy than \Fsched{} up until 25--30~minutes. This indicates that the current delay is only a useful predictor when the bus has almost arrived, and that accounting for \rt{} traffic conditions \emph{does} improve the accuracy of arrival time prediction. \Fnorm{} quickly shows large prediction errors for all but the nearest buses.


<<route_length_times,echo=FALSE,message=FALSE,warning=FALSE,cache=TRUE>>=
library(tidyverse)

here <- setwd("../../data")
source("load_data.R")
setwd(here)

to_int <- function(x) {
    sapply(strsplit(x, ":"),
        function(z) {
            sum(as.integer(z) * c(60 * 60, 60, 1))
        }
    )
}

con <- dbConnect(SQLite(), db)
trip_lengths <- con %>% tbl("stop_times") %>%
    filter(trip_id %like% "%_v82.21") %>%
    arrange(trip_id, stop_sequence) %>%
    group_by(trip_id) %>%
    summarize(
        start = min(departure_time, na.rm = TRUE),
        end = max(arrival_time, na.rm = TRUE),
        n_stop = max(stop_sequence, na.rm = TRUE)
    ) %>%
    collect() %>%
    mutate(
        length = to_int(end) - to_int(start)
    )
dbDisconnect(con)

@

The \gls{mape} for all methods decreases with time until arrival, with \Fhist{} showing the highest relative error when the bus is less than about 5~minutes away. \Fnorm{} remains fairly constant with a large relative error (about 50\%).Again for the first 20~minutes, \Fpf{} has the smallest relative error, and is better than \Fsched{} up until the bus is 25--30~minutes away. After 30~minutes, \Fpf{} seems to converge with slightly lower accuracy than \Fhist{} and \Fsched{}, which appear to be continue improving accuracy after the 40~minute cut-off; however, \Sexpr{round(100*mean(trip_lengths$length < 60*60))}\% of routes in Auckland are less than one hour, so the number of arrival time predictions being made that are greater than 40~minutes becomes small (predictions are only made once the trip starts).


The \gls{picp} is not available for \Fsched{} since that method only provides point estimates. The coverage for the three remaining methods is reasonably constant across time until arrival \cref{fig:model_results_rmse_time}. As we saw earlier, \Fpf{} underestimates uncertainty, resuling in lower than expected coverage, and \Fnorm{} overestimates uncertainty for all times greater than a few minutes. \Fhist{} shows good coverage, although this drops off slightly as time until arrival increases, which could indicate that arrival times for later stops along long routes (since these are the only ones with times until arrival this large) are prone to more variability.




\subsubsection{Stop sequence}

Similarly to time until arrival, we grouped results by stop sequence---skipping the first stop since arrival times are only predicted once the bus begins the trip---and computed the familiar summary statistics, which are displayed in \cref{fig:model_results_rmse_stopn}. Note that stop sequence and time until arrival are correlated, since early stops along a route seldom have long until the bus arrives (once it has begun), and that only \Sexpr{round(100 * mean(trip_lengths$n_stop > 50))}\% of ~trips have more than 50~stops.


<<model_results_rmse_stopn,warning=FALSE,echo=FALSE,cache=TRUE,dependson=c("model_results_load","model_colours"),cache.lazy=FALSE,fig.width=8,fig.height=4,out.width="\\textwidth",fig.cap="Model comparative statistics as a function of stop sequence.">>=
# library(patchwork)
# tidyverse is loaded!
res_stop <- eta_results %>%
    mutate(
        min = time_until_arrival %/% 60
    ) %>%
    filter(time_until_arrival > 0 & stop_sequence > 1) %>%
    group_by(stop_sequence) %>%
    summarize(
        pf_rmse = sqrt(mean(pf_error^2)),
        pf_mae = mean(abs(pf_error)),
        pf_mape = mean(abs(pf_error / time_until_arrival)),
        pf_ci_cov = mean(pf_ci),
        pf_ci_width = mean(pf_upper - pf_lower),
        pf_ci_lower = quantile(pf_upper - pf_lower, 0.025),
        pf_ci_upper = quantile(pf_upper - pf_lower, 0.975),
        normal_rmse = sqrt(mean(normal_error^2)),
        normal_mae = mean(abs(normal_error)),
        normal_mape = mean(abs(normal_error / time_until_arrival)),
        normal_ci_cov = mean(normal_ci),
        normal_ci_width = mean(normal_upper - normal_lower),
        normal_ci_lower = quantile(normal_upper - normal_lower, 0.025),
        normal_ci_upper = quantile(normal_upper - normal_lower, 0.975),
        hist_rmse = sqrt(mean(hist_error^2, na.rm = TRUE)),
        hist_mae = mean(abs(hist_error), na.rm = TRUE),
        hist_mape = mean(abs(hist_error / time_until_arrival), na.rm = TRUE),
        hist_ci_cov = mean(hist_ci, na.rm = TRUE),
        hist_ci_width = mean(historical_upper - historical_lower, na.rm = TRUE),
        hist_ci_lower = quantile(historical_upper - historical_lower, 0.025, na.rm = TRUE),
        hist_ci_upper = quantile(historical_upper - historical_lower, 0.975, na.rm = TRUE),
        gtfs_rmse = sqrt(mean(gtfs_error^2)),
        gtfs_mae = mean(abs(gtfs_error)),
        gtfs_mape = mean(abs(gtfs_error / time_until_arrival))
    ) %>%
    filter(stop_sequence <= 60) %>%
    arrange(stop_sequence)

plot_base <- ggplot(res_stop, aes(stop_sequence)) +
    theme_classic() +
    theme(legend.position = "none") +
    scale_colour_manual(values = pal, name = "model") +
    xlab("Stop sequence")

plot_rmse <- plot_base +
    geom_path(aes(y = pf_rmse, colour = "pf")) +
    geom_path(aes(y = normal_rmse, colour = "normal")) +
    geom_path(aes(y = hist_rmse, colour = "historical")) +
    geom_path(aes(y = gtfs_rmse, colour = "gtfs")) +
    scale_y_continuous(
        "RMSE (s)",
        trans = "log10"
    ) +
    theme(legend.position = "bottom")

plot_mae <- plot_base +
    geom_path(aes(y = pf_mae, colour = "pf")) +
    geom_path(aes(y = normal_mae, colour = "normal")) +
    geom_path(aes(y = hist_mae, colour = "historical")) +
    geom_path(aes(y = gtfs_mae, colour = "gtfs")) +
    scale_y_continuous(
        "MAE (s)",
        trans = "log10"
    )

plot_mape <- plot_base +
    geom_path(aes(y = 100 * pf_mape, colour = "pf")) +
    geom_path(aes(y = 100 * normal_mape, colour = "normal")) +
    geom_path(aes(y = 100 * hist_mape, colour = "historical")) +
    geom_path(aes(y = 100 * gtfs_mape, colour = "gtfs")) +
    scale_y_continuous(
        "MAPE (%)",
        trans = "log10"
    )

plot_ci <- plot_base +
    geom_hline(aes(yintercept = 85), lty = 2) +
    geom_path(aes(y = 100 * pf_ci_cov, colour = "pf")) +
    geom_path(aes(y = 100 * normal_ci_cov, colour = "normal")) +
    geom_path(aes(y = 100 * hist_ci_cov, colour = "historical")) +
    scale_y_continuous(
        name = "PICP (%)"
    )

plot_width <- plot_base +
    geom_ribbon(
        aes(
            ymin = pmax(0, pf_ci_lower),
            ymax = pmin(60 * 60, pf_ci_upper),
            fill = "pf"
        ),
        alpha = 0.2
    ) +
    geom_ribbon(
        aes(
            ymin = pmax(0, normal_ci_lower),
            ymax = pmin(60 * 60, normal_ci_upper),
            fill = "normal"
        ),
        alpha = 0.2
    ) +
    geom_ribbon(
        aes(
            ymin = pmax(0, hist_ci_lower),
            ymax = pmin(60 * 60, hist_ci_upper),
            fill = "historical"
        ),
        alpha = 0.2
    ) +
    geom_path(aes(y = pf_ci_width, colour = "pf")) +
    geom_path(aes(y = normal_ci_width, colour = "normal")) +
    geom_path(aes(y = hist_ci_width, colour = "historical")) +
    scale_y_continuous(
        name = "PPI width (m)",
        breaks = function(x) pretty(x / 60) * 60,
        labels = function(x) x / 60,
        limits = c(0, 60) * 60
    ) +
    scale_fill_manual(values = pal, name = "model")

library(patchwork)

plot_rmse + plot_mae +
    plot_mape + plot_ci +
    guide_area() +
    plot_layout(
        guides = "collect",
        design = "
            13
            24
            55
        ",
        heights = c(1, 1, 0.1)
    )

@

The \gls{rmse} and \gls{mae} increase for all models up until stop 50, after which point only few routes have that many stops, so there is increased variability between consecutive stops. As before, \Fnorm{} shows much higher errors than the other three methods, and \Fpf{} shows slightly better prediction accuracy than \Fhist{} and \Fsched{} up until about stop 30, at which point there is no clear difference between these three methods. However, in terms of relative error (\gls{mape}), \Fpf{} outperforms all the others over all stops, while \Fhist{} shows the poorest accuracy particularly for early stops.


The \gls{picp} show much the same trend as before, again not unexpected due to the relationship between stop sequence and time until arrival. \Fpf{} underestimates uncertainty at all stops, while \Fnorm{} overestimates for all but the first few stops---it performs quite poorly for those. \Fhist{} has the desired coverage for all stops.



\subsubsection{Time of day}

We grouped observations into 15~minute intervals over the day and calculated the summary statistics for each prediction method. The results, displayed in \cref{fig:model_results_rmse_timeofday}, differ quite significantly from those seen previously, as we now see a strong peak-hour effect: in the morning there is a single peak (school and work begin at about the same time) at around 8~am, whereas in the evening there are two smaller peaks: one for schools at about 3~pm, and another for workers at around 5~pm.


<<model_results_rmse_timeofday,warning=FALSE,echo=FALSE,cache=TRUE,dependson=c("model_results_load","model_colours"),cache.lazy=FALSE,fig.width=8,fig.height=4,out.width="\\textwidth",fig.cap="Model comparative statistics as a function of time of day.">>=
res_timeofday <- eta_results %>%
    mutate(
        hour = timestamp %>% format("%H") %>% as.integer,
        minute = timestamp %>% format("%M") %>% as.integer,
        hour = hour + (floor(minute / 15) * 15 / 60)
    ) %>%
    filter(time_until_arrival > 0) %>%
    group_by(hour) %>%
    summarize(
        pf_rmse = sqrt(mean(pf_error^2)),
        pf_mae = mean(abs(pf_error)),
        pf_mape = mean(abs(pf_error / time_until_arrival)),
        pf_ci_cov = mean(pf_ci),
        pf_ci_width = mean(pf_upper - pf_lower),
        pf_ci_lower = quantile(pf_upper - pf_lower, 0.025),
        pf_ci_upper = quantile(pf_upper - pf_lower, 0.975),
        normal_rmse = sqrt(mean(normal_error^2)),
        normal_mae = mean(abs(normal_error)),
        normal_mape = mean(abs(normal_error / time_until_arrival)),
        normal_ci_cov = mean(normal_ci),
        normal_ci_width = mean(normal_upper - normal_lower),
        normal_ci_lower = quantile(normal_upper - normal_lower, 0.025),
        normal_ci_upper = quantile(normal_upper - normal_lower, 0.975),
        hist_rmse = sqrt(mean(hist_error^2, na.rm = TRUE)),
        hist_mae = mean(abs(hist_error), na.rm = TRUE),
        hist_mape = mean(abs(hist_error / time_until_arrival), na.rm = TRUE),
        hist_ci_cov = mean(hist_ci, na.rm = TRUE),
        hist_ci_width = mean(historical_upper - historical_lower, na.rm = TRUE),
        hist_ci_lower = quantile(historical_upper - historical_lower, 0.025, na.rm = TRUE),
        hist_ci_upper = quantile(historical_upper - historical_lower, 0.975, na.rm = TRUE),
        gtfs_rmse = sqrt(mean(gtfs_error^2)),
        gtfs_mae = mean(abs(gtfs_error)),
        gtfs_mape = mean(abs(gtfs_error / time_until_arrival))
    ) %>% arrange(hour)


plot_base <- ggplot(res_timeofday, aes(hour)) +
    theme_classic() +
    theme(legend.position = "none") +
    scale_colour_manual(values = pal, name = "model") +
    xlab("Time of day (hour)")

plot_rmse <- plot_base +
    geom_path(aes(y = pf_rmse, colour = "pf")) +
    geom_path(aes(y = normal_rmse, colour = "normal")) +
    geom_path(aes(y = hist_rmse, colour = "historical")) +
    geom_path(aes(y = gtfs_rmse, colour = "gtfs")) +
    scale_y_continuous(
        "RMSE (s)",
        trans = "log10"
    ) +
    theme(legend.position = "bottom")

plot_mae <- plot_base +
    geom_path(aes(y = pf_mae, colour = "pf")) +
    geom_path(aes(y = normal_mae, colour = "normal")) +
    geom_path(aes(y = hist_mae, colour = "historical")) +
    geom_path(aes(y = gtfs_mae, colour = "gtfs")) +
    scale_y_continuous(
        "MAE (s)",
        trans = "log10"
    )

plot_mape <- plot_base +
    geom_path(aes(y = 100 * pf_mape, colour = "pf")) +
    geom_path(aes(y = 100 * normal_mape, colour = "normal")) +
    geom_path(aes(y = 100 * hist_mape, colour = "historical")) +
    geom_path(aes(y = 100 * gtfs_mape, colour = "gtfs")) +
    scale_y_continuous(
        "MAPE (%)",
        trans = "log10"
    )

plot_ci <- plot_base +
    geom_hline(aes(yintercept = 85), lty = 2) +
    geom_path(aes(y = 100 * pf_ci_cov, colour = "pf")) +
    geom_path(aes(y = 100 * normal_ci_cov, colour = "normal")) +
    geom_path(aes(y = 100 * hist_ci_cov, colour = "historical")) +
    scale_y_continuous(
        name = "PICP (%)"
    )

plot_width <- plot_base +
    geom_ribbon(
        aes(
            ymin = pmax(0, pf_ci_lower),
            ymax = pmin(60 * 60, pf_ci_upper),
            fill = "pf"
        ),
        alpha = 0.2
    ) +
    geom_ribbon(
        aes(
            ymin = pmax(0, normal_ci_lower),
            ymax = pmin(60 * 60, normal_ci_upper),
            fill = "normal"
        ),
        alpha = 0.2
    ) +
    geom_ribbon(
        aes(
            ymin = pmax(0, hist_ci_lower),
            ymax = pmin(60 * 60, hist_ci_upper),
            fill = "historical"
        ),
        alpha = 0.2
    ) +
    geom_path(aes(y = pf_ci_width, colour = "pf")) +
    geom_path(aes(y = normal_ci_width, colour = "normal")) +
    geom_path(aes(y = hist_ci_width, colour = "historical")) +
    scale_y_continuous(
        name = "PPI width (m)",
        breaks = function(x) pretty(x / 60) * 60,
        labels = function(x) x / 60,
        limits = c(0, 60) * 60
    ) +
    scale_fill_manual(values = pal, name = "model")

library(patchwork)

plot_rmse + plot_mae +
    plot_mape + plot_ci +
    guide_area() +
    plot_layout(
        guides = "collect",
        design = "
            13
            24
            55
        ",
        heights = c(1, 1, 0.1)
    )
@

During off-peak (that is, between about 9:30~am and 2:30~pm) \Fpf{} shows the smallest absolute error (\gls{rmse} and \gls{mae}), with \Fhist{} and \Fsched{} showing slightly larger errors. Again, \Fnorm{} shows much poorer accuracy (again, note the log scale). During peak times, all methods show an increase in prediction error as traffic conditions worsen and become more unreliable. \Fsched{} is least affected by this effect since the schedules take, to some extent, peak congestion into account, while the current implementation of our method only uses the \emph{current} traffic state; however, as discussed in \cref{sec:nw_hist_model}, improvements should be possible once a better forecasting method has been implemented.

In terms of relative error (\gls{mape}), we still see the peak effect, but it is much less accentuated, and now \Fpf{} demonstrates the best accuracy throughout the day. This would indicate that much of the absolute error comes from longer-term predictions (when the bus is far away), when traffic has more opportunity to get better or worse: all commuters will be all too familar with how quickly congestion can build. \gls{mape} for \Fsced{} and \Fhist{} show little effect at all of peak hour.


Finally, we look to \gls{picp}, where we can truly see the effect of peak traffic on arrival time predictions, particularly those made using our particle filter. During off-peak, \Fpf{} has very close to the desired coverage of 85\%; during peak time, however, coverage drops quite significantly. This will be due to travel times increasing quickly as congestion builds, meaning initial predictions are too early, and then travel times decreasing again once peak time has passed, and predictions made will be too late. This indicates that, while our \pf{} seems to be able to accurately estimate travel times, it would benefit from the forecasting improvement\footnote{Which we were, unfortunately, unable to complete at this time.}.




\subsection{Assessing the reliability of arrival time prediction}
\label{sec:prediction_model_comp_probs}

\Gls{rmse}, \gls{mae}, and \gls{mape} measure the predictive accuracy of the methods, but do not account for the costs associated with inaccurate predictions. In this section, we evaluate the \emph{reliability} of arrival time distributions by examining
\begin{enumerate}
\item the wait time at the bus stop, and
\item the probability of missing the target bus.
\end{enumerate}
In most cases, the latter incurs a much greater cost, but depends entirely on time until the \emph{next} bus arrival: for high-frequency routes, this will be small; for low-frequency ones, however, it can become quite high\footnote{Some routes only run hourly!}. In this section, we do not differentiate between high and low-frequency routes (we do in \cref{sec:eta_estimates}, however).


The three statistics we compare across the methods are:
\begin{itemize}
\item $\mathbb{P}_m = \Pr{\Varr_m \geq \hat\Tarr_m}$, the probability that the vehicle arrives after the point estimate, $\hat\Tarr_m$, indicating that were a passenger to arrive at the stop by $\hat\Tarr_m$, they would catch the bus with probability $\mathbb{P}_m$;
\item $\mathbb{P}_\ell = \Pr{\Varr_m \geq \hat\alpha_{m,\text{lower}}}$, the probability that the vehicles arrives after the lower bound of the \gls{ppi}; and
\item $\mathbb{E}_\ell = \E{\Varr_m - \hat\alpha_{m,\text{lower}} | \Varr_m \geq \hat\alpha_{m,\text{lower}}}$, the expected waiting time for a passenger arriving at the lower predictive bound, given that the bus arrives after it (that is, conditional on catching the bus).
\end{itemize}


<<model_results_pr_miss,echo=FALSE,message=FALSE,warning=FALSE,cache=TRUE,dependson=c("model_results_load","model_colours"),cache.lazy=FALSE>>=
pr_smry <- eta_results %>%
    mutate(
        # bus arrives after point estimate
        pf_catch = as.integer(time_until_arrival > pf_mean),
        normal_catch = as.integer(time_until_arrival > normal_mean),
        hist_catch = as.integer(time_until_arrival > historical_mean),
        gtfs_catch = as.integer(time_until_arrival > gtfs_eta),
        # bus arrives after lower bound
        pf_lower_catch = as.integer(time_until_arrival > pf_lower),
        normal_lower_catch = as.integer(time_until_arrival > normal_lower),
        hist_lower_catch = as.integer(time_until_arrival > historical_lower),
        # expected wait time | arrive at lower bound & don't miss bus
        pf_wait = ifelse(pf_lower_catch, time_until_arrival - pf_lower, NA),
        normal_wait = ifelse(normal_lower_catch, time_until_arrival - normal_lower, NA),
        hist_wait = ifelse(hist_lower_catch, time_until_arrival - historical_lower, NA),
    ) %>%
    summarize(
        pf_catch = mean(pf_catch),
        normal_catch = mean(normal_catch),
        hist_catch = mean(hist_catch, na.rm = TRUE),
        gtfs_catch = mean(gtfs_catch),
        pf_lower_catch = mean(pf_lower_catch),
        normal_lower_catch = mean(normal_lower_catch),
        hist_lower_catch = mean(hist_lower_catch, na.rm = TRUE),
        pf_wait_lower = quantile(pf_wait, 0.05, na.rm = TRUE),
        pf_wait_upper = quantile(pf_wait, 0.9, na.rm = TRUE),
        normal_wait_lower = quantile(normal_wait, 0.05, na.rm = TRUE),
        normal_wait_upper = quantile(normal_wait, 0.9, na.rm = TRUE),
        hist_wait_lower = quantile(hist_wait, 0.05, na.rm = TRUE),
        hist_wait_upper = quantile(hist_wait, 0.9, na.rm = TRUE),
        pf_wait = mean(pf_wait, na.rm = TRUE),
        normal_wait = mean(normal_wait, na.rm = TRUE),
        hist_wait = mean(hist_wait, na.rm = TRUE)
    )
pr_mat <- with(pr_smry,
    data.frame(
        pr_catch =
            round(100 * c(pf_catch, normal_catch, hist_catch, gtfs_catch)),
        pr_lower_catch =
            round(100 *
                c(pf_lower_catch, normal_lower_catch, hist_lower_catch, NA)
            ),
        exp_wait =
            round(c(pf_wait, normal_wait, hist_wait, NA) / 60, 1),
        exp_ci = c(
            glue::glue("{round(pf_wait_lower/60, 1)}--{round(pf_wait_upper/60, 1)}"),
            glue::glue("{round(normal_wait_lower/60, 1)}--{round(normal_wait_upper/60, 1)}"),
            glue::glue("{round(hist_wait_lower/60, 1)}--{round(hist_wait_upper/60, 1)}"),
            NA
        )
    )
)

options(knitr.kable.NA = "")
row.names(pr_mat) <- paste0(
    "\\F", c("pf", "norm", "hist", "sched"), "{}: ",
    c(
        "Particle filter",
        "Normal approximation",
        "Historical delays",
        "Schedule-delay"
    )
)
names(pr_mat) <- c(
    "$\\mathbb{P}_m$ (\\%)",
    "$\\mathbb{P}_\\ell$ (\\%)",
    "$\\mathbb{E}_\\ell$ (m)",
    "5--90\\% CI"
)
knitr::kable(
    pr_mat,
    booktabs = TRUE,
    caption = "The probability of catching a bus given a passenger arrives by the mean/median ($\\mathbb{P}_m$) and lower quantile ($\\mathbb{P}_\\ell$), along with the expected waiting time, in minutes, given arrival by the lower quantile, for each of the for forecast methods.",
    escape = FALSE
) %>%
    kableExtra::kable_styling(font_size = 8)
@



The overall results are displayed in \cref{tab:model_results_pr_miss}. If a passenger, at any time, looks at the \gls{eta} of their bus \emph{once} and arrives at the stop by the indicated time, then using \Fpf{} their probability of catching the bus is almost double that of using \Fsched{}. Using \Fhist{}, then (not surprisingly) $\mathbb{P}_m$ is about 50\%; \Fnorm{} is over 95\% which indicates that it is underestimating arrival times.



The concept behind examining the accuracy of the lower quantile, $\mathbb{P}_\ell$, is that this value should give passengers the best chance of catching the bus. We used the 2.5\% quantile for the lower estimate, so we would expect the bus to arrive after the predicted time 97.5\% of the time. This is the case for \Fnorm{} and \Fhist{}, but \Fpf{} has a slightly lower probability that expected. Associated with the lower bound is the expected wait time until the bus actually arrives, conditional on not having missed it ($\mathbb{E}_\ell$). \Fpf{} has the shortest expected wait followed closly by \Fhist{}, while the wait time using \Fnorm{} is about four times as long as with \Fpf{}.



Since \Fsched{} provides only a point estimate, we cannot compare it directly to the other methods, in particular \Fpf{}. To do so, we can \emph{indirectly} compare these methods by proposing a passenger arrives $x$~minutes before the stated arrival time (by \Fsched{}) and calculating the probability of capture and expected wait time. The resulting curves are shown for a range of times (arriving 4--12~minutes before the stated arrival) in \cref{fig:model_results_pr_gtfs}, with the values for the other three methods overlaid with dashed lines.



<<model_results_pr_gtfs,echo=FALSE,message=FALSE,warning=FALSE,cache=TRUE,dependson=c("model_results_load","model_results_pr_miss"),cache.lazy=FALSE,fig.width=8,fig.height=3,out.width="\\textwidth",fig.align="center",fig.cap="GTFS equivalent">>=
# the equivalent values for GTFS
ers <- eta_results %>% select(timestamp, stop_sequence, time_until_arrival, gtfs_eta)
smrys <- do.call(rbind,
    lapply(4:12, function(mins) {
        ers %>%
            mutate(
                gtfs_catch = as.integer(time_until_arrival > gtfs_eta - mins * 60),
                gtfs_wait = ifelse(gtfs_catch, time_until_arrival - gtfs_eta + mins * 60, NA)
            ) %>%
            summarize(
                gtfs_catch = mean(gtfs_catch, na.rm = TRUE),
                gtfs_wait = mean(gtfs_wait, na.rm = TRUE)
            ) %>%
            mutate(min_before = mins)
    })
)

plot_base <- ggplot(smrys, aes(min_before)) +
    theme_classic(base_family = "Helvetica") +
    scale_colour_manual(values = pal, name = "model") +
    scale_x_continuous(
        name = "Time before GTFS ETA (minutes)",
        breaks = seq(4, 12, by = 2)
    )

plotA <- plot_base +
    geom_hline(
        aes(yintercept = 100 * pr_smry$pf_lower_catch, colour = "pf"),
        lty = 2
    ) +
    geom_hline(
        aes(yintercept = 100 * pr_smry$normal_lower_catch, colour = "normal"),
        lty = 2
    ) +
    geom_hline(
        aes(yintercept = 100 * pr_smry$hist_lower_catch, colour = "historical"),
        lty = 2
    ) +
    geom_path(aes(y = 100 * gtfs_catch, colour = "gtfs")) +
    #ylab(expression("\u2119"["\u2113"]~"(%)"))
    ylab(expression(P["\u2113"]~"(%)"))

plotB <- plot_base +
    geom_hline(aes(yintercept = pr_smry$pf_wait / 60, colour = "pf"), lty = 2) +
    geom_hline(aes(yintercept = 10 * NA, colour = "normal"), lty = 2) +
    geom_hline(aes(yintercept = pr_smry$hist_wait / 60, colour = "historical"), lty = 2) +
    geom_path(aes(y = gtfs_wait / 60, colour = "gtfs")) +
    ylab(expression(E["\u2113"]~"(%)"))

library(patchwork)
plotA + plotB + plot_layout(guides = "collect") &
    theme(legend.position = "bottom")

@



First let us consider the probability of the bus arriving after the estimated arrival time, $\mathbb{P}_\ell$. Based on the data collected, a passenger would need to arrive at least 10~minutes before the stated \gls{eta} (by \Fsched{}) to have a 97.5\% probability of catching the bus. To obtain the same probability as \Fpf{}, this would be 6~minutes before arrival. Now we can compare the expected waiting time: to achieve the targetted 97.5\% chance of catching the bus, the passenger would arrive 10 minutes before the stated \gls{eta}, which has an expected waiting time of about 9~minutes. Or, arriving 6~minutes before, the expected wait time drops to almost 6~minutes, which is greater than the expected wait time under \Fpf{} of just over 4~minutes.


We could also examine this the opposite way, and match the expected waiting time with that of \Fpf{}. In this case, a passenger would need to arrive no more than 4~minutes before the stated arrival time, which would give them an 85\% chance of catching the bus. For the remainder of this section, we use 6~minutes before the specified \gls{eta} to obtain a lower bound for \Fsched{}, and compare the probabilities as a function of time until arrival, stop sequence, and time of day.



\subsubsection{Time until arrival}

\Cref{fig:model_results_pr_time} shows $\mathbb{P}_m$, $\mathbb{P}_\ell$, and $\mathbb{E}_\ell$ computed for one-minute intervals for each of the four methods. For \Fsched{}, we used a lower bound of 6~minutes before the predicted arrival. For the expected wait time, we also computed the 5\% and 90\% quantiles, which are displayed as shaded regions. The dotted line in the expected waiting time graph represents the maximum possible waiting time; that is, when the bus is 10~minutes and you arrive immediately at the stop, you will wait 10~minutes.


<<model_results_pr_time,echo=FALSE,message=FALSE,warning=FALSE,cache=TRUE,dependson=c("model_results_load","model_results_pr_miss"),cache.lazy=FALSE,fig.width=8,fig.height=4,out.width="\\textwidth",fig.cap="Summary values by time until arrival.">>=
pr_smry_time <- eta_results %>%
    mutate(
        # bus arrives after point estimate
        pf_catch = as.integer(time_until_arrival > pf_mean),
        normal_catch = as.integer(time_until_arrival > normal_mean),
        hist_catch = as.integer(time_until_arrival > historical_mean),
        gtfs_catch = as.integer(time_until_arrival > gtfs_eta),
        # bus arrives after lower bound
        pf_lower_catch = as.integer(time_until_arrival > pf_lower),
        normal_lower_catch = as.integer(time_until_arrival > normal_lower),
        hist_lower_catch = as.integer(time_until_arrival > historical_lower),
        gtfs_lower_catch = as.integer(time_until_arrival > gtfs_eta - 8 * 60),
        # expected wait time | arrive at lower bound & don't miss bus
        pf_wait = ifelse(pf_lower_catch, time_until_arrival - pf_lower, NA),
        normal_wait = ifelse(normal_lower_catch, time_until_arrival - normal_lower, NA),
        hist_wait = ifelse(hist_lower_catch, time_until_arrival - historical_lower, NA),
        gtfs_wait = ifelse(gtfs_lower_catch, time_until_arrival - gtfs_eta + 8 * 60, NA),
        min = time_until_arrival %/% 60
    ) %>%
    group_by(min) %>%
    summarize(
        pf_catch = mean(pf_catch),
        normal_catch = mean(normal_catch),
        hist_catch = mean(hist_catch, na.rm = TRUE),
        gtfs_catch = mean(gtfs_catch),
        pf_lower_catch = mean(pf_lower_catch),
        normal_lower_catch = mean(normal_lower_catch),
        hist_lower_catch = mean(hist_lower_catch, na.rm = TRUE),
        gtfs_lower_catch = mean(gtfs_lower_catch, na.rm = TRUE),
        pf_wait_lower = quantile(pf_wait, 0.05, na.rm = TRUE),
        pf_wait_upper = quantile(pf_wait, 0.9, na.rm = TRUE),
        normal_wait_lower = quantile(normal_wait, 0.05, na.rm = TRUE),
        normal_wait_upper = quantile(normal_wait, 0.9, na.rm = TRUE),
        hist_wait_lower = quantile(hist_wait, 0.05, na.rm = TRUE),
        hist_wait_upper = quantile(hist_wait, 0.9, na.rm = TRUE),
        gtfs_wait_lower = quantile(gtfs_wait, 0.05, na.rm = TRUE),
        gtfs_wait_upper = quantile(gtfs_wait, 0.9, na.rm = TRUE),
        pf_wait = mean(pf_wait, na.rm = TRUE),
        normal_wait = mean(normal_wait, na.rm = TRUE),
        hist_wait = mean(hist_wait, na.rm = TRUE),
        gtfs_wait = mean(gtfs_wait, na.rm = TRUE)
    ) %>%
    filter(min < 40 & min > 0) %>% arrange(min)


plot_base <- ggplot(pr_smry_time, aes(min)) +
    theme_classic() +
    scale_colour_manual(values = pal, name = "model") +
    xlab("Time until arrival (minutes)")

plotA <- plot_base +
    #geom_hline(yintercept = 0.5, lty = 2) +
    geom_path(aes(y = pf_catch, colour = "pf")) +
    geom_path(aes(y = normal_catch, colour = "normal")) +
    geom_path(aes(y = hist_catch, colour = "historical")) +
    geom_path(aes(y = gtfs_catch, colour = "gtfs")) +
    ylab("P[m]")

plotB <- plot_base +
    #geom_hline(yintercept = 0.975, lty = 2) +
    geom_path(aes(y = pf_lower_catch, colour = "pf")) +
    geom_path(aes(y = normal_lower_catch, colour = "normal")) +
    geom_path(aes(y = hist_lower_catch, colour = "historical")) +
    geom_path(aes(y = gtfs_lower_catch, colour = "gtfs")) +
    ylab("P[l]")

plotC <- plot_base +
    #geom_abline(lty = 3) +
    geom_ribbon(
        aes(
            ymin = pmin(30, pmin(min, pf_wait_lower / 60)),
            ymax = pmin(30, pmin(min, pf_wait_upper / 60)),
            fill = "pf"
        ),
        alpha = 0.2
    ) +
    geom_ribbon(
        aes(
            ymin = pmin(30, pmin(min, normal_wait_lower / 60)),
            ymax = pmin(30, pmin(min, normal_wait_upper / 60)),
            fill = "normal"
        ),
        alpha = 0.2
    ) +
    geom_ribbon(
        aes(
            ymin = pmin(30, pmin(min, hist_wait_lower / 60)),
            ymax = pmin(30, pmin(min, hist_wait_upper / 60)),
            fill = "historical"
        ),
        alpha = 0.2
    ) +
    geom_ribbon(
        aes(
            ymin = pmin(30, pmin(min, gtfs_wait_lower / 60)),
            ymax = pmin(30, pmin(min, gtfs_wait_upper / 60)),
            fill = "gtfs"
        ),
        alpha = 0.2
    ) +
    geom_path(aes(y = pmin(min, pf_wait / 60), colour = "pf")) +
    geom_path(aes(y = pmin(min, normal_wait / 60), colour = "normal")) +
    geom_path(aes(y = pmin(min, hist_wait / 60), colour = "historical")) +
    geom_path(aes(y = pmin(min, gtfs_wait / 60), colour = "gtfs")) +
    scale_y_continuous(
        "E[l] (m)",
        limits = c(0, 30)
    ) +
    theme(legend.position = "none") +
    scale_fill_manual(values = pal, name = "model", guide = FALSE)

library(patchwork)
plotA + plotB + plotC + guide_area() +
    plot_layout(
        guides = "collect",
        design = "
            13
            24
        ",
        heights = c(1, 1)
    )
@



The probability that the bus arrives after the point estimate (mean or median), $\mathbb{P}_\ell$ is more or less constant with a slight decrease as the bus nears the stop. \Fpf{} and \Fnorm{} are above the expected value of 50\%, though the latter is significantly higher. \Fnorm{} performs reasonably well, though tends to underestimate arrival time the farther out the bus is, while \Fsched{} overestimates arrival time quite such that there is less than a 40\% chance of catching the bus if it is less than 20~minutes away.


As for $\mathbb{P}_\ell$, we see a different trend: \Fpf{} and \Fhist{} increase the further out the vehicle is; on the other hand with \Fsched{}, the probability decreases, although this is because we have chosen a fixed lower bound. Once the bus is about 15~minutes away, the \gls{eta} provided by \Fsched{} minus 6~minutes is increasingly likely to result in a caught bus, while under \Fpf{} this probability is lower, indicating not enough uncertainty is accounted for over short distances (though the difference is only a few percent).


Finally, we look at the expected waiting time, given a passenger arrives at the lower bound \emph{and} the bus arrives after it. \Fpf{} has a consistently shorter waiting time, though by about 30~minutes out the three methods (excluding \Fnorm{}) are approximately the same. We can see that the expected waiting time for \Fsched{} is more or less independent of time until arrival, which is to be expected since the width is fixed. The shaded reasons represent the 5\% and 90\% quantiles of waiting time, and we see that \Fpf{} results in shorter waits, on average, for 10~minutes before arrival. As for the normal approximation, it tends towards overestimation of arrival time uncertainty, so expected waiting time is very large if arriving at the lower estimate, indicating that \Fnorm{} is not a reliable choice of predictor.



\subsubsection{Stop sequence}

The same values were computed by stop sequence, and displayed in \cref{fig:model_results_pr_stop}. Again, \Fhist{} achieves the target probability of 50\%, whilc \Fpf{} is slightly above at about 60\%. Most notable is the steady decline in the reliability of \Fsched{}, which after stop 40 drops to about a one in three chance of catching the bus (assuming you arrive at the predicted \gls{eta}).



<<model_results_pr_stop,echo=FALSE,message=FALSE,warning=FALSE,cache=TRUE,dependson=c("model_results_load","model_results_pr_miss"),cache.lazy=FALSE,fig.width=8,fig.height=4,out.width="\\textwidth",fig.cap="Summary values by stop sequence.">>=
pr_smry_stop <- eta_results %>%
    mutate(
        # bus arrives after point estimate
        pf_catch = as.integer(time_until_arrival > pf_mean),
        normal_catch = as.integer(time_until_arrival > normal_mean),
        hist_catch = as.integer(time_until_arrival > historical_mean),
        gtfs_catch = as.integer(time_until_arrival > gtfs_eta),
        # bus arrives after lower bound
        pf_lower_catch = as.integer(time_until_arrival > pf_lower),
        normal_lower_catch = as.integer(time_until_arrival > normal_lower),
        hist_lower_catch = as.integer(time_until_arrival > historical_lower),
        gtfs_lower_catch = as.integer(time_until_arrival > gtfs_eta - 8 * 60),
        # expected wait time | arrive at lower bound & don't miss bus
        pf_wait = ifelse(pf_lower_catch, time_until_arrival - pf_lower, NA),
        normal_wait = ifelse(normal_lower_catch, time_until_arrival - normal_lower, NA),
        hist_wait = ifelse(hist_lower_catch, time_until_arrival - historical_lower, NA),
        gtfs_wait = ifelse(gtfs_lower_catch, time_until_arrival - gtfs_eta + 8 * 60, NA),
        min = time_until_arrival %/% 60
    ) %>%
    group_by(stop_sequence) %>%
    summarize(
        pf_catch = mean(pf_catch),
        normal_catch = mean(normal_catch),
        hist_catch = mean(hist_catch, na.rm = TRUE),
        gtfs_catch = mean(gtfs_catch),
        pf_lower_catch = mean(pf_lower_catch),
        normal_lower_catch = mean(normal_lower_catch),
        hist_lower_catch = mean(hist_lower_catch, na.rm = TRUE),
        gtfs_lower_catch = mean(gtfs_lower_catch, na.rm = TRUE),
        pf_wait_lower = quantile(pf_wait, 0.05, na.rm = TRUE),
        pf_wait_upper = quantile(pf_wait, 0.9, na.rm = TRUE),
        normal_wait_lower = quantile(normal_wait, 0.05, na.rm = TRUE),
        normal_wait_upper = quantile(normal_wait, 0.9, na.rm = TRUE),
        hist_wait_lower = quantile(hist_wait, 0.05, na.rm = TRUE),
        hist_wait_upper = quantile(hist_wait, 0.9, na.rm = TRUE),
        gtfs_wait_lower = quantile(gtfs_wait, 0.05, na.rm = TRUE),
        gtfs_wait_upper = quantile(gtfs_wait, 0.9, na.rm = TRUE),
        pf_wait = mean(pf_wait, na.rm = TRUE),
        normal_wait = mean(normal_wait, na.rm = TRUE),
        hist_wait = mean(hist_wait, na.rm = TRUE),
        gtfs_wait = mean(gtfs_wait, na.rm = TRUE)
    ) %>%
    filter(stop_sequence <= 60) %>%
    arrange(stop_sequence)


plot_base <- ggplot(pr_smry_stop, aes(stop_sequence)) +
    theme_classic() +
    scale_colour_manual(values = pal, name = "model") +
    xlab("Stop sequence")

plotA <- plot_base +
    geom_path(aes(y = pf_catch, colour = "pf")) +
    geom_path(aes(y = normal_catch, colour = "normal")) +
    geom_path(aes(y = hist_catch, colour = "historical")) +
    geom_path(aes(y = gtfs_catch, colour = "gtfs")) +
    ylab("P[m]")

plotB <- plot_base +
    geom_path(aes(y = pf_lower_catch, colour = "pf")) +
    geom_path(aes(y = normal_lower_catch, colour = "normal")) +
    geom_path(aes(y = hist_lower_catch, colour = "historical")) +
    geom_path(aes(y = gtfs_lower_catch, colour = "gtfs")) +
    ylab("P[l]")

plotC <- plot_base +
    geom_ribbon(
        aes(
            ymin = pmin(30, pf_wait_lower / 60),
            ymax = pmin(30, pf_wait_upper / 60),
            fill = "pf"
        ),
        alpha = 0.2
    ) +
    geom_ribbon(
        aes(
            ymin = pmin(30, normal_wait_lower / 60),
            ymax = pmin(30, normal_wait_upper / 60),
            fill = "normal"
        ),
        alpha = 0.2
    ) +
    geom_ribbon(
        aes(
            ymin = pmin(30, hist_wait_lower / 60),
            ymax = pmin(30, hist_wait_upper / 60),
            fill = "historical"
        ),
        alpha = 0.2
    ) +
    geom_ribbon(
        aes(
            ymin = pmin(30, gtfs_wait_lower / 60),
            ymax = pmin(30, gtfs_wait_upper / 60),
            fill = "gtfs"
        ),
        alpha = 0.2
    ) +
    geom_path(aes(y = pf_wait / 60, colour = "pf")) +
    geom_path(aes(y = normal_wait / 60, colour = "normal")) +
    geom_path(aes(y = hist_wait / 60, colour = "historical")) +
    geom_path(aes(y = gtfs_wait / 60, colour = "gtfs")) +
    ylab("E[l] (m)") + ylim(0, 30) +
    theme(legend.position = "none") +
    scale_fill_manual(values = pal, name = "model")

library(patchwork)
plotA + plotB + plotC + guide_area() +
    plot_layout(
        guides = "collect",
        design = "
            13
            24
        ",
        heights = c(1, 1)
    )
@


Moving on to the lower 2.5\% quantile, $\mathbb{P}_\ell$, we expect 97.5\% probabiltiy of capture. We see that, as before, \Fpf{} overestimates arrival time slightly, at about 90\%, while \Fsched{} decreases (again) with stop sequence; but remember the lower bound was fixed at 6~minutes before the predicted \gls{eta}. The associated wait time, $\mathbb{E}_\ell$, increases for all methods with increasing stop sequence \emph{except} for \Fsched{}, which decreases (again, the width is fixed). \Fpf{} has the lowest expected wait time up until about stop 50, and again the upper 90\% interval is lower than the mean for \Fsched{} for the first 20~stops. However, many stops with low indices will be serviced within the first 5--10~minutes of the trip, thus inflating $\mathbb{P}_\ell$ under \Fsched{}.



\subsubsection{Time of day}

The probabilities and expected waiting time were calculated for 15~minute intervals over the day for each of the models, as is shown in \cref{fig:model_results_pr_timeofday}. The peak hour effects are again visible, associated with an increased probability of arriving before the bus does under \Fpf{} for both the median and lower 2.5\% quantile, while for \Fsched{} the probability of arriving before the bus does decreases slightly. In the evening we see the performance of \Fpf{} drops rapidly, which likely indicates that the probability of stopping is much reduced (many evening services have low occupancy, and as such are less likely to stop at each stop). Future work targetting more complicated dwell time models could help to correct this, however.


<<model_results_pr_timeofday,echo=FALSE,message=FALSE,warning=FALSE,cache=TRUE,dependson=c("model_results_load","model_results_pr_miss"),cache.lazy=FALSE,fig.width=8,fig.height=4.5,out.width="\\textwidth",fig.cap="Summary values by time of day.">>=
pr_smry_timeofday <- eta_results %>%
    mutate(
        # bus arrives after point estimate
        pf_catch = as.integer(time_until_arrival > pf_mean),
        normal_catch = as.integer(time_until_arrival > normal_mean),
        hist_catch = as.integer(time_until_arrival > historical_mean),
        gtfs_catch = as.integer(time_until_arrival > gtfs_eta),
        # bus arrives after lower bound
        pf_lower_catch = as.integer(time_until_arrival > pf_lower),
        normal_lower_catch = as.integer(time_until_arrival > normal_lower),
        hist_lower_catch = as.integer(time_until_arrival > historical_lower),
        gtfs_lower_catch = as.integer(time_until_arrival > gtfs_eta - 8 * 60),
        # expected wait time | arrive at lower bound & don't miss bus
        pf_wait = ifelse(pf_lower_catch, time_until_arrival - pf_lower, NA),
        normal_wait = ifelse(normal_lower_catch, time_until_arrival - normal_lower, NA),
        hist_wait = ifelse(hist_lower_catch, time_until_arrival - historical_lower, NA),
        gtfs_wait = ifelse(gtfs_lower_catch, time_until_arrival - gtfs_eta + 8 * 60, NA),
        hour = timestamp %>% format("%H") %>% as.integer,
        minute = timestamp %>% format("%M") %>% as.integer,
        hour = hour + (floor(minute / 15) * 15 / 60)
    ) %>%
    group_by(hour) %>%
    summarize(
        pf_catch = mean(pf_catch),
        normal_catch = mean(normal_catch),
        hist_catch = mean(hist_catch, na.rm = TRUE),
        gtfs_catch = mean(gtfs_catch),
        pf_lower_catch = mean(pf_lower_catch),
        normal_lower_catch = mean(normal_lower_catch),
        hist_lower_catch = mean(hist_lower_catch, na.rm = TRUE),
        gtfs_lower_catch = mean(gtfs_lower_catch, na.rm = TRUE),
        pf_wait_lower = quantile(pf_wait, 0.05, na.rm = TRUE),
        pf_wait_upper = quantile(pf_wait, 0.9, na.rm = TRUE),
        normal_wait_lower = quantile(normal_wait, 0.05, na.rm = TRUE),
        normal_wait_upper = quantile(normal_wait, 0.9, na.rm = TRUE),
        hist_wait_lower = quantile(hist_wait, 0.05, na.rm = TRUE),
        hist_wait_upper = quantile(hist_wait, 0.9, na.rm = TRUE),
        gtfs_wait_lower = quantile(gtfs_wait, 0.05, na.rm = TRUE),
        gtfs_wait_upper = quantile(gtfs_wait, 0.9, na.rm = TRUE),
        pf_wait = mean(pf_wait, na.rm = TRUE),
        normal_wait = mean(normal_wait, na.rm = TRUE),
        hist_wait = mean(hist_wait, na.rm = TRUE),
        gtfs_wait = mean(gtfs_wait, na.rm = TRUE)
    ) %>%
    arrange(hour)


plot_base <- ggplot(pr_smry_timeofday, aes(hour)) +
    theme_classic() +
    scale_colour_manual(values = pal, name = "model") +
    xlab("Time of day")

plotA <- plot_base +
    geom_path(aes(y = pf_catch, colour = "pf")) +
    geom_path(aes(y = normal_catch, colour = "normal")) +
    geom_path(aes(y = hist_catch, colour = "historical")) +
    geom_path(aes(y = gtfs_catch, colour = "gtfs")) +
    ylab("P[m]")

plotB <- plot_base +
    geom_path(aes(y = pf_lower_catch, colour = "pf")) +
    geom_path(aes(y = normal_lower_catch, colour = "normal")) +
    geom_path(aes(y = hist_lower_catch, colour = "historical")) +
    geom_path(aes(y = gtfs_lower_catch, colour = "gtfs")) +
    ylab("P[l]")

plotC <- plot_base +
    geom_ribbon(
        aes(
            ymin = pmin(30, pf_wait_lower / 60),
            ymax = pmin(30, pf_wait_upper / 60),
            fill = "pf"
        ),
        alpha = 0.2
    ) +
    geom_ribbon(
        aes(
            ymin = pmin(30, normal_wait_lower / 60),
            ymax = pmin(30, normal_wait_upper / 60),
            fill = "normal"
        ),
        alpha = 0.2
    ) +
    geom_ribbon(
        aes(
            ymin = pmin(30, hist_wait_lower / 60),
            ymax = pmin(30, hist_wait_upper / 60),
            fill = "historical"
        ),
        alpha = 0.2
    ) +
    geom_ribbon(
        aes(
            ymin = pmin(30, gtfs_wait_lower / 60),
            ymax = pmin(30, gtfs_wait_upper / 60),
            fill = "gtfs"
        ),
        alpha = 0.2
    ) +
    geom_path(aes(y = pf_wait / 60, colour = "pf")) +
    geom_path(aes(y = normal_wait / 60, colour = "normal")) +
    geom_path(aes(y = hist_wait / 60, colour = "historical")) +
    geom_path(aes(y = gtfs_wait / 60, colour = "gtfs")) +
    ylab("E[l] (m)") + ylim(0, 30) +
    theme(legend.position = "none") +
    scale_fill_manual(values = pal, name = "model")

library(patchwork)
plotA + plotB + plotC + guide_area() +
    plot_layout(
        guides = "collect",
        design = "
            13
            24
        ",
        heights = c(1, 1)
    )
@


We see much the same pattern with the expected waiting time $\mathbb{E}_\ell$, in which wait times increase by a few minutes under \Fpf{}, while there is little noticable change for \Fsched{} and \Fhist{}. Even so, \Fpf{} consistently provides shorter expected wait times than \Fsched{}, and over most of the day (from about 7~am until 6~pm) the probability of the bus arriving after the lower estimate is above 90\%.
]


\subsection{Result summary}
\label{sec:prediction_model_comp_summary}

We have now seen that the particle filter suggests some improvement is possible over the schedule-delay method used by \AT. It tends to underestimate the arrival time, but even so, the expected waiting time is, in most situations, less than that of all of the other methods. Conversely, the normal approximation performed very poorly in this case, likely since summing uncertainties, and assuming independence, quickly results in an overestimation of uncertainty, and thus wide prediction intervals (not to mention high prediction error).

As for the other methods which do not use real-time network information, the historical data-based method performed as well as or better than the schedule-delay method, with a few situations where it did not perform so well. The average and variance of arrival delays were based on two weeks' worth of data, which is---at most---10 observations per trip. Processing more weeks of data could bring slight improvements, but without taking into account real-time data, it is unlikely to yield significant improvements. Post-processing is an intensive procedure, so future development could include real-time computation of the mean and variance of arrival time for each stop along each trip.
