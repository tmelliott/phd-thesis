\section{Comparing models}
\label{sec:prediction_model_comparison}


We now have four models to evaluate, two of which use the road network state, one uses historical data, and one only the current delay, the last being the method currently used by \gls{at}\footnote{And many other public transport providers using \gls{gtfs}-realtime}. To compare them, we implemented the first two in the application and, using a single day of data, run the program, storing all arrival time estimates, the uncertainty, as well as the 5\% and 90\% quantiles\footnote{Initially we used a symmetric 95\% prediction interval, but this was often highly skewed by a few very late particles.}. We could then use the actual (reported) arrival times to compute the accuracy of each estimator. For the historical data, we compare the mean with the actual arrival time. For the schedule-delay method, the arrival time for all upcoming stops was for each observation, and the prediction error computed.


The comparison criteria used is the \emph{\gls{rmse}}, as is commonly used for model checking \citep{cn}. \Gls{rmse} is the mean squared difference (in seconds) between the predicted and actual arrival times. Of course, since predictions change over time, we also compute \gls{rmse} by \emph{time until (actual) arrival}, allowing us to compare the models at different time points, as well as by stop sequence and time of day.


Another criteria we are interested in is the \emph{coverage of the prediction interval}, which is only available for our models. In each, we construct a 85\% credible prediction interval: for the particle filter, this is achieved by sorting the particles in order of arrival time, and then taking the $\lfloor q_\text{lower} N^\star\rfloor^{\text{th}}$ particle as the lower bound, and the $\lceil q_{\text{upper}} N^\star\rceil^{\text{th}}$ particle as the upper bound. For the 85\% interval, we used $q_\text{lower} = 0.05$ and $q_\text{upper} = 0.9$. For the normal approximation, the inverse \gls{cdf} gives us the required quantiles. Similarly, the historical mean and variance were used to obtain the quantiles for the historical-data method. The results are displayed in \cref{tab:...} and \cref{fig:...}.


<<model_colours,echo=FALSE,cache=TRUE>>=
pal <- RColorBrewer::brewer.pal(4, "Set1")
names(pal) <- c("pf", "normal", "historical", "gtfs")
options(knitr.kable.NA = '')
@

<<model_results_load,echo=FALSE,message=FALSE,warning=FALSE,cache=TRUE,cache.lazy=FALSE>>=
suppressPackageStartupMessages({
    library(tidyverse)
})


eta_files <- list.files("data", pattern = "eta_results.\\.rda", full.names = TRUE)
eta_results_all <-
    do.call(bind_rows,
        lapply(eta_files, function(f) {
            load(f)
            etai
        })
    ) %>% mutate(
        hist_error = historical_mean - time_until_arrival,
        hist_ci = as.integer(
            historical_lower <= time_until_arrival &
            time_until_arrival <= historical_upper
        )
    ) %>%
    ungroup()

# routes_to_keep <-
# c("1", "101", "105", "106", "110", "111", "112", "114", "120",
# "126", "131", "132", "133", "134", "138", "141", "142", "143",
# "146", "14T", "14W", "152", "154", "161", "162", "170", "172",
# "18", "186", "191", "195", "2", "20", "22A", "22N", "22R", "24B",
# "24R", "25B", "25L", "27H", "27T", "27W", "295", "298", "30",
# "309", "31", "313", "314", "32", "321", "323", "324", "325",
# "326", "33", "35", "351", "352", "353", "355", "361", "362",
# "365", "366", "371", "372", "373", "376", "377", "378", "380",
# "391", "392", "393", "650", "66", "670", "68", "711", "712",
# "714", "72C", "72M", "72X", "734", "735", "739", "743", "744",
# "747", "75", "751", "755", "762", "774", "781", "782", "783",
# "801", "814", "82", "83", "843", "845", "856", "861", "865",
# "871", "883", "884", "885", "889", "901", "906", "907", "917",
# "923", "924", "926", "928", "931", "933", "941", "942", "95B",
# "95C", "97B", "97R", "981", "982", "983", "985", "998", "CTY",
# "INN", "NX1", "NX2", "OUT", "SKY", "TMK")

eta_results <- eta_results_all #%>% filter(route_short_name %in% routes_to_keep)
@

<<model_results_rmse,echo=FALSE,message=FALSE,warning=FALSE,cache=TRUE,dependson=c("model_results_load","model_colours"),cache.lazy=FALSE>>=
mat <- eta_results %>%
    summarize(
        pf_rmse = sqrt(mean(pf_error^2)),
        pf_ci_cov = mean(pf_ci),
        pf_ci_width = mean(pf_upper - pf_lower),
        pf_ci_lower = quantile(pf_upper - pf_lower, 0.025),
        pf_ci_upper = quantile(pf_upper - pf_lower, 0.975),
        normal_rmse = sqrt(mean(normal_error^2)),
        normal_ci_cov = mean(normal_ci),
        normal_ci_width = mean(normal_upper - normal_lower),
        normal_ci_lower = quantile(normal_upper - normal_lower, 0.025),
        normal_ci_upper = quantile(normal_upper - normal_lower, 0.975),
        hist_rmse = sqrt(mean(hist_error^2, na.rm = TRUE)),
        hist_ci_cov = mean(hist_ci, na.rm = TRUE),
        hist_ci_width = mean(historical_upper - historical_lower, na.rm = TRUE),
        hist_ci_lower = quantile(historical_upper - historical_lower, 0.025, na.rm = TRUE),
        hist_ci_upper = quantile(historical_upper - historical_lower, 0.975, na.rm = TRUE),
        gtfs_rmse = sqrt(mean(gtfs_error^2))
    ) %>%
    with(
        data.frame(
            rmse = round(c(pf_rmse, normal_rmse, hist_rmse, gtfs_rmse)),
            ci_cov = round(c(pf_ci_cov, normal_ci_cov, hist_ci_cov, NA), 2),
            ci_width = round(c(pf_ci_width, normal_ci_width, hist_ci_width, NA) / 60),
            ci_ci = c(
                glue::glue("({round(pf_ci_lower/60, 1)}, {round(pf_ci_upper/60, 1)})"),
                glue::glue("({round(normal_ci_lower/60, 1)}, {round(normal_ci_upper/60, 1)})"),
                glue::glue("({round(hist_ci_lower/60, 1)}, {round(hist_ci_upper/60, 1)})"),
                NA
            )
        )
    )
row.names(mat) <- paste0(
    "$\\mathcal{F}_", 1:4, "$: ",
    c(
        "Particle filter",
        "Normal approximation",
        "Historical delays",
        "Schedule-delay"
    )
)
names(mat) <- c(
    "RMSE (s)",
    "$\\Pr{\\Varr_m \\in \\text{CI}}$",
    "CI width (m)",
    "(95\\% CI)"
)
options(knitr.kable.NA = "")
knitr::kable(
    mat,
    booktabs = TRUE,
    caption = "Predictive model comparison of RMSE, in seconds, CI coverage, and mean CI width, in minutes, with a 95\\% credible interval.",
    escape = FALSE
)
@


<<model_results_rmse_time,warning=FALSE,echo=FALSE,cache=TRUE,dependson=c("model_results_load","model_colours"),cache.lazy=FALSE,fig.width=9,fig.height=3,out.width="\\textwidth",fig.cap="RMSE as a function of time of day.",fig.subcap=c("One", "Two", "Three"),fig.ncol=1,fig.colsep=rep("\\\\", 4)>>=
# tidyverse is loaded!
res_min <- eta_results %>%
    mutate(
        min = time_until_arrival %/% 60
    ) %>%
    group_by(min) %>%
    summarize(
        pf_rmse = sqrt(mean(pf_error^2)),
        pf_ci_cov = mean(pf_ci),
        pf_ci_width = mean(pf_upper - pf_lower),
        normal_rmse = sqrt(mean(normal_error^2)),
        normal_ci_cov = mean(normal_ci),
        normal_ci_width = mean(normal_upper - normal_lower),
        hist_rmse = sqrt(mean(hist_error^2, na.rm = TRUE)),
        hist_ci_cov = mean(hist_ci, na.rm = TRUE),
        hist_ci_width = mean(historical_upper - historical_lower, na.rm = TRUE),
        gtfs_rmse = sqrt(mean(gtfs_error^2))
    ) %>% arrange(min) %>%
    filter(min < 40)

plot_base <- ggplot(res_min, aes(min)) +
    theme_classic() +
    xlab("Time until arrival (minutes)")

plot_rmse <- plot_base +
    geom_path(aes(y = pf_rmse, colour = "pf")) +
    geom_path(aes(y = normal_rmse, colour = "normal")) +
    geom_path(aes(y = hist_rmse, colour = "historical")) +
    geom_path(aes(y = gtfs_rmse, colour = "gtfs")) +
    scale_colour_manual(values = pal, name = "model") +
    ylab("RMSE") + ylim(0, 400)

plot_ci <- plot_base +
    geom_hline(aes(yintercept = 0.85), lty = 2) +
    geom_path(aes(y = pf_ci_cov, colour = "pf")) +
    geom_path(aes(y = normal_ci_cov, colour = "normal")) +
    geom_path(aes(y = hist_ci_cov, colour = "historical")) +
    scale_colour_manual(values = pal, name = "model") +
    scale_y_continuous(
        name = "CI coverage (%)",
        labels = function(x) x * 100
    )

plot_width <- plot_base +
    geom_path(aes(y = pf_ci_width, colour = "pf")) +
    geom_path(aes(y = normal_ci_width, colour = "normal")) +
    geom_path(aes(y = hist_ci_width, colour = "historical")) +
    scale_colour_manual(values = pal, name = "model") +
    scale_y_continuous(
        name = "Mean CI width (minutes)",
        breaks = function(x) pretty(x / 60) * 60,
        labels = function(x) x / 60
    )

gA <- ggplotGrob(plot_rmse)
gB <- ggplotGrob(plot_ci)
gC <- ggplotGrob(plot_width)
wds <- grid::unit.pmax(gA$widths, gB$widths, gC$widths)
gA$widths <- wds
gB$widths <- wds
gC$widths <- wds

plot(gA)
plot(gB)
plot(gC)
@


<<model_results_rmse_stopn,warning=FALSE,echo=FALSE,cache=TRUE,dependson=c("model_results_load","model_colours"),cache.lazy=FALSE,fig.width=9,fig.height=3,out.width="\\textwidth",fig.cap="RMSE as a function of stop sequence.",fig.subcap=c("One", "Two", "Three"),fig.ncol=1,fig.colsep=rep("\\\\", 4)>>=
# library(patchwork)
# tidyverse is loaded!
res_stop <- eta_results %>%
    mutate(
        min = time_until_arrival %/% 60
    ) %>%
    group_by(stop_sequence) %>%
    summarize(
        pf_rmse = sqrt(mean(pf_error^2)),
        pf_ci_cov = mean(pf_ci),
        pf_ci_width = mean(pf_upper - pf_lower),
        normal_rmse = sqrt(mean(normal_error^2)),
        normal_ci_cov = mean(normal_ci),
        normal_ci_width = mean(normal_upper - normal_lower),
        hist_rmse = sqrt(mean(hist_error^2, na.rm = TRUE)),
        hist_ci_cov = mean(hist_ci, na.rm = TRUE),
        hist_ci_width = mean(historical_upper - historical_lower, na.rm = TRUE),
        gtfs_rmse = sqrt(mean(gtfs_error^2))
    ) %>%
    filter(stop_sequence <= 60) %>%
    arrange(stop_sequence)

plot_base <- ggplot(res_stop, aes(stop_sequence)) +
    theme_classic() +
    xlab("Stop sequence")

plot_rmse <- plot_base +
    geom_path(aes(y = pf_rmse, colour = "pf")) +
    geom_path(aes(y = normal_rmse, colour = "normal")) +
    geom_path(aes(y = hist_rmse, colour = "historical")) +
    geom_path(aes(y = gtfs_rmse, colour = "gtfs")) +
    scale_colour_manual(values = pal, name = "model") +
    ylab("RMSE") + ylim(c(0, 500))

plot_ci <- plot_base +
    geom_hline(aes(yintercept = 0.85), lty = 2) +
    geom_path(aes(y = pf_ci_cov, colour = "pf")) +
    geom_path(aes(y = normal_ci_cov, colour = "normal")) +
    geom_path(aes(y = hist_ci_cov, colour = "historical")) +
    scale_colour_manual(values = pal, name = "model") +
    scale_y_continuous(
        name = "CI coverage (%)",
        labels = function(x) x * 100
    )

plot_width <- plot_base +
    geom_path(aes(y = pf_ci_width, colour = "pf")) +
    geom_path(aes(y = normal_ci_width, colour = "normal")) +
    geom_path(aes(y = hist_ci_width, colour = "historical")) +
    scale_colour_manual(values = pal, name = "model") +
    scale_y_continuous(
        name = "Mean CI width (minutes)",
        breaks = function(x) pretty(x / 60) * 60,
        labels = function(x) x / 60
    )

gA <- ggplotGrob(plot_rmse)
gB <- ggplotGrob(plot_ci)
gC <- ggplotGrob(plot_width)
wds <- grid::unit.pmax(gA$widths, gB$widths, gC$widths)
gA$widths <- wds
gB$widths <- wds
gC$widths <- wds

plot(gA)
plot(gB)
plot(gC)
@



<<model_results_rmse_timeofday,warning=FALSE,echo=FALSE,cache=TRUE,dependson=c("model_results_load","model_colours"),cache.lazy=FALSE,fig.width=9,fig.height=3,out.width="\\textwidth",fig.cap="RMSE as a function of time of day.",fig.subcap=c("One", "Two", "Three"),fig.ncol=1,fig.colsep=rep("\\\\", 4)>>=
res_timeofday <- eta_results %>%
    mutate(
        hour = timestamp %>% format("%H") %>% as.integer,
        minute = timestamp %>% format("%M") %>% as.integer,
        hour = hour + (floor(minute / 15) * 15 / 60)
    ) %>%
    group_by(hour) %>%
    summarize(
        pf_rmse = sqrt(mean(pf_error^2)),
        pf_ci_cov = mean(pf_ci),
        pf_ci_width = mean(pf_upper - pf_lower),
        normal_rmse = sqrt(mean(normal_error^2)),
        normal_ci_cov = mean(normal_ci),
        normal_ci_width = mean(normal_upper - normal_lower),
        hist_rmse = sqrt(mean(hist_error^2, na.rm = TRUE)),
        hist_ci_cov = mean(hist_ci, na.rm = TRUE),
        hist_ci_width = mean(historical_upper - historical_lower, na.rm = TRUE),
        gtfs_rmse = sqrt(mean(gtfs_error^2))
    ) %>% arrange(hour)

plot_base <- ggplot(res_timeofday, aes(hour)) +
    theme_classic() +
    scale_colour_manual(values = pal, name = "model") +
    xlab("Hour")

plot_rmse <- plot_base +
    geom_path(aes(y = pf_rmse, colour = "pf")) +
    geom_path(aes(y = normal_rmse, colour = "normal")) +
    geom_path(aes(y = hist_rmse, colour = "historical")) +
    geom_path(aes(y = gtfs_rmse, colour = "gtfs")) +
    ylab("RMSE") + ylim(c(0, 500))

plot_ci <- plot_base +
    geom_hline(aes(yintercept = 0.85), lty = 2) +
    geom_path(aes(y = pf_ci_cov, colour = "pf")) +
    geom_path(aes(y = normal_ci_cov, colour = "normal")) +
    geom_path(aes(y = hist_ci_cov, colour = "historical")) +
    scale_y_continuous(
        name = "CI coverage (%)",
        labels = function(x) x * 100
    )

plot_width <- plot_base +
    geom_path(aes(y = pf_ci_width, colour = "pf")) +
    geom_path(aes(y = normal_ci_width, colour = "normal")) +
    geom_path(aes(y = hist_ci_width, colour = "historical")) +
    scale_y_continuous(
        name = "Mean CI width (minutes)",
        breaks = function(x) pretty(x / 60) * 60,
        labels = function(x) x / 60
    )

gA <- ggplotGrob(plot_rmse)
gB <- ggplotGrob(plot_ci)
gC <- ggplotGrob(plot_width)
wds <- grid::unit.pmax(gA$widths, gB$widths, gC$widths)
gA$widths <- wds
gB$widths <- wds
gC$widths <- wds

plot(gA)
plot(gB)
plot(gC)
@



<<model_results_pr_miss,echo=FALSE,message=FALSE,warning=FALSE,cache=TRUE,dependson=c("model_results_load","model_colours"),cache.lazy=FALSE>>=
gtfs_min_before <- 8
pr_smry <- eta_results %>%
    mutate(
        # bus arrives after point estimate
        pf_catch = as.integer(time_until_arrival > pf_mean),
        normal_catch = as.integer(time_until_arrival > normal_mean),
        hist_catch = as.integer(time_until_arrival > historical_mean),
        gtfs_catch = as.integer(time_until_arrival > gtfs_eta),
        # bus arrives after lower bound
        pf_lower_catch = as.integer(time_until_arrival > pf_lower),
        normal_lower_catch = as.integer(time_until_arrival > normal_lower),
        hist_lower_catch = as.integer(time_until_arrival > historical_lower),
        # expected wait time | arrive at lower bound & don't miss bus
        pf_wait = ifelse(pf_lower_catch, time_until_arrival - pf_lower, NA),
        normal_wait = ifelse(normal_lower_catch, time_until_arrival - normal_lower, NA),
        hist_wait = ifelse(hist_lower_catch, time_until_arrival - historical_lower, NA),
    ) %>%
    summarize(
        pf_catch = mean(pf_catch),
        normal_catch = mean(normal_catch),
        hist_catch = mean(hist_catch, na.rm = TRUE),
        gtfs_catch = mean(gtfs_catch),
        pf_lower_catch = mean(pf_lower_catch),
        normal_lower_catch = mean(normal_lower_catch),
        hist_lower_catch = mean(hist_lower_catch, na.rm = TRUE),
        pf_wait_lower = quantile(pf_wait, 0.025, na.rm = TRUE),
        pf_wait_upper = quantile(pf_wait, 0.975, na.rm = TRUE),
        normal_wait_lower = quantile(normal_wait, 0.025, na.rm = TRUE),
        normal_wait_upper = quantile(normal_wait, 0.975, na.rm = TRUE),
        hist_wait_lower = quantile(hist_wait, 0.025, na.rm = TRUE),
        hist_wait_upper = quantile(hist_wait, 0.975, na.rm = TRUE),
        pf_wait = mean(pf_wait, na.rm = TRUE),
        normal_wait = mean(normal_wait, na.rm = TRUE),
        hist_wait = mean(hist_wait, na.rm = TRUE)
    )
pr_mat <- with(pr_smry,
    data.frame(
        pr_catch =
            round(c(pf_catch, normal_catch, hist_catch, gtfs_catch), 2),
        pr_lower_catch =
            round(c(pf_lower_catch, normal_lower_catch, hist_lower_catch, NA), 2),
        exp_wait = round(c(pf_wait, normal_wait, hist_wait, NA) / 60, 2),
        exp_ci = c(
            glue::glue("({round(pf_wait_lower/60, 1)}, {round(pf_wait_upper/60, 1)})"),
            glue::glue("({round(normal_wait_lower/60, 1)}, {round(normal_wait_upper/60, 1)})"),
            glue::glue("({round(hist_wait_lower/60, 1)}, {round(hist_wait_upper/60, 1)})"),
            NA
        )
    )
)

options(knitr.kable.NA = "")
row.names(pr_mat) <- paste0(
    "$\\mathcal{F}_", 1:4, "$: ",
    c(
        "Particle filter",
        "Normal approximation",
        "Historical delays",
        "Schedule-delay"
    )
)
names(pr_mat) <- c("$\\mathbb{P}_m$", "$\\mathbb{P}_\\ell$", "$\\mathbb{E}_\\ell$ (m)", "(95\\% CI)")
knitr::kable(
    pr_mat,
    booktabs = TRUE,
    caption = "The probability of catching a bus given a passenger arrives by the mean/median ($\\mathbb{P}_m$) and lower quantile ($\\mathbb{P}_\\ell$), along with the expected waiting time, in minutes, given arrival by the lower quantile, for each of the for forecast methods.",
    escape = FALSE
)
@

<<model_results_pr_gtfs,echo=FALSE,message=FALSE,warning=FALSE,cache=TRUE,dependson=c("model_results_load","model_results_pr_miss"),cache.lazy=FALSE,fig.width=9,fig.height=3,out.width="\\textwidth",fig.cap="GTFS equivalent",fig.subcap=c("One", "Two"),fig.ncol=1,fig.colsep=rep("\\\\", 3)>>=
# the equivalent values for GTFS
ers <- eta_results %>% select(timestamp, stop_sequence, time_until_arrival, gtfs_eta)
smrys <- do.call(rbind,
    lapply(2:14, function(mins) {
        ers %>%
            mutate(
                gtfs_catch = as.integer(time_until_arrival > gtfs_eta - mins * 60),
                gtfs_wait = ifelse(gtfs_catch, time_until_arrival - gtfs_eta + mins * 60, NA)
            ) %>%
            summarize(
                gtfs_catch = mean(gtfs_catch, na.rm = TRUE),
                gtfs_wait = mean(gtfs_wait, na.rm = TRUE)
            ) %>%
            mutate(min_before = mins)
    })
)

plot_base <- ggplot(smrys, aes(min_before)) +
    theme_classic() +
    scale_colour_manual(values = pal, name = "model") +
    scale_x_continuous(
        name = "Time before GTFS ETA (minutes)",
        breaks = seq(2, 14, by = 4)
    )

plotA <- plot_base +
    geom_hline(aes(yintercept = pr_smry$pf_lower_catch, colour = "pf"), lty = 2) +
    geom_hline(aes(yintercept = pr_smry$normal_lower_catch, colour = "normal"), lty = 2) +
    geom_hline(aes(yintercept = pr_smry$hist_lower_catch, colour = "historical"), lty = 2) +
    geom_path(aes(y = gtfs_catch, colour = "gtfs")) +
    ylab("Probability of arriving before the bus")

plotB <- plot_base +
    geom_hline(aes(yintercept = pr_smry$pf_wait / 60, colour = "pf"), lty = 2) +
    # geom_hline(aes(yintercept = pr_smry$normal_wait / 60, colour = "normal"), lty = 2) +
    geom_hline(aes(yintercept = pr_smry$hist_wait / 60, colour = "historical"), lty = 2) +
    geom_path(aes(y = gtfs_wait / 60, colour = "gtfs")) +
    ylab("Expected waiting time (min)")

gA <- ggplotGrob(plotA)
gB <- ggplotGrob(plotB)
wds <- grid::unit.pmax(gA$widths, gB$widths)
gA$widths <- wds
gB$widths <- wds
plot(gA)
plot(gB)
@



<<model_results_pr_time,echo=FALSE,message=FALSE,warning=FALSE,cache=TRUE,dependson=c("model_results_load","model_results_pr_miss"),cache.lazy=FALSE,fig.width=9,fig.height=3,out.width="\\textwidth",fig.cap="Summary values by time until arrival.",fig.subcap=c("One", "Two", "Three"),fig.ncol=1,fig.colsep=rep("\\\\", 4)>>=
pr_smry_time <- eta_results %>%
    mutate(
        # bus arrives after point estimate
        pf_catch = as.integer(time_until_arrival > pf_mean),
        normal_catch = as.integer(time_until_arrival > normal_mean),
        hist_catch = as.integer(time_until_arrival > historical_mean),
        gtfs_catch = as.integer(time_until_arrival > gtfs_eta),
        # bus arrives after lower bound
        pf_lower_catch = as.integer(time_until_arrival > pf_lower),
        normal_lower_catch = as.integer(time_until_arrival > normal_lower),
        hist_lower_catch = as.integer(time_until_arrival > historical_lower),
        gtfs_lower_catch = as.integer(time_until_arrival > gtfs_eta - 8 * 60),
        # expected wait time | arrive at lower bound & don't miss bus
        pf_wait = ifelse(pf_lower_catch, time_until_arrival - pf_lower, NA),
        normal_wait = ifelse(normal_lower_catch, time_until_arrival - normal_lower, NA),
        hist_wait = ifelse(hist_lower_catch, time_until_arrival - historical_lower, NA),
        gtfs_wait = ifelse(gtfs_lower_catch, time_until_arrival - gtfs_eta + 8 * 60, NA),
        min = time_until_arrival %/% 60
    ) %>%
    group_by(min) %>%
    summarize(
        pf_catch = mean(pf_catch),
        normal_catch = mean(normal_catch),
        hist_catch = mean(hist_catch, na.rm = TRUE),
        gtfs_catch = mean(gtfs_catch),
        pf_lower_catch = mean(pf_lower_catch),
        normal_lower_catch = mean(normal_lower_catch),
        hist_lower_catch = mean(hist_lower_catch, na.rm = TRUE),
        gtfs_lower_catch = mean(gtfs_lower_catch, na.rm = TRUE),
        pf_wait = mean(pf_wait, na.rm = TRUE),
        normal_wait = mean(normal_wait, na.rm = TRUE),
        hist_wait = mean(hist_wait, na.rm = TRUE),
        gtfs_wait = mean(gtfs_wait, na.rm = TRUE)
    ) %>%
    filter(min < 40 & min > 0) %>% arrange(min)


plot_base <- ggplot(pr_smry_time, aes(min)) +
    theme_classic() +
    scale_colour_manual(values = pal, name = "model") +
    xlab("Time until arrival (minutes)")

plotA <- plot_base +
    geom_path(aes(y = pf_catch, colour = "pf")) +
    geom_path(aes(y = normal_catch, colour = "normal")) +
    geom_path(aes(y = hist_catch, colour = "historical")) +
    geom_path(aes(y = gtfs_catch, colour = "gtfs")) +
    ylab("Probability of arriving before the bus\n(arrive at point estimate)")

plotB <- plot_base +
    geom_path(aes(y = pf_lower_catch, colour = "pf")) +
    geom_path(aes(y = normal_lower_catch, colour = "normal")) +
    geom_path(aes(y = hist_lower_catch, colour = "historical")) +
    geom_path(aes(y = gtfs_lower_catch, colour = "gtfs")) +
    ylab("Probability of arriving before the bus\n(arrive at lower estimate)")

plotC <- plot_base +
    geom_abline(lty = 3) +
    geom_path(aes(y = pmin(min, pf_wait / 60), colour = "pf")) +
    geom_path(aes(y = pmin(min, normal_wait / 60), colour = "normal")) +
    geom_path(aes(y = pmin(min, hist_wait / 60), colour = "historical")) +
    geom_path(aes(y = pmin(min, gtfs_wait / 60), colour = "gtfs")) +
    ylab("Expected waiting time (min)\n(arrive at lower estimate)") + ylim(0, 20)

gA <- ggplotGrob(plotA)
gB <- ggplotGrob(plotB)
gC <- ggplotGrob(plotC)
wds <- grid::unit.pmax(gA$widths, gB$widths, gC$widths)
gA$widths <- wds
gB$widths <- wds
gC$widths <- wds
plot(gA)
plot(gB)
plot(gC)
@



<<model_results_pr_stop,echo=FALSE,message=FALSE,warning=FALSE,cache=TRUE,dependson=c("model_results_load","model_results_pr_miss"),cache.lazy=FALSE,fig.width=9,fig.height=3,out.width="\\textwidth",fig.cap="Summary values by stop sequence.",fig.subcap=c("One", "Two", "Three"),fig.ncol=1,fig.colsep=rep("\\\\", 4)>>=
pr_smry_stop <- eta_results %>%
    mutate(
        # bus arrives after point estimate
        pf_catch = as.integer(time_until_arrival > pf_mean),
        normal_catch = as.integer(time_until_arrival > normal_mean),
        hist_catch = as.integer(time_until_arrival > historical_mean),
        gtfs_catch = as.integer(time_until_arrival > gtfs_eta),
        # bus arrives after lower bound
        pf_lower_catch = as.integer(time_until_arrival > pf_lower),
        normal_lower_catch = as.integer(time_until_arrival > normal_lower),
        hist_lower_catch = as.integer(time_until_arrival > historical_lower),
        gtfs_lower_catch = as.integer(time_until_arrival > gtfs_eta - 8 * 60),
        # expected wait time | arrive at lower bound & don't miss bus
        pf_wait = ifelse(pf_lower_catch, time_until_arrival - pf_lower, NA),
        normal_wait = ifelse(normal_lower_catch, time_until_arrival - normal_lower, NA),
        hist_wait = ifelse(hist_lower_catch, time_until_arrival - historical_lower, NA),
        gtfs_wait = ifelse(gtfs_lower_catch, time_until_arrival - gtfs_eta + 8 * 60, NA),
        min = time_until_arrival %/% 60
    ) %>%
    group_by(stop_sequence) %>%
    summarize(
        pf_catch = mean(pf_catch),
        normal_catch = mean(normal_catch),
        hist_catch = mean(hist_catch, na.rm = TRUE),
        gtfs_catch = mean(gtfs_catch),
        pf_lower_catch = mean(pf_lower_catch),
        normal_lower_catch = mean(normal_lower_catch),
        hist_lower_catch = mean(hist_lower_catch, na.rm = TRUE),
        gtfs_lower_catch = mean(gtfs_lower_catch, na.rm = TRUE),
        pf_wait = mean(pf_wait, na.rm = TRUE),
        normal_wait = mean(normal_wait, na.rm = TRUE),
        hist_wait = mean(hist_wait, na.rm = TRUE),
        gtfs_wait = mean(gtfs_wait, na.rm = TRUE)
    ) %>%
    filter(stop_sequence <= 60) %>%
    arrange(stop_sequence)


plot_base <- ggplot(pr_smry_stop, aes(stop_sequence)) +
    theme_classic() +
    scale_colour_manual(values = pal, name = "model") +
    xlab("Stop sequence")

plotA <- plot_base +
    geom_path(aes(y = pf_catch, colour = "pf")) +
    geom_path(aes(y = normal_catch, colour = "normal")) +
    geom_path(aes(y = hist_catch, colour = "historical")) +
    geom_path(aes(y = gtfs_catch, colour = "gtfs")) +
    ylab("Probability of arriving before the bus\n(arrive at point estimate)")

plotB <- plot_base +
    geom_path(aes(y = pf_lower_catch, colour = "pf")) +
    geom_path(aes(y = normal_lower_catch, colour = "normal")) +
    geom_path(aes(y = hist_lower_catch, colour = "historical")) +
    geom_path(aes(y = gtfs_lower_catch, colour = "gtfs")) +
    ylab("Probability of arriving before the bus\n(arrive at lower estimate)")

plotC <- plot_base +
    geom_path(aes(y = pf_wait / 60, colour = "pf")) +
    geom_path(aes(y = normal_wait / 60, colour = "normal")) +
    geom_path(aes(y = hist_wait / 60, colour = "historical")) +
    geom_path(aes(y = gtfs_wait / 60, colour = "gtfs")) +
    ylab("Expected waiting time (min)\n(arrive at lower estimate)") + ylim(0, 20)

gA <- ggplotGrob(plotA)
gB <- ggplotGrob(plotB)
gC <- ggplotGrob(plotC)
wds <- grid::unit.pmax(gA$widths, gB$widths, gC$widths)
gA$widths <- wds
gB$widths <- wds
gC$widths <- wds
plot(gA)
plot(gB)
plot(gC)
@


<<model_results_pr_timeofday,echo=FALSE,message=FALSE,warning=FALSE,cache=TRUE,dependson=c("model_results_load","model_results_pr_miss"),cache.lazy=FALSE,fig.width=9,fig.height=3,out.width="\\textwidth",fig.cap="Summary values by time of day.",fig.subcap=c("One", "Two", "Three"),fig.ncol=1,fig.colsep=rep("\\\\", 4)>>=
pr_smry_timeofday <- eta_results %>%
    mutate(
        # bus arrives after point estimate
        pf_catch = as.integer(time_until_arrival > pf_mean),
        normal_catch = as.integer(time_until_arrival > normal_mean),
        hist_catch = as.integer(time_until_arrival > historical_mean),
        gtfs_catch = as.integer(time_until_arrival > gtfs_eta),
        # bus arrives after lower bound
        pf_lower_catch = as.integer(time_until_arrival > pf_lower),
        normal_lower_catch = as.integer(time_until_arrival > normal_lower),
        hist_lower_catch = as.integer(time_until_arrival > historical_lower),
        gtfs_lower_catch = as.integer(time_until_arrival > gtfs_eta - 8 * 60),
        # expected wait time | arrive at lower bound & don't miss bus
        pf_wait = ifelse(pf_lower_catch, time_until_arrival - pf_lower, NA),
        normal_wait = ifelse(normal_lower_catch, time_until_arrival - normal_lower, NA),
        hist_wait = ifelse(hist_lower_catch, time_until_arrival - historical_lower, NA),
        gtfs_wait = ifelse(gtfs_lower_catch, time_until_arrival - gtfs_eta + 8 * 60, NA),
        hour = timestamp %>% format("%H") %>% as.integer,
        minute = timestamp %>% format("%M") %>% as.integer,
        hour = hour + (floor(minute / 15) * 15 / 60)
    ) %>%
    group_by(hour) %>%
    summarize(
        pf_catch = mean(pf_catch),
        normal_catch = mean(normal_catch),
        hist_catch = mean(hist_catch, na.rm = TRUE),
        gtfs_catch = mean(gtfs_catch),
        pf_lower_catch = mean(pf_lower_catch),
        normal_lower_catch = mean(normal_lower_catch),
        hist_lower_catch = mean(hist_lower_catch, na.rm = TRUE),
        gtfs_lower_catch = mean(gtfs_lower_catch, na.rm = TRUE),
        pf_wait = mean(pf_wait, na.rm = TRUE),
        normal_wait = mean(normal_wait, na.rm = TRUE),
        hist_wait = mean(hist_wait, na.rm = TRUE),
        gtfs_wait = mean(gtfs_wait, na.rm = TRUE)
    ) %>%
    arrange(hour)


plot_base <- ggplot(pr_smry_timeofday, aes(hour)) +
    theme_classic() +
    scale_colour_manual(values = pal, name = "model") +
    xlab("Time of day")

plotA <- plot_base +
    geom_path(aes(y = pf_catch, colour = "pf")) +
    geom_path(aes(y = normal_catch, colour = "normal")) +
    geom_path(aes(y = hist_catch, colour = "historical")) +
    geom_path(aes(y = gtfs_catch, colour = "gtfs")) +
    ylab("Probability of arriving before the bus\n(arrive at point estimate)")

plotB <- plot_base +
    geom_path(aes(y = pf_lower_catch, colour = "pf")) +
    geom_path(aes(y = normal_lower_catch, colour = "normal")) +
    geom_path(aes(y = hist_lower_catch, colour = "historical")) +
    geom_path(aes(y = gtfs_lower_catch, colour = "gtfs")) +
    ylab("Probability of arriving before the bus\n(arrive at lower estimate)")

plotC <- plot_base +
    geom_path(aes(y = pf_wait / 60, colour = "pf")) +
    geom_path(aes(y = normal_wait / 60, colour = "normal")) +
    geom_path(aes(y = hist_wait / 60, colour = "historical")) +
    geom_path(aes(y = gtfs_wait / 60, colour = "gtfs")) +
    ylab("Expected waiting time (min)\n(arrive at lower estimate)") + ylim(0, 20)


gA <- ggplotGrob(plotA)
gB <- ggplotGrob(plotB)
gC <- ggplotGrob(plotC)
wds <- grid::unit.pmax(gA$widths, gB$widths, gC$widths)
gA$widths <- wds
gB$widths <- wds
gC$widths <- wds
plot(gA)
plot(gB)
plot(gC)
@



