\section{\Rt{} implementation in Rcpp}
\label{sec:rt-implementation}

In \cref{sec:gtfs} we introduced the R package \verb+transitr+, which loads a \GTFS{} database and connects to a \rt{} \gls{api}. The advantage of R \citep{rcore} was its superior ability for processing data of various forms through additional packages, and providing an easy-to-use interface for users. However, when it comes to computational efficiency, C++ is the better choice. Fortunately, R offers an interface to C++ through the 'Rcpp' package developed by \cite{Rcpp}. This gives us the speed and memory management capabilities of C++ from within R.

The general structure of our program comes in two parts. The first handles data collection from a transit provider and creation of the transit network (\cref{sec:route-segments}), which are all stored in an SQLite database.  Users are able to connect a GTFS-realtime \gls{api}, as well as pass additional arguments, to the generated \verb+gtfs+ object, which are then forwarded onto the second part which runs purely within C++.

Within the C++ component there are two main phases: the setup phase and the modelling phase. During the setup, the GTFS database is loaded and parameter values establised. A vector of \verb+Vehicle+ objects is initialized which will contain the \rt{} vehicle states. The modelling phase consists of a single \verb+while+ loop which runs until the program is sent a kill signal by the operating system. It is inside this loop that all of the \rt{} modelling discussed throughout the remainder of this thesis occurs.

Within the program, we use \gls{oop} to represent objects---both static (routes and trips) and \rt{} (vehicles, road segments). These objects contain a lot of \emph{interdependence}; for example, a trip belongs to a route, and a vehicle services trips. Pointers are used in C++ to allow easy access to these relationships without any duplication of information. For example, the route number for a vehicle can be obtained using the following command:
\begin{knitrout}\small
\definecolor{shadecolor}{rgb}{0.969, 0.969, 0.969}\color{fgcolor}\begin{kframe}
\noindent
\ttfamily
\hlstd{vehicle}\hlopt{.}\hlstd{}\hlkwd{trip\ }\hlstd{}\hlopt{(){-}$>$}\hlstd{}\hlkwd{route\ }\hlstd{}\hlopt{(){-}$>$}\hlstd{}\hlkwd{route\textunderscore short\textunderscore name\ }\hlstd{}\hlopt{();}\hlstd{}\hspace*{\fill}
\mbox{}
\normalfont
\end{kframe}
\end{knitrout}
Pointers are not fixes, so the above example will work even after the vehicle changes to another trip. In addition to retrieving information, pointers can be used to pass information between objects. Later in this thesis, we use vehicle to estimate the average speed of vehicles along individual roads, and then forward these observations on to the appropriate road segment. First, we note that a route follows a sequence of road segments, which we store in C++ using a \verb+std::vector+ containing an ordered sequence of \verb+RouteSegment+ objects, each pointing to the appropriate \verb+Segment+ object. Thus, once a vehicle completes travel along the segment with index \verb+index+, the observed average speed can be passed to directly to the \verb+Segment+ object:
\begin{knitrout}\small
\definecolor{shadecolor}{rgb}{0.969, 0.969, 0.969}\color{fgcolor}\begin{kframe}
\noindent
\ttfamily
\hlstd{vehicle}\hlopt{.}\hlstd{}\hlkwd{trip\ }\hlstd{}\hlopt{(){-}$>$}\hlstd{}\hlkwd{route\ }\hlstd{}\hlopt{()}\hspace*{\fill}\\
\hlstd{}\hlstd{\ \ \ \ }\hlstd{}\hlopt{{-}$>$}\hlstd{}\hlkwd{segments\ }\hlstd{}\hlopt{().}\hlstd{}\hlkwd{at\ }\hlstd{}\hlopt{(}\hlstd{index}\hlopt{){-}$>$}\hlstd{}\hlkwd{segment\ }\hlstd{}\hlopt{()}\hspace*{\fill}\\
\hlstd{}\hlstd{\ \ \ \ }\hlstd{}\hlopt{{-}$>$}\hlstd{}\hlkwd{push\textunderscore data\ }\hlstd{}\hlopt{(}\hlstd{speed}\hlopt{,\ }\hlstd{uncertainty}\hlopt{);}\hlstd{}\hspace*{\fill}
\mbox{}
\normalfont
\end{kframe}
\end{knitrout}
This data is then handled by the segment, as we describe later in \cref{cha:network_model}.

The main issue with pointers is that, if an object is deleted or moved, a pointer may no longer point to the appropriate object, resuling in a \emph{segmentation fault} and crashing the program at runtime. However, with care, and by checking a pointer is valid before using it, we can avoid such problems. For example, the above would be better written as follows.
\begin{knitrout}\small
\definecolor{shadecolor}{rgb}{0.969, 0.969, 0.969}\color{fgcolor}\begin{kframe}
\noindent
\ttfamily
\hlstd{Trip}\hlopt{{*}\ }\hlstd{trip\ }\hlopt{=\ }\hlstd{vehicle}\hlopt{.}\hlstd{}\hlkwd{trip\ }\hlstd{}\hlopt{();}\hspace*{\fill}\\
\hlstd{}\hlkwa{if\ }\hlstd{}\hlopt{(}\hlstd{trip\ }\hlopt{==\ }\hlstd{}\hlkwc{nullptr}\hlstd{}\hlopt{)\ }\hlstd{}\hlkwa{return}\hlstd{}\hlopt{();}\hspace*{\fill}\\
\hlstd{Route}\hlopt{{*}\ }\hlstd{route\ }\hlopt{=\ }\hlstd{trip}\hlopt{{-}$>$}\hlstd{}\hlkwd{route\ }\hlstd{}\hlopt{();}\hspace*{\fill}\\
\hlstd{}\hlkwa{if\ }\hlstd{}\hlopt{(}\hlstd{route\ }\hlopt{==\ }\hlstd{}\hlkwc{nullptr}\hlstd{}\hlopt{)\ }\hlstd{}\hlkwa{return}\hlstd{}\hlopt{();}\hspace*{\fill}\\
\hlstd{}\hlkwa{if\ }\hlstd{}\hlopt{(}\hlstd{route}\hlopt{{-}$>$}\hlstd{segments}\hlopt{.}\hlstd{}\hlkwd{size\ }\hlstd{}\hlopt{()\ $<$=\ }\hlstd{index}\hlopt{)\ }\hlstd{}\hlkwa{return\ }\hlstd{}\hlopt{();}\hspace*{\fill}\\
\hlstd{Segment}\hlopt{{*}\ }\hlstd{segment\ }\hlopt{=\ }\hlstd{route}\hlopt{{-}$>$}\hlstd{segments}\hlopt{.}\hlstd{}\hlkwd{at\ }\hlstd{}\hlopt{(}\hlstd{index}\hlopt{){-}$>$}\hlstd{}\hlkwd{segment\ }\hlstd{}\hlopt{();}\hspace*{\fill}\\
\hlstd{}\hlkwa{if\ }\hlstd{}\hlopt{(}\hlstd{segment\ }\hlopt{==\ }\hlstd{}\hlkwc{nullptr}\hlstd{}\hlopt{)\ }\hlstd{}\hlkwa{return\ }\hlstd{}\hlopt{();}\hspace*{\fill}\\
\hlstd{segment}\hlopt{{-}$>$}\hlstd{}\hlkwd{push\textunderscore data\ }\hlstd{}\hlopt{(}\hlstd{speed}\hlopt{,\ }\hlstd{uncertainty}\hlopt{);}\hlstd{}\hspace*{\fill}
\mbox{}
\normalfont
\end{kframe}
\end{knitrout}

The last topic for this section is \emph{multithreading}, which is the process of using more than one CPU core to run the program with the assistance of OpenMP. This requires our program to be \emph{threadsafe}, such that two independent cores wil not adversely interact (for example by both trying to modify the same object). The simplest way around this is to perform read-only operations on common resources.

Sometimes, however, write operations are unavoidable, such as the example before with passing data to road segments. \emph{Mutex locking} provides a simple way of ensuring that only one process can perform a specified task at a time. Continuing with the same example, if two vehicles traverse a road at the same time (which happens frequently), they will both want to push their observed speed observations to this same road segment object at the same time. To prevent errors, we create a lock at the beginning of the \verb+push_data ()+ method. Now when the first vehicle calls \verb+push_data ()+, the segment is ``locked'' until the method is complete (the data is processed and stored within the segment object). If a second vehicle calls the method before the first has finished, it will find the segment locked and the process will wait until the lock has been released before it can continue. This lets us parallelise the processing of vehicles to multiple cores, greatly speeding up iteration timings.
