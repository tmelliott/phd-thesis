\section{GTFS}
\label{sec:gtfs}

The adoption of GTFS \citep{GoogleDevelopers_2006} to public transport agencies around the world
has made it possible for apps such as Google Maps
to access and display public transport data to users,
regardless of their location.
The main goal of GTFS is to specify, in detail,
how transit data should be organised in a fundamental way
that is consistent across agencies around the world.


\GTFS{} consists of two components,
\emph{static} and \emph{\rt{}}.
The static component specifies how information portaining to the schedule,
fare, and route geography are organised,
while the \emph{\rt{}} component specifies the format for vehicle locations,
arrival predictions, and service advisories.
Each of the static and \rt{} components are implemented by a transit provider,
for example \AT{} have a set up their \GTFS{} service
which is hosted at \url{https://dev-portal.at.govt.nz}.


\subsection{Static GTFS}
\label{sec:gtfs_static}


\begin{table}[t]
\centering
\begin{tabular}{ll}
\toprule
Term & Definition \\
\midrule
route & a collection of \emph{trips} that are displayed to comuters
as a single service \\
trip & a journey servicing two or more stops at a specific time \\
stop & a location where passengers are picked up or dropped off \\
stop time & the (scheduled) times at which vehicles
will arrive at stops for each trip \\
shape & the GPS track a vehicle will take for a specific route \\
\bottomrule
\end{tabular}
\caption{Definitions of relevant GTFS terms, taken from\\
\url{https://developers.google.com/transit/gtfs/reference/}}
\label{tab:gtfs_terms}
\end{table}


There are several components of GTFS that are of particular interest to us:
routes, trips, stops, stop times, and shapes.
The definitions of these terms are given in \cref{tab:gtfs_terms}.
Extensive documentation can be found on these and the other components
on the GTFS website (\url{https://developers.google.com/transit/gtfs/})
\citep{GoogleDevelopers_2006}.


\Cref{fig:gtfs_nw} demonstrates a single \emph{route},
along which there are two active \emph{trips} (A and B).
The route's \emph{shape} is represented by the line connecting
the six \emph{stops} numbered 1--6.
The \rt{} arrivals board is shown for stop~5,
displaying the scheduled \emph{stop time} (arrival time) for each trip at that stop.
The additional information displayed is described in the next section.



<<gtfs_nw,echo=FALSE,messages=FALSE,fig.width=8,fig.height=5,out.width="\\textwidth",fig.align="center",fig.cap="A \\gls{gtfs} diagram of a single \\emph{route}, showing two \\emph{trips} (A and B) travelling along the route's \\emph{shape} path. The numbered squares represents \\emph{stops}, and the scheduled arrival times of each trip at stop 5 are displayed in the \\emph{stop times} box.">>=
suppressPackageStartupMessages(library(tidyverse))
load("gtfs_shape.rda")
load("gtfs_stops.rda")

shape <- shape[335:484, ]
xl <- range(shape$shape_pt_lon)
yl <- range(shape$shape_pt_lat)
stops <- stops %>%
    filter(stop_lon >= xl[1] & stop_lon <= xl[2] &
           stop_lat >= yl[1] & stop_lat <= yl[2]) %>%
    mutate(stop_id = 1:n())
busimg <- png::readPNG("bus.png", native = TRUE) %>%
    grid::rasterGrob(0, 0, 1, 1,
        just = c("left", "bottom")
    )
rat <- cos(mean(shape$shape_pt_lat * pi / 180))
xd <- diff(xl)
yd <- diff(yl)
# bus locations:
b1 <- shape[30,3:2] %>% as.numeric
b2 <- shape[113,3:2] %>% as.numeric
p <- ggplot(shape, aes(shape_pt_lon, shape_pt_lat)) +
    geom_path() +
    geom_label(aes(stop_lon, stop_lat, label = stop_id),
        data = stops,
        size = 3) +
    annotation_custom(busimg,
        b1[1] - xd * 0.2,
        b1[1] + xd * 0.2,
        b1[2] - xd * 0.2 / rat,
        b1[2] + xd * 0.2 / rat
    ) +
    annotation_custom(busimg,
        b2[1] - xd * 0.2,
        b2[1] + xd * 0.2,
        b2[2] - xd * 0.2 / rat,
        b2[2] + xd * 0.2 / rat
    ) +
    annotate("text",
        x = b1[1] + 1.8 * xd,
        y = c(b1[2], b2[2]),
        label = paste(
            "Trip",
            c("B", "A"),
            "\ndeparted last stop", c(1, 5), "min", c("late", "early")
        ),
        size = 3
    ) +
    annotate("text",
        x = b1[1] + xd * 1.5,
        y = mean(c(b1[2], b2[2])),
        label = "Stops",
        size = 3
    ) +
    geom_segment(
        aes(x, y,
            xend = b1[1] + xd * 1.1,
            yend = mean(c(b1[2], b2[2]))
        ),
        data = tibble(
            x = stops$stop_lon[2:4] + xd * 0.25,
            y = stops$stop_lat[2:4]
        ),
        lty = "23", lwd = 0.3
    ) +
    coord_fixed(rat) +
    theme_minimal() +
    theme(panel.grid = element_blank()) +
    scale_x_continuous(breaks = NULL,
        limits = extendrange(xl, f = 3)) +
    scale_y_continuous(breaks = NULL) +
    xlab("") + ylab("")

# arrivals board
p +
    geom_rect(
        aes(
            xmin = stops$stop_lon[5] - xd * 3 - xd * 0.3,
            xmax = stops$stop_lon[5] - xd - xd * 0.3,
            ymin = stops$stop_lat[5] - xd,
            ymax = stops$stop_lat[5] + xd * 0.5
        ),
        fill = "#eeeeee",
        col = "black"
    ) +
    geom_rect(
        aes(
            xmin = stops$stop_lon[5] - xd * 3 - xd * 0.3,
            xmax = stops$stop_lon[5] - xd - xd * 0.3,
            ymin = stops$stop_lat[5],
            ymax = stops$stop_lat[5] + xd * 0.5
        ),
        fill = "#eeeeee",
        col = "black",
    ) +
    annotate("text",
        x = stops$stop_lon[5] - xd * 1.95 - xd * 0.3,
        y = stops$stop_lat[5] + xd * 0.75,
        label = "StopTimes",
        size = 3
    ) +
    annotate("text",
        x = stops$stop_lon[5] - xd * 1.95 - xd * 0.3,
        y = stops$stop_lat[5] + xd * 0.25,
        label =
            "Trip   Sched    ETA",
        size = 2.5
    ) +
    annotate("text",
        x = stops$stop_lon[5] - xd * 1.90 - xd * 0.3,
        y = stops$stop_lat[5] - xd * c(0.3, 0.7),
        label = c(
            "A       9:42    9:37",
            "B       9:55    9:56"
        ),
        size = 2.5
    ) +
    geom_segment(
        aes(
            x = stops$stop_lon[5] - xd - xd * 0.3,
            xend = stops$stop_lon[5] - xd * 0.3,
            y = stops$stop_lat[5],
            yend = stops$stop_lat[5]
        ),
        lwd = 0.3,
        lty = "23"
    )
@


The distribution of static \GTFS{} data by transport providers is typically done via text files,
one for each of the components (\verb+routes.csv+, \verb+trips.csv+, etc).
Often these are then distributed as a single ZIP archive,
and the data can easily be loaded into a \emph{relational database}.
In the R package developed as part of this work,
this is done automatically using the \verb+create_gtfs()+ function:
<<transitr_load_gtfs,eval=FALSE>>=
library(transitr)
nw <- create_gtfs("at_gtfs.zip", db = "at_gtfs.sqlite")
@

<<transitr_load_gtfs_hidden,echo=FALSE>>=
source("load_gtfs.R")
library(transitr)
con <- dbConnect(SQLite(), db)
vmax <- dbGetQuery(con, "select max(version) as v from routes")$v
nstoptimes <- dbGetQuery(con, sprintf("SELECT count(*) as n from stop_times where trip_id in (select trip_id from trips where version=%s)", vmax))$n
dbDisconnect(con)
@


Within these separate files or tables, the data is stored as per \GTFS{}.
Importantly, shapes are stored as sequences of coordinates in a sequence
that draw a path on a map,
while stops are represented as a single coordinate marking the location of the bus stop.
Stop times are stored in trip-stop pairs\footnote{It is a pivot table, if you know what that is.},
with one row for every stop of each trip, along with the scheduled arrival and departure times%
\footnote{There are \Sexpr{format(nstoptimes, big.mark=",")} rows in the stop times table for Auckland Transport!}.



On its own, the static \GTFS{} information is as useful as a printed timetable,
allowing simple journey planning to take place.
It therefore provides the necessary ``fallback'' state in cases where
no \rt{} information is available for a given trip.
In later sections, we will be needing \emph{prior} information about
the travel times between stops,
so this too could be inferred from the static schedule information.



\subsection{\Rt{} GTFS}
\label{sec:gtfs_rt}

The \rt{} component of \GTFS{} is responsible for handling vehicle positions,
trip updates (arrivals and departures from stops),
and service alerts (cancellations and stop closures, for example).
Data is processed by a central server,
and then stored in an appropriate fashion to enable quick access via \glspl{api}.
There is therefore the additional need of a server that can handle
vast numbers of \gls{api} requests,
which means that only a subset of the transport providers using \GTFS{}
have also implemented this \rt{} component.
Below we give a brief summary of these components,
but further information can be read on the \GTFS{} website%
\footnote{see \url{https://developers.google.com/transit/gtfs-realtime/}.}.


\subsubsection{Vehicle positions}
\label{sec:gtfs_rt_vehicle}

The key components of a vehicle position (in the context of \GTFS{})
are a \emph{vehicle descriptor} which includes information about the physical vehicle,
a \emph{trip descriptor} which holds information about the trip being serviced,
a \emph{timestamp} specifying exactly when the observation was made,
and a \emph{position} containing the actual data,
such as the \gls{gps} observation.


\subsubsection{Trip updates}
\label{sec:gtfs_rt_trip}

As vehicles equipped with \gls{avl} technology arrive at and depart from stops,
information about their time of arrival,
and most importantly \emph{schedule adherence},
is stored in trip updates.
These also contain a \emph{trip descriptor},
as well as one or more \emph{stop time updates}.
\AT{} provides a single stop time update for the most recently visited stop;
however, it is possible to retain all previous stop time updates,
as well as provide predictions for upcoming stops.


Each stop time update reports either the arrival or departure time and,
where schedule information is available,
the schedule adherance by way of an \emph{arrival} or \emph{departure delay} (in seconds).
Typically this is based off the \gls{gps} position of the vehicle,
which is monitored by the \gls{avl} system on the vehicle,
enabling it to determine where on the route it is.



\subsubsection{Service alerts}
\label{sec:gtfs_rt_alerts}

Less important for the current work, but necessary for reliable \gls{rti},
\emph{service alerts} enable transit operators to modify the static \GTFS{} in \rt{}.
So, when a trip is cancelled, they can\footnote{Although they often don't.}
send out a service alert announcing that a specific trip has been cancelled.
This is often displayed to passengers as a ``C'' on the \rt{} board.
It is also possible to add trips, for example if there is a special event,
or to reroute trips via different stops,
but this is beyond the scope of our work.


\subsection{Accessing \rt{} data (API)}
\label{sec:gtfs_rt_api}

In order to distribute vehicle locations, trip updates, and service alerts
to passengers quickly and usefully requires more than just a \rt{} board at bus stops.
Personal mobile devices have revolutionised the way we live our lives,
and developers are constantly creating new apps to help us out.
Included in these are transit apps,
which are capable of passing on \rt{} \GTFS{} data to passengers.


The most common method of distributing \rt{} data is via an \gls{api}.
These are, in simple terms, a fixed web address that developers can fetch
and return a data file---either JSON or, in the case of some \GTFS{} systems,
protobuf \citep{cn}---which can then be parsed and displayed to users.
Usually developers need an \emph{\gls{api} key} to prevent server overload,
or to control access to data.
Our R package includes the ability to connect to a \GTFS{}-based \gls{api} easily,
by issuing the following command:
<<transitr_api_connect>>=
nw <- load_gtfs("at_gtfs.sqlite") %>%
    realtime_feed(
        "https://api.at.govt.nz/v2/public/realtime/vehiclelocations",
        with_headers(
            "Ocp-Apim-Subscription-Key" = Sys.getenv('APIKEY')
        ))
@
