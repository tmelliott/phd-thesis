\section{Improving forecasts with history}
\label{sec:nw_hist_model}

The model presented in the previous sections is adequate for estimating the \emph{real-time} state of the network, but when it comes to forecasting road travel times, it becomes unuseful, particularly just before or after a peak period. In the next chapter, we will be predicting arrival time, which will involve making short-term forecasts of travel time. To do so, we will use historical data to detect the average temporal location and magnitude of travel time peaks.

From \cref{nw_par_est_real} we saw that roads typically have a peak effect either in the morning or in the evening, while some are affected by both morning and afternoon traffic. It seems reasonable therefore to have a model which allows a segment to have zero, one, or two peaks, each with varying magnitude (the size of the increase in travel time) and width (how long the peak period is). The temporal location of these peaks is likely to be related, but variable: some roads will experience peak traffic earlier than others, for example.

<<tt_week0_load,cache=TRUE,echo=FALSE,fig.height=8,fig.width=8,fig.align="center",out.width="\\linewidth",fig.cap="Travel times along six roads over one week, coloured by the day of the week.">>=
library(ggplot2)
source("load_week_data.R")

data_week0 %>% filter(segment_id %in% sids) %>%
    mutate(weekday = factor(
        ifelse(dow %in% c("Saturday", "Sunday"), "weekend", "weekday")
    )) %>%
    # filter(!dow %in% c("Saturday", "Sunday")) %>%
    ggplot(aes(time, travel_time, colour = dow)) +
        geom_point() +
        # geom_smooth(aes(colour = NULL),span = 0.2) +
        scale_x_datetime(labels = function(t) format(t, "%l%P")) +
        facet_grid(segment_id~weekday, scales = "free_y") +
        theme_classic() +
        theme(strip.background = element_blank(), legend.position = "bottom") +
        xlab("Time") + ylab("Travel time (seconds)") +
        scale_colour_brewer(palette = "Dark2") +
        labs(colour = "Day of week")

@

Early work fitting hierarchical Bayesian models to this data were not promising, as it involved too much manual work tuning the parameters and checking the results. Since our goal is to obtain a generalised framework which can be run automatically, we had to try an alternative.

From \cref{fig:tt_week0_load} it is clear that along each segment, there is a consistent pattern, with some variability between days as far as the temporal location and magnitude of the ``peak'' on weekday; weekends are fairly consistent, although this is only two days' worth of data. Our first approach is to develop a nearest-neighbour grid, which takes current time and road state (travel time) as input, and outputs the mean and uncertainty of travel time in 10, 20, or 30~minutes. The first step is to aggregate observations into 5~minute intervals and take the mean travel time in each interval. Then, we take a duplicate of these travel times and shift if backward 10, 20, and 30~minutes, so now each row has the current state, and future predicted states too.


<<tt_week0_grid_fit,cache=TRUE,echo=FALSE>>=
library(ggplot2)
source("load_week_data.R")
library(FNN)

seg_fits <-
    lapply(sids, function(sid) {
        week0_smry <- data_week0 %>%
            filter(segment_id == sid) %>%
            mutate(
                weekday = factor(
                    ifelse(dow %in% c("Saturday", "Sunday"), "weekend", "weekday")
                ),
                t_int = as.integer(format(time, "%H")) +
                    5 * (as.integer(format(time, "%M")) %/% 5) / 60
            ) %>%
            group_by(t_int, date) %>%
            summarise(mean = mean(travel_time), e = sd(travel_time), weekday = first(weekday)) %>%
            ungroup() %>%
            mutate(time_30 = t_int + 30/60)

        week0_smry <- week0_smry %>%
            left_join(week0_smry %>% select(t_int, date, mean) %>% rename(tt30 = mean),
                by = c("date", "time_30" = "t_int")
            ) %>%
            group_by(date) %>%
            # w0 <- week0_smry %>% filter(date == "2019-08-12")
            do({
                w0 <- (.) %>% arrange(t_int)
                for (i in which(is.na(w0$tt30))) {
                    if (i == 1) {
                        w0$tt30[1] <- w0 %>% filter(!is.na(tt30)) %>% pull(tt30) %>% head(1)
                    } else {
                        w0$tt30[i] <- mean(w0$tt30[c(i-1, i+1)], na.rm = TRUE)
                    }
                }
                w0
            }) %>% ungroup()

        week0_train <- week0_smry %>%
            filter(weekday == "weekday") %>%
            select(t_int, mean, tt30) %>%
            filter(!is.na(tt30))

        weekX_test <- with(week0_train,
            expand.grid(
                # every 5 mins
                t_int = seq(5, 24, by = 5/60),
                mean = seq(min(mean), max(mean), length = 100)
            )
        ) %>% as_tibble

        fit <- knn.reg(week0_train %>% select(-tt30) %>% scale(),
            weekX_test %>% scale(), y = week0_train %>% pull(tt30),
            k = 10
        )
        weekX_test %>% as_tibble() %>%
            mutate(pred = fit$pred, segment_id = sid)
    }) %>% bind_rows
save(seg_fits, file = "seg_fits.rda")
@

<<tt_week0_grid,cache=TRUE,echo=FALSE,message=FALSE,warning=FALSE,fig.height=10,fig.width=8,fig.align="center",out.width="\\linewidth",fig.cap="Predicted travel time (lighter is longer) in 30 minutes from the current time, given the current state (y-axis).">>=
library(ggplot2)
load("seg_fits.rda")

seg_fits %>% group_by(segment_id) %>%
    do({
        fit <- (.)
        vc <- viridis::viridis(
            max(round(fit$pred)) - min(round(fit$pred)) + 1,
            option = "A"
        )
        fit %>% mutate(col = vc[pred-min(pred)+1])
    }) %>%
    ggplot(aes(t_int, mean)) +
        geom_raster(aes(fill = I(col)), interpolate = TRUE) +
        scale_x_continuous(expand = c(0, 0)) +
        scale_y_continuous(expand = c(0, 0)) +
        facet_grid(segment_id~., scales = "free_y") +
        theme_classic() +
        theme(legend.position = "none") +
        xlab("Time t") + ylab("Road state (seconds)")
@

The next step is to evaluate the predictive power of this approach. We do this by taking the next week of data (shown in \cref{fig:tt_week1_load}) and using the fitted estimates to predict the state in 30~minutes, and then comparing this to the actual state in 30~minutes. Then, we calculate the \gls{rmse}
\begin{equation}\label{eq:rmse}
\text{RMSE} = \sqrt{\frac{1}{N}\sum_{i=1}^N \left(X_i - \hat X_i\right)^2}
\end{equation}
for comparison with other predictive methods (for example, just using the mean).



<<tt_week1_load,cache=TRUE,echo=FALSE,message=FALSE,warning=FALSE,fig.height=8,fig.width=8,fig.align="center",out.width="\\linewidth",fig.cap="Travel times along six roads over the course of two weeks, showing only week days.">>=
library(ggplot2)
source("load_week_data.R")
load("seg_fits.rda")

bind_rows(
    data_week0 %>% mutate(week = "week 1"),
    data_week1 %>% mutate(week = "week 2")
) %>%
    filter(segment_id %in% sids) %>%
    filter(!dow %in% c("Saturday", "Sunday")) %>%
    ggplot(aes(time, travel_time, colour = dow)) +
        geom_point() +
        scale_x_datetime(labels = function(t) format(t, "%l%P")) +
        facet_grid(segment_id~week, scales = "free_y") +
        theme_classic() +
        theme(strip.background = element_blank(), legend.position = "bottom") +
        xlab("Time") + ylab("Travel time (seconds)") +
        scale_colour_brewer(palette = "Dark2") +
        labs(colour = "Day of week")

@

<<tt_week1_pred,cache=TRUE,message=FALSE,warning=FALSE,echo=FALSE,fig.height=8,fig.width=8,fig.align="center",out.width="\\linewidth",fig.cap="Forecasted travel times in 30 minutes versus actual travel times in 30 minutes along segments.">>=
suppressPackageStartupMessages({
    library(ggplot2)
    library(purrr)
})
source("load_week_data.R")
load("seg_fits.rda")

seg_preds <-
    lapply(sids, function(sid) {
        week1_smry <- data_week1 %>%
            filter(segment_id == sid) %>%
            mutate(
                weekday = factor(
                    ifelse(dow %in% c("Saturday", "Sunday"), "weekend", "weekday")
                ),
                t_int = as.integer(format(time, "%H")) +
                    5 * (as.integer(format(time, "%M")) %/% 5) / 60
            ) %>%
            filter(weekday == "weekday") %>%
            group_by(t_int, date) %>%
            summarise(mean = mean(travel_time), e = sd(travel_time), weekday = first(weekday)) %>%
            ungroup() %>%
            mutate(time_30 = t_int + 30/60)

        week1_smry <- week1_smry %>%
            left_join(week1_smry %>% select(t_int, date, mean) %>%
                rename(tt30 = mean),
                by = c("date", "time_30" = "t_int")
            ) %>%
            mutate(segment_id = sid)

        week1_smry %>% select(segment_id, date, t_int, mean, e, tt30)
    }) %>% bind_rows %>% group_by(segment_id) %>%
    do({
        seg_x <- (.)
        cv <- seg_fits %>%
            filter(segment_id == seg_x$segment_id[1]) %>%
            pull(mean) %>% unique()
        seg_x %>% mutate(
            mean_original = mean,
            mean = cut(seg_x$mean, c(0, cv, Inf),
                labels = c(cv[1], cv), right = FALSE) %>%
                as.character() %>% as.numeric %>% round(1)
        )
    }) %>%
    left_join(seg_fits %>% mutate(mean = round(mean, 1)),
        by = c("segment_id", "t_int", "mean")) %>%
    filter(!is.na(tt30) & !is.na(pred) & !is.na(mean_original))

egg::ggarrange(
    ggplot(seg_preds, aes(pred, tt30, colour = date)) +
        geom_point() +
        geom_smooth(aes(colour = NULL), method="lm") +
        facet_wrap(segment_id~., scales = "free", ncol = 1) +
        scale_colour_brewer(palette = "Dark2") +
        xlab("Predicted travel time (sec)") +
        ylab("Observed travel time (sec)") +
        theme_classic() +
        theme(legend.position = "none", strip.background = element_blank()) +
        geom_abline(slope = 1, intercept = 0),
    ggplot(seg_preds, aes(mean_original, tt30, colour = date)) +
        geom_point() +
        geom_smooth(aes(colour = NULL), method="lm") +
        facet_wrap(segment_id~., scales = "free", ncol = 1) +
        scale_colour_brewer(palette = "Dark2") +
        xlab("Predicted travel time (sec)") +
        ylab("Observed travel time (sec)") +
        theme_classic() +
        theme(strip.background = element_blank()) +
        geom_abline(slope = 1, intercept = 0),
    ncol = 2
)

RMSE_forecast <- sqrt(mean(with(seg_preds, pred - tt30)^2, na.rm = TRUE))
RMSE_equal <- sqrt(mean(with(seg_preds, mean_original - tt30)^2, na.rm = TRUE))
@


Forecasts 30~minutes into the future are shown in \cref{fig:tt_week1_pred} for both the grid-search method, as well as the na\"ive method of using the current mean travel time as the predictor. The comparative \gls{rmse} values are displayed in \cref{tab:tt_pred_rmse}, although these are not too different because there is a lot of inherent uncertainty, but shows that we do have a slight increase in predictive performance.


Most importantly, however, is the linear curve (shown in blue in \cref{fig:tt_week1_pred}) compared to the line of equality, in black. The interpretation is that, the more accurate the predictions on average, the closer the blue trend line will be to the black line of equality. For our forecast model, we see that in 5 out of 6 segments the two lines are very close, compared to the na\"ive estimate in which case the predictions are often too high or too low. The only problematic segment is 97, which, looking again at \cref{fig:tt_week1_load}, is caused by an unnormally late peak period. This could have been caused by rain or a road accident.


There is clearly a need for an even more complex forecasting model, which can detect how far into a peak the traffic currently is; but not today.


<<tt_pred_rmse,echo=FALSE,results="asis",cache=TRUE>>=

kable(
    tibble(
        method = c("Simple", "Forecast"),
        RMSE = round(c(RMSE_equal, RMSE_forecast), 2)
    ),
    booktabs = TRUE,
    caption = "RMSE results"
)
@




% \pagebreak
% As in the previous section, we first present the model for a single segment over a week. We are no longer assuming the state is a Markov process; instead, we assume that there is some underlying mean travel time $\mu_\ell$ which the actual travel time fluctuates around. At peak times, there are added morning and evening peak effects, $\rho_{\ell,1}$ and $\rho_{\ell,2}$, respectively. The segment we are examining first exhibits a morning peak, as shown in \cref{fig:tt_week0_load}.
% Weekends are not shown as they do not exhibit ``peak hour'' effects, so we will simply assume constant speed all day\footnote{Future work will look at detecting obvious trends, for example roads around malls may be busier in the middle of the day}.

% The size and width of the peak varies according to how much congestion there is on a particular day, but we expect this magnitude to be similar for the same road segment. Therefore, we assume another \emph{hierarchical} relationship, such that on day $d$ along road segment $d$ for peak $i = 1,2$, the temporal location is
% \begin{equation}\label{eq:peak_effect_day_time}
% \tau_{\ell,d,i}\sim\Normal{\mu_{\tau_{\ell,i}}}{\sigma_{\tau_{\ell,i}}^2},
% \end{equation}
% the magnitude is
% \begin{equation}\label{eq:peak_effect_day_size}
% \rho_{\ell,d,i}\sim\Normal{\mu_{\rho_{\ell,i}}}{\sigma_{\rho_{\ell,i}}^2},
% \end{equation}
% and the width (or length) of the effect is
% \begin{equation}\label{eq:peak_effect_day_length}
% \omega_{\ell,d,i}\sim\Normal{\mu_{\omega_{\ell,i}}}{\sigma_{\omega_{\ell,i}}^2}.
% \end{equation}
% We could, of course, allow a relationship between the morning and evening peaks, but this gets too complicated and will in many cases be unrelated.


% Now the expected travel time at any time of day is given by
% \begin{equation}\label{eq:peak_effect_day_calc}
% \beta_{\ell,d}(t) =
%     \mu_{\ell} + \sum_{i\in\{1,2\}} \pi_{\ell,i}
%     \rho_{\ell,d,i}\exp\left\{{-\frac{(t - \tau_{\ell,d,i})^2}{2\omega_{\ell,d,i}^2}}\right\}
% \end{equation}
% where $\pi_{\ell,i} = \{0,1\}$ indicates whether or not that segment exhibits a peak period.


% The above is fit using JAGS \citep{JAGS}, using noninformative priors for all parameters, to the first segment to ensure model validity before scaling up to include hyperparameters and fitting to all road segments.

% <<tt_week0_seg1_fit,cache=TRUE,echo=FALSE,eval=FALSE>>=
% source("load_week_data.R")
% library(rstan)
% options(mc.cores = 3L)
% rstan_options(auto_write = TRUE)

% wd0 <- data_week0 %>% filter(segment_id == sids[[2]])
% wd0_stan <-
%     list(
%         b = wd0$travel_time,
%         # time in decimal hours should be sufficient
%         t = as.integer(format(wd0$time, "%H")) +
%             as.integer(format(wd0$time, "%M")) / 60,
%         d = as.integer(as.factor(wd0$date)),
%         N = nrow(wd0),
%         M = length(unique(wd0$date))
%     )

% week0_fit <-
%     stan(
%         file = "week_model.stan",
%         data = wd0_stan
%         # init = function() {
%         #     list(
%         #         mu = rnorm(1, median(wd0_stan$b), sd(wd0_stan$b)/sqrt(wd0_stan$N)),
%         #         tau = rnorm(2, c(9, 17), 1),
%         #         rho = runif(2, 100, 200)
%         #     )
%         # }
%     )

% save(week0_fit, file = "week0_samples.rda")
% @

% <<tt_week0_seg1_pars,echo=FALSE,cache=TRUE,fig.height=9,fig.width=6,out.width="\\linewidth",fig.cap="Model output parameters for single segment.",eval=FALSE>>=
% source("load_week_data.R")
% load("week0_samples.rda")

% library(ggplot2)
% library(tidybayes)

% egg::ggarrange(
%     week0_fit %>%
%         spread_draws(mu) %>%
%         ggplot(aes(.iteration, mu, colour = as.factor(.chain), group = .chain)) +
%             geom_path(),
%     week0_fit %>%
%         spread_draws(mu_tau[j]) %>%
%         ggplot(aes(.iteration, mu_tau, colour = as.factor(.chain), group = .chain)) +
%             geom_path() +
%             facet_wrap(~j, scales = "free_y"),
%     week0_fit %>%
%         spread_draws(mu_rho[j]) %>%
%         ggplot(aes(.iteration, mu_rho, colour = as.factor(.chain), group = .chain)) +
%             geom_path() +
%             facet_wrap(~j, scales = "free_y"),
%     week0_fit %>%
%         spread_draws(sigma_tau, sigma_rho) %>%
%         gather(key = "par", value = "value", sigma_tau, sigma_rho) %>%
%         ggplot(aes(.iteration, value, colour = as.factor(.chain), group = .chain)) +
%             geom_path() +
%             facet_wrap(~par, scales = "free_y"),
%     week0_fit %>%
%         spread_draws(omega[j]) %>%
%         ggplot(aes(.iteration, omega, colour = as.factor(.chain), group = .chain)) +
%             geom_path() +
%             facet_wrap(~j, scales = "free_y"),
%     week0_fit %>%
%         spread_draws(pi[j]) %>%
%         ggplot(aes(.iteration, pi, colour = as.factor(.chain), group = .chain)) +
%             geom_path() +
%             facet_wrap(~j, scales = "free_y"),
%     ncol = 1
% )

% @



% <<tt_week0_seg1_plot,echo=FALSE,cache=TRUE,fig.height=9,fig.width=6,out.width="\\linewidth",fig.cap="Model output fitted to data.",eval=FALSE>>=
% source("load_week_data.R")
% load("week0_samples.rda")

% library(ggplot2)
% library(tidybayes)

% mu <- week0_fit %>% spread_draws(mu) %>% pull(mu) %>% median + mean(wd0_stan$b)
% pi <- week0_fit %>% spread_draws(pi[j]) %>% median_qi() %>% pull(pi)
% tau <- week0_fit %>% spread_draws(tau[j,d]) %>% median_qi() %>% pull(tau) %>%
%     matrix(nrow = 2, byrow = TRUE)
% rho <- week0_fit %>% spread_draws(rho[j,d]) %>% median_qi() %>% pull(rho) %>%
%     matrix(nrow = 2, byrow = TRUE)
% omega <- week0_fit %>% spread_draws(omega[j]) %>% median_qi() %>% pull(omega)

% xx <- seq(5, 24, length = 1000)
% calc_tt <- function(t, mu, week, p, tau, omega, rho) {
%     p <- as.integer(p)
%     week <- as.integer(week)
%     y <- mu
%     for (j in 1:2)
%         y <- y + week * p[j] * rho[j] * exp(-(t - tau[j])^2 * 0.5 / omega[j]^2)
%     y
% }

% fit_df <-
%     tibble(
%         x = rep(xx, 7),
%         d = rep(1:7, each = length(xx)),
%         dow = rep(1:7, each = length(xx)),
%     ) %>%
%     group_by(d) %>%
%     do((.) %>%
%         mutate(
%             y = calc_tt(x, mu, dow[1] < 6,
%                 pi > 0.5, tau[,d[1]], omega, rho[,d[1]]
%             )
%         )
%     )

% data_week0 %>% filter(segment_id == sids[[2]]) %>%
%     mutate(
%         t = as.integer(format(time, "%H")) +
%             as.integer(format(time, "%M")) / 60,
%         dow = as.integer(dow)
%     ) %>%
%     ggplot(aes(t, travel_time)) +
%         geom_point() +
%         geom_path(aes(x, y), data = fit_df, colour = "orangered") +
%         # scale_x_datetime(labels = function(t) format(t, "%l%P")) +
%         facet_grid(dow~.) +
%         theme_classic() +
%         theme(strip.background = element_blank()) +
%         xlab("Time") + ylab("Travel time (seconds)")

% @

% For the segment parameters, we assume a hierarchical model on the temporal location and width, with hyperparameters common across all segments in the network, while the magnitude will be independent for each segment. This leads to the following model:
% \begin{equation}\label{eq:peak_effect_model}
% \begin{split}
% \mu_{\tau_{\ell,i}} &\sim \Normal{\mu_{\tau_i}}{\sigma_{\tau_i}}\\
% \mu_{\omega_{\ell,i}} &\sim \Normal{\mu_{\omega_i}}{\sigma_{\omega_i}}.
% \end{split}
% \end{equation}

% And then we fit the model using JAGS \citep{JAGS}.
