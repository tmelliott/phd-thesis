\section{Constructing a transit network model}
\label{sec:nw_hist_prior}



The relationship between the underlying travel time
and the value we estimate (back in chapter 3) involves two steps.
First, we must describe the relationship between the underlying travel time
and the \emph{actual}  time taken.
Secondly, we define the relationship between \emph{actual} and \emph{observed}
(or, more specifically, estimated) travel time.
This type of model is often called a \emph{heirarchical Bayesian model}.


First, we present the relationship at a fixed time $t_c$.
We define $\NWstate_{\ell c}$ to be the average travel time of vehicles
along road segment $\ell$ at time $t_c$,
and $\NWvar_{\ell c}^2$ as the associated variance (\emph{between} vehicles).
Now, the time taken for vehicle $m$ to travel along
road $\ell$ at time $t_c$ is $\Vtt_{\ell c}^m$ seconds---%
to avoid complications we define the time a vehicle travels along a road
as the time that it reaches the end of the road.
Assuming that vehicle travel times follow a normal distribution,
we write this as
\begin{equation*}
    \Vtt_{\ell c}^m \sim
        \Normal{\NWstate_{\ell c}}{\NWvar_{\ell c}^2}
\end{equation*}
Once the bus reaches the end of the road and reports its position to us,
we estimate (see section 3.3) how long it took,
which is a noisy ``measurement'' of the time it \emph{actually} took,
which we assume has an error of $\Vtterr_{\ell c}^m$ seconds.
Again, assuming the errors follow a normal distribution,
we write the observation as
\begin{equation*}
\Vttobs_{\ell c}^m \sim
    \Normal{\Vtt_{\ell c}^m}{(\Vtterr_{\ell c}^m)^2}.
\end{equation*}

Secondly, we need to consider that travel time changes over time for various reasons.
The obvious one is congestion at peak times
when lots of people are commuting (many in cars) to or from work,
but throughout the day there can be fluctuations in traffic flow
due to intersections, incidents, weather, or countless other causes.
To model this, we need to account for
\emph{systematic, predictable changes}, that is, congestion at peak times,
and \emph{random changes}, which accounts for everything else.
The systematic part, or trend, can be described
using a transition function (or matrix) $\NWtransfun_c$,
which, given the state at time $t_{c-1}$ predicts the state at time $t_c$.
As for the random fluctuations, these are encapsulated by the model parameter $\NWnoise$,
which can be interpreted as \emph{the rate of change of travel time}.
Together, again assuming that the state follows a normal distribution,
then we write
\begin{equation*}
    \NWstate_{\ell c} \sim
        \Normal{\NWstate_{\ell c-1}}{(\NWtdiff_c \NWnoise)^2},
\end{equation*}
where $\NWtdiff_c = t_c - t_{c-1}$.

However, we can describe the model with more detail than this.
Let us assume that the \emph{fastest possible travel time} along a road is denoted $\NWmaxtt_\ell$,
which would be obtained by a vehicle travelling at the posted speed limit along the entire road.
Now $\NWstate_{\ell c}$ is the additional travel time caused by congestion,
driver behaviour, and so on, leading to
\begin{equation*}
    \Vtt_{\ell c}^m \sim
        \Normal{\NWmaxtt_\ell + \NWstate_{\ell c}}{\NWvar_{\ell c}^2}
\end{equation*}
for individual vehicles.

<<tt_figure,echo=FALSE,fig.height=3,fig.width=6,out.width=".9\\linewidth",fig.cap="Travel times along a road.">>=
library(ggplot2)
source("load_nw_data.R")

ggplot(tts, aes(arrival_time, travel_time)) +
    geom_point() +
    geom_hline(yintercept = 43, lty = 2) +
    theme_classic() +
    xlab("Time") + ylab("Travel time (seconds)")
@

Now that we have a model, we can take a look at some data.
\Cref{fig:tt_figure} shows the travel times
between two stops on Symonds Street in central Auckland.
We know that the maximum speed limit along this road is 50~km/h,
which is approximately \Sexpr{ceiling(50*1000/60/60)}~m/s.
The distance between the two stops is 610~m,
so we know the minimum possible travel time is
$\lfloor\frac{610}{14}\rfloor = \Sexpr{floor(610/14)}$~seconds.

The first model we fit, N1, uses the transition function
\begin{equation*}
\NWtransfun(\NWstate_{\ell c}) = \NWstate_{\ell c-1}.
\end{equation*}
We used JAGS \citep{JAGS} to fit the hierarchical model described above,
using the following values and priors:
\begin{equation}
\label{eq:nw_model_n1_priors}
\begin{split}
\NWmaxtt_\ell &= \Sexpr{floor(610/14)} \\
\NWstate_{\ell 1} &\sim
    \GammaD{0.001}{0.001} \\
\NWvar_\ell^2 &\sim \Uniform{0}{1000} \\
(\Vtterr_{\ell c}^m)^2 &\sim \GammaD{0.001}{0.001}
    \quad\forall c \\
\NWnoise^2 &\sim \GammaD{0.001}{0.001}
\end{split}
\end{equation}

The model implementation was completed within R
using the \verb+rjags+ package \citep{rjags},
and model output was processed and graphed
using the \verb+tidybayes+ package \citep{tidybayes}
and \verb+ggplot2+ \citep{ggplot2}.
Traceplots of the first eight $\NWstate$ parameters,
as well as for $\NWvar$ and $\NWnoise$ are displayed in \cref{fig:nw_model_n1_view}.

<<nw_model_n1_fit,cache=TRUE,echo=FALSE,message=FALSE>>=
library(rjags)
library(tidybayes)
library(ggplot2)

source("load_nw_data.R")

segdata <-
    list(
        b = tts$travel_time,
        t = as.integer(as.factor(t30)),
        delta = diff(sort(unique(as.integer(t30)))),
        N = nrow(tts),
        M = length(unique(t30)),
        mu = mu[1]
    )

# plot(t30, segdata$b)
# with(segdata, plot(sort(unique(t30))[t], b))

n1_model <- "
model {
    for (i in 1:N) {
        b[i] ~ dnorm(B[i], pow(E, -1))
        B[i] ~ dnorm(mu + beta[t[i]], pow(phi, -1))
    }

    beta[1] ~ dunif(0, 500)
    for (j in 2:M) {
        beta[j] ~ dnorm(beta[j-1], pow(pow(delta[j-1], 2) * q, -1))T(0,)
    }

    phi ~ dgamma(0.01, 0.01)
    q ~ dgamma(0.01, 0.01)
    E <- 9
}
"

t0 <- proc.time()
n1_fit <-
    jags.model(
        textConnection(n1_model),
        data = segdata,
        n.chains = 4,
        n.adapt = 10000,
        quiet = TRUE
    )

n1_samples <-
    coda.samples(n1_fit,
        variable.names = c("beta", "phi", "q"),
        n.iter = 5000,
        thin = 5
    )
time_mcmc <- proc.time() - t0
@

<<nw_model_n1_view,cache=TRUE,echo=FALSE,fig.height=9,fig.width=6,out.width="\\linewidth",fig.cap="Model output.">>=
egg::ggarrange(
    n1_samples %>% spread_draws(beta[t]) %>%
        filter(t < 9) %>%
        ggplot(aes(.iteration, beta, colour = as.factor(.chain), group = .chain)) +
            geom_path() +
            facet_wrap(~t, scales = "free", nrow = 4),

    n1_samples %>% spread_draws(phi) %>%
        ggplot(aes(.iteration, (phi), colour = as.factor(.chain), group = .chain)) +
            geom_path(),

    n1_samples %>% spread_draws(q) %>%
        ggplot(aes(.iteration, (q), colour = as.factor(.chain), group = .chain)) +
            geom_path(),

    # n1_samples %>% spread_draws(E) %>%
    #     ggplot(aes(.iteration, sqrt(E), colour = as.factor(.chain), group = .chain)) +
    #         geom_path(),

    ncol = 1, heights = c(2, 1, 1)
)
@

<<nw_model_n1_fitted,cache=TRUE,echo=FALSE,fig.height=3,fig.width=6,out.width="0.9\\linewidth",fig.cap="Travel times with fitted betas">>=
n1_samples %>%
    spread_draws(beta[t]) %>%
    sample_draws(n = 20) %>%
    #median_qi(beta) %>%
    mutate(timestamp = sort(unique(t30))[t]) %>%
    ggplot(aes(timestamp, segdata$mu + beta)) +
        geom_point(aes(arrival_time, travel_time),
            data = tts, col = "red") +
        geom_path(aes(group = .draw)) +
        geom_hline(yintercept = 43, lty = 2) +
        theme_classic() +
        xlab("Time") + ylab("Travel time (seconds)")
@

Fitting the model allowed us to estimate values for $\NWvar$ and $\NWnoise$
for a single road segment.
It is then possible to fit a \rt{} version of the same model to the same data
using these tuning parameters to see how well it performs.
Since the \kf{} does not allow the hierarchical structure we described earlier,
we combined the between-vehicle noise with measurement error,
so, from normal theory, the observation variance is simply the
sum of the two variances,
\begin{equation}
    \Vttobs_{\ell c}^m \sim
        \Normal{\Vtt_{\ell c}^m}{\NWvar_{\ell}^2 + (\Vtterr_{\ell c}^m)^2}
\end{equation}
which we can fit using a standard \kf{}.

<<nw_model_n1_kf,cache=TRUE,echo=FALSE,fig.height=3,fig.width=6,out.width="0.9\\linewidth",fig.cap="Travel times with KF fit">>=
source("load_nw_data.R")
N <- nrow(tts)
M <- length(unique(t30))
kf.fit <-
    tibble(
        time = sort(unique(t30)),
        delta = c(0, diff(sort(unique(t30)))),
        beta = rep(NA_real_, (M)),
        beta_hat = rep(NA_real_, (M)),
        P = rep(NA_real_, (M)),
        P_hat = rep(NA_real_, (M)),
        B_hat = 1 / P_hat,
        b_hat = beta_hat / P_hat,
        B = 1 / P,
        b = beta / P
    )

kf.fit$beta[1] <- 50
kf.fit$P[1] <- 500

q <- sqrt(0.009)
phi <- sqrt(1300)
mu <- 43

# convert all data to information
kf.data <-
    tibble(
        time = t30,
        t = as.integer(as.factor(t30)),
        b = tts$travel_time - mu,
        E = 3.0
    ) %>% mutate(
        I = 1 / (E^2 + phi^2),
        i = b / (E^2 + phi^2)
    ) %>% arrange(t)

kf.fit <- kf.fit %>%
    left_join(
        kf.data %>% group_by(t) %>%
            summarize(time = first(time), Z = sum(I), z = sum(i)),
        by = "time"
    )

t0 <- proc.time()
for (i in 2:M) {
    # predict
    kf.fit$beta_hat[i] <- kf.fit$beta[i-1]
    kf.fit$P_hat[i] <- kf.fit$P[i-1] + (kf.fit$delta[i] + q)^2

    # update
    kf.fit$B_hat[i] <- 1 / kf.fit$P_hat[i]
    kf.fit$b_hat[i] <- kf.fit$beta_hat[i] / kf.fit$P_hat[i]
    kf.fit$B[i] <- kf.fit$B_hat[i] + kf.fit$Z[i]
    kf.fit$b[i] <- kf.fit$b_hat[i] + kf.fit$z[i]

    # untransform
    kf.fit$beta[i] <- kf.fit$b[i] / kf.fit$B[i]
    kf.fit$P[i] <- 1 / kf.fit$B[i]
}
time_kf <- proc.time () - t0

library(ggplot2)

ggplot(kf.fit[-1,], aes(time)) +
    geom_point(aes(y = mu + b), data = kf.data) +
    geom_ribbon(aes(
            ymin = mu + truncnorm::qtruncnorm(0.025, 0, Inf, beta_hat, sqrt(P_hat)),
            ymax = mu + truncnorm::qtruncnorm(0.975, 0, Inf, beta_hat, sqrt(P_hat))
        ),
        fill = "blue", alpha = 0.2) +
    geom_path(aes(y = mu + beta_hat), col = "blue") +
    geom_ribbon(aes(
            ymin = mu + truncnorm::qtruncnorm(0.025, 0, Inf, beta, sqrt(P)),
            ymax = mu + truncnorm::qtruncnorm(0.975, 0, Inf, beta, sqrt(P))
        ),
        fill = "red", alpha = 0.2) +
    geom_path(aes(y = mu + beta), col = "red") +
    theme_classic() +
    xlab("Time") + ylab("Travel time (seconds)")
@

<<nw_model_n1_kf_pred,cache=TRUE,echo=FALSE,fig.height=3,fig.width=6,out.width="0.9\\linewidth",fig.cap="Travel times predictive distribution from KF fit">>=
ggplot(kf.fit[-1,], aes(time)) +
    geom_point(aes(y = mu + b), data = kf.data) +
    # geom_ribbon(aes(
    #         ymin = mu + pmax(0, qnorm(0.025, beta_hat, sqrt(P_hat))),
    #         ymax = mu + qnorm(0.975, beta_hat, sqrt(P_hat))
    #     ),
    #     fill = "blue", alpha = 0.2) +
    # geom_path(aes(y = mu + beta_hat), col = "blue") +
    geom_ribbon(aes(
            ymin = mu + truncnorm::qtruncnorm(0.025, 0, Inf, beta, sqrt(P) + phi),
            ymax = mu + truncnorm::qtruncnorm(0.975, 0, Inf, beta, sqrt(P) + phi)
        ),
        fill = "red", alpha = 0.2) +
    geom_path(aes(y = mu + beta), col = "red") +
    theme_classic() +
    xlab("Time") + ylab("Travel time (seconds)")
@

From \cref{fig:nw_model_n1_kf}, we see a fairly similar pattern
to the estimate of $\NWstate_{\ell,1:T}$,
although the peak estimation is less extreme
and slightly delayed.
The predictive travel time distribution,
which accounts for uncertainty in $\NWstate_{\ell c}$ and vehicle variation, $\NWvar_{\ell c}$,
is shown in \cref{fig:nw_model_n1_kf_pred}.
However, considering the \kf{} model is assuming constant travel time over time,
this makes sense,
as the \kf{} is a \emph{noise filtering} technique.


Most importantly is the timing comparison,
which is shown in \cref{tab:nw_model_n1_timecomp}.
The hierarchical model fit using JAGS took
\Sexpr{round(time_mcmc[3] / time_kf[3])} times as long as the \kf{} implementation.
So, even if we reduced the number of chains, the number of iterations,
and tried to speed up the JAGS model,
we would never get it close to the \kf{} result.

<<nw_model_n1_timecomp,echo=FALSE,results="asis">>=
kable(rbind(time_mcmc, time_kf)[,1:3],
    booktabs = TRUE,
    caption = "Timing results")
@

\kf{}'s can implement non-constant transitions between states,
for example by modifying $\NWtrans_c$ over time.


\subsubsection{Investigating a selection of road segments}

To assess how effective this method is for estimating $\NWvar$ and $\NWnoise$,
we selected five other road segments around Auckland
and repeated the above process.
We fit the same JAGS model, using the same number of iterations for each,
which worked in most cases.
Each segment was modelled independently.
The travel time data is shown in \cref{fig:nw_model_n2_segplots}.

<<nw_model_n2_segplots,echo=FALSE,cache=TRUE,fig.width=6,fig.height=9,out.width="0.8\\textwidth",fig.cap="Travel times along 5 roads throughout Auckland.">>=
source("load_nw_data.R")
library(ggplot2)

data.list <- lapply(c(2, 3, 5, 9, 11), function(i) {
    tts <- tt_all %>% filter(stop_id == seg_table[i, 1])
    t30 <- paste(sep = ":",
        format(tts$arrival_time,
            "%Y-%m-%d %H"),
        format(tts$arrival_time, "%M") %>%
            as.integer %>% `%/%`(5) %>% `*`(5) %>%
            stringr::str_pad(2, pad = "0")
    ) %>% as.POSIXct
    attr(tts, "t30") <- t30
    attr(tts, "mu") <- mu[i]
    tts
})

do.call(egg::ggarrange, c(
    lapply(data.list, function(tts) {
        ggplot(tts, aes(arrival_time, travel_time)) +
            geom_point() +
            geom_hline(yintercept = attr(tts, "mu"), lty = 2) +
            theme_classic() +
            xlab("Time") + ylab("Travel time (seconds)")
    }),
    ncol = 1
))
@

<<nw_model_nw_jagsfits,echo=FALSE,cache=TRUE>>=
library(rjags)
library(tidybayes)

all.fits <- lapply(data.list, function(tts) {
    t30 <- attr(tts, "t30")
    segdata <-
        list(
            b = tts$travel_time,
            t = as.integer(as.factor(t30)),
            delta = diff(sort(unique(as.integer(t30)))),
            N = nrow(tts),
            M = length(unique(t30)),
            mu = attr(tts, "mu")
        )

    # plot(t30, segdata$b)
    # with(segdata, plot(sort(unique(t30))[t], b))

    n1_model <- "
    model {
        for (i in 1:N) {
            b[i] ~ dnorm(B[i], pow(E, -1))
            B[i] ~ dnorm(mu + beta[t[i]], pow(phi, -1))
        }

        beta[1] ~ dunif(0, 500)
        for (j in 2:M) {
            beta[j] ~ dnorm(beta[j-1], pow(pow(delta[j-1], 2) * q, -1))T(0,)
        }

        phi ~ dgamma(0.01, 0.01)
        #q ~ dgamma(0.01, 0.01)
        log_q ~ dnorm(0, 0.1)
        eq <- exp(log_q)
        q <- pow(eq, 2)
        E <- 9
    }
    "


    t0 <- proc.time()
    n1_fit <-
        jags.model(
            textConnection(n1_model),
            data = segdata,
            n.chains = 4,
            n.adapt = 10000,
            quiet = TRUE
        )

    n1_samples <-
        coda.samples(n1_fit,
            variable.names = c("beta", "phi", "q"),
            n.iter = 5000,
            thin = 5
        )
    time_mcmc <- proc.time() - t0

    attr(n1_samples, "time") <- time_mcmc

    n1_samples
})
@

<<nw_model_n2_diag,cache=TRUE,echo=FALSE,fig.width=8,fig.height=9,out.width="\\textwidth",fig.cap="Traceplots of network parameters for each segment.">>=

do.call(egg::ggarrange, c(
    do.call(c, lapply(all.fits, function(n1_samples) {
        list(
            n1_samples %>% spread_draws(phi) %>%
                ggplot(aes(.iteration, phi, colour = as.factor(.chain), group = .chain)) +
                    geom_path() +
                    xlab("Iteration") +
                    theme_classic() + theme(legend.position = "none") +
                    ylab(expression(psi)),

            n1_samples %>% spread_draws(q) %>%
                ggplot(aes(.iteration, q, colour = as.factor(.chain), group = .chain)) +
                    geom_path() +
                    xlab("Iteration") +
                    theme_classic() +
                    labs(colour = "Chain")
        )
    })),
    list(ncol = 2)
))
@

<<nw_model_n2_resfits,cache=TRUE,echo=FALSE,fig.width=6,fig.height=9,out.width="0.8\\textwidth",fig.cap="Sample of posterior fits to segment travel times.">>=

do.call(egg::ggarrange, c(
    lapply(seq_along(all.fits), function(i) {
        tts <- data.list[[i]]
        t30 <- attr(tts, "t30")
        n1_samples <- all.fits[[i]]
        mu <- attr(tts, "mu")

        n1_samples %>%
            spread_draws(beta[t]) %>%
            sample_draws(n = 20) %>%
            #median_qi(beta) %>%
            mutate(timestamp = sort(unique(t30))[t]) %>%
            ggplot(aes(timestamp, mu + beta)) +
                geom_point(aes(arrival_time, travel_time),
                    data = tts, col = "red") +
                geom_path(aes(group = .draw)) +
                geom_hline(yintercept = 43, lty = 2) +
                theme_classic() +
                xlab("Time") + ylab("Travel time (seconds)")
    }),
    ncol = 1
))
@

<<nw_model_n2_kf,echo=FALSE,cache=TRUE,fig.width=8,fig.height=9,out.width="\\textwidth",fig.cap="Kalman filter results from real-time fitting, showing travel time estimate (left) and posterior predictive travel time (right).">>=

do.call(egg::ggarrange, c(
    do.call(c, lapply(seq_along(all.fits), function(i) {
        tts <- data.list[[i]]
        t30 <- attr(tts, "t30")
        n1_samples <- all.fits[[i]]

        N <- nrow(tts)
        M <- length(unique(t30))
        kf.fit <-
            tibble(
                time = sort(unique(t30)),
                delta = c(0, diff(sort(unique(t30)))),
                beta = rep(NA_real_, (M)),
                beta_hat = rep(NA_real_, (M)),
                P = rep(NA_real_, (M)),
                P_hat = rep(NA_real_, (M)),
                B_hat = 1 / P_hat,
                b_hat = beta_hat / P_hat,
                B = 1 / P,
                b = beta / P
            )

        kf.fit$beta[1] <- mean(as.matrix(n1_samples)[,"beta[1]"])
        kf.fit$P[1] <- 500

        q <- sqrt(mean(as.matrix(n1_samples)[,"q"]))
        phi <- sqrt(mean(as.matrix(n1_samples)[,"phi"]))
        mu <- attr(tts, "mu")

        # convert all data to information
        kf.data <-
            tibble(
                time = t30,
                t = as.integer(as.factor(t30)),
                b = tts$travel_time - mu,
                E = 3.0
            ) %>% mutate(
                I = 1 / (E^2 + phi^2),
                i = b / (E^2 + phi^2)
            ) %>% arrange(t)

        kf.fit <- kf.fit %>%
            left_join(
                kf.data %>% group_by(t) %>%
                    summarize(time = first(time), Z = sum(I), z = sum(i)),
                by = "time"
            )

        t0 <- proc.time()
        for (i in 2:M) {
            # predict
            kf.fit$beta_hat[i] <- kf.fit$beta[i-1]
            kf.fit$P_hat[i] <- kf.fit$P[i-1] + (kf.fit$delta[i] + q)^2

            # update
            kf.fit$B_hat[i] <- 1 / kf.fit$P_hat[i]
            kf.fit$b_hat[i] <- kf.fit$beta_hat[i] / kf.fit$P_hat[i]
            kf.fit$B[i] <- kf.fit$B_hat[i] + kf.fit$Z[i]
            kf.fit$b[i] <- kf.fit$b_hat[i] + kf.fit$z[i]

            # untransform
            kf.fit$beta[i] <- kf.fit$b[i] / kf.fit$B[i]
            kf.fit$P[i] <- 1 / kf.fit$B[i]
        }
        time_kf <- proc.time () - t0

        library(ggplot2)

        list(
            # n1_samples %>%
            #     spread_draws(beta[t]) %>%
            #     sample_draws(n = 20) %>%
            #     #median_qi(beta) %>%
            #     mutate(timestamp = sort(unique(t30))[t]) %>%
            #     ggplot(aes(timestamp, mu + beta)) +
            #         geom_point(aes(arrival_time, travel_time),
            #             data = tts, col = "red") +
            #         geom_path(aes(group = .draw)) +
            #         geom_hline(yintercept = mu, lty = 2) +
            #         theme_classic() +
            #         xlab("Time") + ylab("Travel time (seconds)"),

            ggplot(kf.fit[-1,], aes(time)) +
                geom_point(aes(y = mu + b), data = kf.data) +
                geom_ribbon(aes(
                        ymin = mu + truncnorm::qtruncnorm(0.025, 0, Inf, beta_hat, sqrt(P_hat)),
                        ymax = mu + truncnorm::qtruncnorm(0.975, 0, Inf, beta_hat, sqrt(P_hat))
                    ),
                    fill = "blue", alpha = 0.2) +
                geom_path(aes(y = mu + beta_hat), col = "blue") +
                geom_ribbon(aes(
                        ymin = mu + truncnorm::qtruncnorm(0.025, 0, Inf, beta, sqrt(P)),
                        ymax = mu + truncnorm::qtruncnorm(0.975, 0, Inf, beta, sqrt(P))
                    ),
                    fill = "red", alpha = 0.2) +
                geom_path(aes(y = mu + beta), col = "red") +
                theme_classic() +
                xlab("Time") + ylab("Travel time (seconds)"),

            ggplot(kf.fit[-1,], aes(time)) +
                geom_point(aes(y = mu + b), data = kf.data) +
                geom_ribbon(aes(
                        ymin = mu + truncnorm::qtruncnorm(0.025, 0, Inf, beta, sqrt(P) + phi),
                        ymax = mu + truncnorm::qtruncnorm(0.975, 0, Inf, beta, sqrt(P) + phi)
                    ),
                    fill = "red", alpha = 0.2) +
                geom_path(aes(y = mu + beta), col = "red") +
                theme_classic() +
                xlab("Time") + ylab("Travel time (seconds)")
        )
    })),
    ncol = 2
))
@

For most of them, despite a range of features,
the JAGS-estimated values of $\NWvar$ and $\NWnoise$ were well suited
for the \rt{} \kf{} implementation.
The traceplots are shown in \cref{fig:nw_model_n2_diag},
and a posterior sample of $\NWstate_{1:C}$ is shown in \cref{fig:nw_model_n2_resfits}.
For all segments, $\NWvar$ was sampled well;
however, $\NWnoise$ often had difficulties due to the zero-boundary.


We then took the posterior mean from the JAGS samples to estimate values
for $\NWvar$ and $\NWnoise$ for each segment,
and fit the \rt{} \kf{} as before.
\Cref{fig:nw_model_n2_kf} shows the estimates of
the predicted and updated network state and associated variances,
along with the predictive distribution (mean + uncertainty + between vehicle noise).


A better examination, however, is to look at data from a different day
for the same segment.

Should try fitting a single value of q and only estimate psi.


\newpage
\subsubsection*{Old}
In order to improve short-term predictions for the \kf{},
and also longer-term forecasts for arrival time prediction
(\cref{cha:prediction}),
we need to be model patterns in travel times over time.
This is particularly obvious around peak times,
where there is a general trend of increased travel time
along roads,
particularly those city-bound in morning peak,
and out-bound in evening peak,
although many roads experience congestion during both peaks.


The aim of this section is to estimate $\NWhistmean{}{t}$ and $\NWhistvar{}{t}$.
The first step to doing this is estimating the traffic speed
$\NWstate_{\ell,0:C}$,
which we did in \cref{sec:nw_par_est}.
