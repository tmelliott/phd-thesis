\section{Improving forecasts with history}
\label{sec:nw_hist_model}

The model presented in the previous sections is adequate for estimating the \emph{real-time} state of the network, but when it comes to forecasting road travel times, it becomes unuseful, particularly just before or after a peak period. In the next chapter, we will be predicting arrival time, which will involve making short-term forecasts of travel time. To do so, we will use historical data to detect the average temporal location and magnitude of travel time peaks.

From \cref{nw_par_est_real} we saw that roads typically have a peak effect either in the morning or in the evening, while some are affected by both morning and afternoon traffic. It seems reasonable therefore to have a model which allows a segment to have zero, one, or two peaks, each with varying magnitude (the size of the increase in travel time) and width (how long the peak period is). The temporal location of these peaks is likely to be related, but variable: some roads will experience peak traffic earlier than others, for example.

<<tt_week0_load,cache=TRUE,echo=FALSE,fig.height=9,fig.width=8,fig.align="center",out.width="\\linewidth",fig.cap="Travel times along six roads over one week, coloured by the day of the week. Weekends aren't shown.">>=
library(ggplot2)
source("load_week_data.R")

data_week0 %>% filter(segment_id %in% sids) %>%
    filter(!dow %in% c("Saturday", "Sunday")) %>%
    ggplot(aes(time, travel_time, colour = dow)) +
        geom_point() +
        scale_x_datetime(labels = function(t) format(t, "%l%P")) +
        facet_grid(segment_id~., scales = "free_y") +
        theme_classic() +
        theme(strip.background = element_blank()) +
        xlab("Time") + ylab("Travel time (seconds)") +
        scale_colour_brewer(palette = "Dark2") +
        labs(colour = "Day of week")

@

As in the previous section, we first present the model for a single segment over a week. We are no longer assuming the state is a Markov process; instead, we assume that there is some underlying mean travel time $\mu_\ell$ which the actual travel time fluctuates around. At peak times, there are added morning and evening peak effects, $\rho_{\ell,1}$ and $\rho_{\ell,2}$, respectively. The segment we are examining first exhibits a morning peak, as shown in \cref{fig:tt_week0_load}.
Weekends are not shown as they do not exhibit ``peak hour'' effects, so we will simply assume constant speed all day\footnote{Future work will look at detecting obvious trends, for example roads around malls may be busier in the middle of the day}.

The size and width of the peak varies according to how much congestion there is on a particular day, but we expect this magnitude to be similar for the same road segment. Therefore, we assume another \emph{hierarchical} relationship, such that on day $d$ along road segment $d$ for peak $i = 1,2$, the temporal location is
\begin{equation}\label{eq:peak_effect_day_time}
\tau_{\ell,d,i}\sim\Normal{\mu_{\tau_{\ell,i}}}{\sigma_{\tau_{\ell,i}}^2},
\end{equation}
the magnitude is
\begin{equation}\label{eq:peak_effect_day_size}
\rho_{\ell,d,i}\sim\Normal{\mu_{\rho_{\ell,i}}}{\sigma_{\rho_{\ell,i}}^2},
\end{equation}
and the width (or length) of the effect is
\begin{equation}\label{eq:peak_effect_day_length}
\omega_{\ell,d,i}\sim\Normal{\mu_{\omega_{\ell,i}}}{\sigma_{\omega_{\ell,i}}^2}.
\end{equation}
We could, of course, allow a relationship between the morning and evening peaks, but this gets too complicated and will in many cases be unrelated.


Now the expected travel time at any time of day is given by
\begin{equation}\label{eq:peak_effect_day_calc}
\beta_{\ell,d}(t) =
    \mu_{\ell} + \sum_{i\in\{1,2\}} \pi_{\ell,i}
    \rho_{\ell,d,i}\exp\left\{{-\frac{(t - \tau_{\ell,d,i})^2}{2\omega_{\ell,d,i}^2}}\right\}
\end{equation}
where $\pi_{\ell,i} = \{0,1\}$ indicates whether or not that segment exhibits a peak period.


The above is fit using JAGS \citep{JAGS}, using noninformative priors for all parameters, to the first segment to ensure model validity before scaling up to include hyperparameters and fitting to all road segments.

<<tt_week0_seg1_fit,cache=TRUE,echo=FALSE,eval=FALSE>>=
source("load_week_data.R")
library(rstan)
options(mc.cores = 3L)
rstan_options(auto_write = TRUE)

wd0 <- data_week0 %>% filter(segment_id == sids[[1]])
wd0_stan <-
    list(
        b = wd0$travel_time,
        # time in decimal hours should be sufficient
        t = as.integer(format(wd0$time, "%H")) +
            as.integer(format(wd0$time, "%M")) / 60,
        d = as.integer(as.factor(wd0$date)),
        N = nrow(wd0),
        M = length(unique(wd0$date))
    )

week0_fit <-
    stan(
        file = "week_model.stan",
        data = wd0_stan
        # init = function() {
        #     list(
        #         mu = rnorm(1, median(wd0_stan$b), sd(wd0_stan$b)/sqrt(wd0_stan$N)),
        #         tau = rnorm(2, c(9, 17), 1),
        #         rho = runif(2, 100, 200)
        #     )
        # }
    )

week0_fit


week_model <- "
model{
    for (i in 1:N) {
        b_hat[i] <- mu +
            week[i] * p[1] * rho[d[i],1] *
                exp(-pow(t[i] - tau[d[i],1], 2) * 0.5 * pow(omega[d[i],1], -2)) +
            week[i] * p[2] * rho[d[i],2] *
                exp(-pow(t[i] - tau[d[i],2], 2) * 0.5 * pow(omega[d[i],2], -2))
        b[i] ~ dnorm(b_hat[i], pow(err, -2))
    }

    mu ~ dunif(0, 500)
    mu_tau[1] ~ dnorm(9, pow(3, -2))
    mu_tau[2] ~ dnorm(18, pow(3, -2))
    for (j in 1:2) {
        p[j] ~ dbern(pi[j])
        pi[j] ~ dbeta(0.001, 0.001)

        mu_rho[j] ~ dnorm(100, 0.001)
        sigma_rho[j] ~ dgamma(0.1, 0.1)

        mu_omega[j] ~ dunif(0.1, 3)
        # sigma_omega[j] ~ dgamma(0.001, 0.001)

        sigma_tau[j] ~ dgamma(0.1, 0.1)

        for (l in 1:M) {
            rho[l,j] ~ dnorm(mu_rho[j], pow(sigma_rho[j], -2))
            #omega[l,j] ~ dnorm(mu_omega[j], pow(sigma_omega[j], -2))T(0,)
            omega[l,j] <- mu_omega[j]
            tau[l,j] ~ dnorm(mu_tau[j], pow(sigma_tau[j], -2))
        }
    }

    err ~ dgamma(0.001, 0.001)
}"

save(week0_samples, file = "week0_samples.rda")
@

<<tt_week0_seg1_pars,echo=FALSE,cache=TRUE,fig.height=9,fig.width=6,out.width="\\linewidth",fig.cap="Model output parameters for single segment.",eval=FALSE>>=
source("load_week_data.R")
load("week0_samples.rda")

library(ggplot2)
library(tidybayes)

egg::ggarrange(
    week0_fit %>%
        spread_draws(mu) %>%
        ggplot(aes(.iteration, mu, colour = as.factor(.chain), group = .chain)) +
            geom_path(),
    week0_fit %>%
        spread_draws(mu_tau[j]) %>%
        ggplot(aes(.iteration, mu_tau, colour = as.factor(.chain), group = .chain)) +
            geom_path() +
            facet_wrap(~j, scales = "free_y"),
    week0_fit %>%
        spread_draws(mu_rho[j]) %>%
        ggplot(aes(.iteration, mu_rho, colour = as.factor(.chain), group = .chain)) +
            geom_path() +
            facet_wrap(~j, scales = "free_y"),
    week0_fit %>%
        spread_draws(omega[j]) %>%
        ggplot(aes(.iteration, omega, colour = as.factor(.chain), group = .chain)) +
            geom_path() +
            facet_wrap(~j, scales = "free_y"),
    week0_fit %>%
        spread_draws(pi[j]) %>%
        ggplot(aes(.iteration, pi, colour = as.factor(.chain), group = .chain)) +
            geom_path() +
            facet_wrap(~j, scales = "free_y"),
    ncol = 1
)

@



<<tt_week0_seg1_plot,echo=FALSE,cache=TRUE,fig.height=9,fig.width=6,out.width="\\linewidth",fig.cap="Model output fitted to data.",eval=FALSE>>=
source("load_week_data.R")
load("week0_samples.rda")

library(ggplot2)
library(tidybayes)

mu <- week0_fit %>% spread_draws(mu) %>% pull(mu) %>% median
peak_pars <- week0_fit %>% spread_draws(pi[j], rho[j], tau[j], omega[j]) %>%
    median_qi() %>% select(j, pi, rho, tau, omega)
xx <- seq(5, 24, length = 1000)
calc_tt <- function(t, mu, week, p, tau, omega, rho) {
    p <- as.integer(p)
    week <- as.integer(week)
    y <- mu
    for (j in 1:2)
        y <- y + week * p[j] * rho[j] * exp(-(t - tau[j])^2 * 0.5 / omega[j]^2)
    y
}

plot(calc_tt(xx, mu, 1, peak_pars$pi>0.5, peak_pars$tau, peak_pars$omega, peak_pars$rho))

fit_df <-
    tibble(
        x = rep(xx, 7),
        dow = rep(1:7, each = length(xx)),
    ) %>% mutate(
        y = calc_tt(x, mu, dow < 6,
                peak_pars$pi > 0.5, peak_pars$tau, peak_pars$omega, peak_pars$rho
            )
    )

data_week0 %>% filter(segment_id == sids[[1]]) %>%
    mutate(
        t = as.integer(format(time, "%H")) +
            as.integer(format(time, "%M")) / 60,
        dow = as.integer(dow)
    ) %>%
    ggplot(aes(t, travel_time)) +
        geom_point() +
        geom_path(aes(x, y), data = fit_df, colour = "orangered") +
        # scale_x_datetime(labels = function(t) format(t, "%l%P")) +
        facet_grid(dow~.) +
        theme_classic() +
        theme(strip.background = element_blank()) +
        xlab("Time") + ylab("Travel time (seconds)")

@

For the segment parameters, we assume a hierarchical model on the temporal location and width, with hyperparameters common across all segments in the network, while the magnitude will be independent for each segment. This leads to the following model:
\begin{equation}\label{eq:peak_effect_model}
\begin{split}
\mu_{\tau_{\ell,i}} &\sim \Normal{\mu_{\tau_i}}{\sigma_{\tau_i}}\\
\mu_{\omega_{\ell,i}} &\sim \Normal{\mu_{\omega_i}}{\sigma_{\omega_i}}.
\end{split}
\end{equation}

And then we fit the model using JAGS \citep{JAGS}.
