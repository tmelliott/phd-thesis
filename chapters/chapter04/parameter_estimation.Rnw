
\section{Estimating network parameters}
\label{sec:nw_par_est}

In order to optimise the \kf{}, it is necessary to estimate the main parameters in the model. These are the system noise, $\NWnoise_\ell$, which describes how volatile travel times throughout the network are over time, and the \emph{between-vehicle} variability $\NWvar_{\ellc}$.

In order to estimate values for $\NWnoise_\ell$ and $\NWvar_{\ellc}$, we need some data to which we can fit a full Bayesian model using the same model from \cref{sec:nw_model} but fitting it using \gls{mcmc} instead of the \kf{}.


The first model we fit, N1, uses the transition function
\begin{equation*}
\NWtransfun(\NWstate_{\ell c}) = \NWstate_{\ell c-1}.
\end{equation*}
We used JAGS \citep{JAGS} to fit the hierarchical model described above,
using the following values and priors:
\begin{equation}
\label{eq:nw_model_n1_priors}
\begin{split}
\NWmaxtt_\ell &= \Sexpr{floor(610/14)} \\
\NWstate_{\ell,0} &\sim \Normal{0}{100^2} \\
\NWvar_\ell^2 &\sim \Uniform{0}{1000} \\
\NWnoise^2 &\sim \GammaD{0.001}{0.001}
\end{split}
\end{equation}

The model implementation was completed within R
using the \verb+rjags+ package \citep{rjags},
and model output was processed and graphed
using the \verb+tidybayes+ package \citep{tidybayes}
and \verb+ggplot2+ \citep{ggplot2}.
Traceplots of the first eight $\NWstate$ parameters,
as well as for $\NWvar$ and $\NWnoise$ are displayed in \cref{fig:nw_model_n1_view}.

<<nw_model_n1_fit,cache=TRUE,echo=FALSE,message=FALSE>>=
library(rjags)
library(tidybayes)
library(ggplot2)

source("load_nw_data.R")

segdata <-
    list(
        b = tts$travel_time,
        t = as.integer(as.factor(t30)),
        delta = diff(sort(unique(as.integer(t30)))),
        N = nrow(tts),
        M = length(unique(t30)),
        mu = mu[1]
    )

# plot(t30, segdata$b)
# with(segdata, plot(sort(unique(t30))[t], b))

n1_model <- "
model {
    for (i in 1:N) {
        b[i] ~ dnorm(B[i], pow(E, -2))
        B[i] ~ dnorm(mu + beta[t[i]], pow(phi, -2))
    }

    beta[1] ~ dunif(0, 500)
    for (j in 2:M) {
        beta[j] ~ dnorm(beta[j-1], pow(delta[j-1] * q, -2))T(0,)
    }

    phi ~ dgamma(0.01, 0.01)
    q ~ dgamma(0.01, 0.01)
    E <- 3
}
"

t0 <- proc.time()
n1_fit <-
    jags.model(
        textConnection(n1_model),
        data = segdata,
        n.chains = 4,
        n.adapt = 10000,
        quiet = TRUE
    )

n1_samples <-
    coda.samples(n1_fit,
        variable.names = c("beta", "phi", "q"),
        n.iter = 5000,
        thin = 5
    )
time_mcmc <- proc.time() - t0
@

<<nw_model_n1_view,cache=TRUE,echo=FALSE,fig.height=9,fig.width=6,out.width="\\linewidth",fig.cap="Model output.">>=
egg::ggarrange(
    n1_samples %>% spread_draws(beta[t]) %>%
        filter(t < 9) %>%
        ggplot(aes(.iteration, beta, colour = as.factor(.chain), group = .chain)) +
            geom_path() +
            facet_wrap(~t, scales = "free", nrow = 4),

    n1_samples %>% spread_draws(phi) %>%
        ggplot(aes(.iteration, (phi), colour = as.factor(.chain), group = .chain)) +
            geom_path(),

    n1_samples %>% spread_draws(q) %>%
        ggplot(aes(.iteration, (q), colour = as.factor(.chain), group = .chain)) +
            geom_path(),

    # n1_samples %>% spread_draws(E) %>%
    #     ggplot(aes(.iteration, sqrt(E), colour = as.factor(.chain), group = .chain)) +
    #         geom_path(),

    ncol = 1, heights = c(2, 1, 1)
)
@

<<nw_model_n1_fitted,cache=TRUE,echo=FALSE,fig.height=3,fig.width=6,out.width="0.9\\linewidth",fig.cap="Travel times with fitted betas">>=

n1_samples %>%
    spread_draws(beta[t]) %>%
    sample_draws(n = 20) %>%
    #median_qi(beta) %>%
    mutate(timestamp = sort(unique(t30))[t]) %>%
    ggplot(aes(timestamp, segdata$mu + beta)) +
        geom_point(aes(arrival_time, travel_time),
            data = tts, col = "red") +
        geom_path(aes(group = .draw)) +
        geom_hline(yintercept = 43, lty = 2) +
        theme_classic() +
        xlab("Time") + ylab("Travel time (seconds)")
@

Fitting the model allowed us to estimate values for $\NWvar$ and $\NWnoise$
for a single road segment.
It is then possible to fit a \rt{} version of the same model to the same data
using these tuning parameters to see how well it performs.


<<nw_model_n1_kf,cache=TRUE,echo=FALSE,fig.height=3,fig.width=6,out.width="0.9\\linewidth",fig.cap="Travel times with KF fit">>=
source("load_nw_data.R")
N <- nrow(tts)
M <- length(unique(t30))
kf.fit <-
    tibble(
        time = sort(unique(t30)),
        delta = c(0, diff(sort(unique(t30)))),
        beta = rep(NA_real_, (M)),
        beta_hat = rep(NA_real_, (M)),
        P = rep(NA_real_, (M)),
        P_hat = rep(NA_real_, (M)),
        B_hat = 1 / P_hat,
        b_hat = beta_hat / P_hat,
        B = 1 / P,
        b = beta / P
    )

kf.fit$beta[1] <- n1_samples %>% spread_draws(beta[i]) %>%
    filter(i == 1) %>% median_qi() %>% pull(beta)
kf.fit$P[1] <- 500

q <- n1_samples %>% spread_draws(q) %>% median_qi() %>% pull(q)
phi <- n1_samples %>% spread_draws(phi) %>% median_qi() %>% pull(phi)
mu <- 43

# convert all data to information
kf.data <-
    tibble(
        time = t30,
        t = as.integer(as.factor(t30)),
        b = tts$travel_time - mu,
        E = 3.0
    ) %>% mutate(
        I = 1 / (E^2 + phi^2),
        i = b / (E^2 + phi^2)
    ) %>% arrange(t)

kf.fit <- kf.fit %>%
    left_join(
        kf.data %>% group_by(t) %>%
            summarize(time = first(time), Z = sum(I), z = sum(i)),
        by = "time"
    )

t0 <- proc.time()
for (i in 2:M) {
    # predict
    kf.fit$beta_hat[i] <- kf.fit$beta[i-1]
    kf.fit$P_hat[i] <- kf.fit$P[i-1] + (kf.fit$delta[i] + q)^2

    # update
    kf.fit$B_hat[i] <- 1 / kf.fit$P_hat[i]
    kf.fit$b_hat[i] <- kf.fit$beta_hat[i] / kf.fit$P_hat[i]
    kf.fit$B[i] <- kf.fit$B_hat[i] + kf.fit$Z[i]
    kf.fit$b[i] <- kf.fit$b_hat[i] + kf.fit$z[i]

    # untransform
    kf.fit$beta[i] <- kf.fit$b[i] / kf.fit$B[i]
    kf.fit$P[i] <- 1 / kf.fit$B[i]
}
time_kf <- proc.time () - t0

library(ggplot2)

ggplot(kf.fit[-1,], aes(time)) +
    geom_point(aes(y = mu + b), data = kf.data) +
    geom_ribbon(aes(
            ymin = mu + truncnorm::qtruncnorm(0.025, 0, Inf, beta_hat, sqrt(P_hat)),
            ymax = mu + truncnorm::qtruncnorm(0.975, 0, Inf, beta_hat, sqrt(P_hat))
        ),
        fill = "blue", alpha = 0.2) +
    geom_path(aes(y = mu + beta_hat), col = "blue") +
    geom_ribbon(aes(
            ymin = mu + truncnorm::qtruncnorm(0.025, 0, Inf, beta, sqrt(P)),
            ymax = mu + truncnorm::qtruncnorm(0.975, 0, Inf, beta, sqrt(P))
        ),
        fill = "red", alpha = 0.2) +
    geom_path(aes(y = mu + beta), col = "red") +
    theme_classic() +
    xlab("Time") + ylab("Travel time (seconds)")
@

<<nw_model_n1_kf_pred,cache=TRUE,echo=FALSE,fig.height=3,fig.width=6,out.width="0.9\\linewidth",fig.cap="Travel times predictive distribution from KF fit">>=
ggplot(kf.fit[-1,], aes(time)) +
    geom_point(aes(y = mu + b), data = kf.data) +
    # geom_ribbon(aes(
    #         ymin = mu + pmax(0, qnorm(0.025, beta_hat, sqrt(P_hat))),
    #         ymax = mu + qnorm(0.975, beta_hat, sqrt(P_hat))
    #     ),
    #     fill = "blue", alpha = 0.2) +
    # geom_path(aes(y = mu + beta_hat), col = "blue") +
    geom_ribbon(aes(
            ymin = mu + truncnorm::qtruncnorm(0.025, 0, Inf, beta, sqrt(P) + phi),
            ymax = mu + truncnorm::qtruncnorm(0.975, 0, Inf, beta, sqrt(P) + phi)
        ),
        fill = "red", alpha = 0.2) +
    geom_path(aes(y = mu + beta), col = "red") +
    theme_classic() +
    xlab("Time") + ylab("Travel time (seconds)")
@


\subsection{Simulated data}
\label{nw_par_est_sim}

\subsection{Real data}
\label{nw_par_est_real}

From \cref{fig:nw_model_n1_kf}, we see a fairly similar pattern
to the estimate of $\NWstate_{\ell,1:T}$,
although the peak estimation is less extreme
and slightly delayed.
The predictive travel time distribution,
which accounts for uncertainty in $\NWstate_{\ell c}$ and vehicle variation, $\NWvar_{\ell c}$,
is shown in \cref{fig:nw_model_n1_kf_pred}.
However, considering the \kf{} model is assuming constant travel time over time,
this makes sense,
as the \kf{} is a \emph{noise filtering} technique.


Most importantly is the timing comparison,
which is shown in \cref{tab:nw_model_n1_timecomp}.
The hierarchical model fit using JAGS took
\Sexpr{round(time_mcmc[3] / time_kf[3])} times as long as the \kf{} implementation.
So, even if we reduced the number of chains, the number of iterations,
and tried to speed up the JAGS model,
we would never get it close to the \kf{} result.

<<nw_model_n1_timecomp,echo=FALSE,results="asis">>=
kable(rbind(time_mcmc, time_kf)[,1:3],
    booktabs = TRUE,
    caption = "Timing results")
@

\kf{}'s can implement non-constant transitions between states,
for example by modifying $\NWtrans_c$ over time.


\subsubsection{Investigating a selection of road segments}

<<echo=FALSE>>=
Nseg <- "UNKNOWN"
@

To assess how effective this method is for estimating $\NWvar$ and $\NWnoise$, we selected five other road segments around Auckland and repeated the above process. However, instead of fitting the same model independently over segments,  we decided to use a hierarchical Bayesian model on the parameters, since it seems reasonable that, while they wont be the same over all segments, there will be an underlying population distribution. This will allow us to obtain estimates of the parameter values without explicitly needing to model every road (of which there are \Sexpr{Nseg}). Additionally, if we look at a graph of travel time versus variance (\cref{fig:tt_var_err}), we see that, on the log scale, these have a linear relationship.

<<tt_var_err,echo=FALSE,fig.width=6,fig.height=3,out.width="0.8\\textwidth",fig.align="center",fig.cap="Log transform of mean travel time and variance of travel time along all segments throughout the network.">>=
library(ggplot2)
source("load_nw_data.R")

tt_all %>% group_by(segment_id) %>%
    filter(travel_time > length / 30 & travel_time < length / 2) %>%
    summarize(tt = mean(travel_time), sd = sd(travel_time)) %>%
    filter(sd > 0) %>%
    ggplot() +
        geom_point(aes(tt, sd), na.rm = TRUE) +
        scale_x_log10() + scale_y_log10() +
        xlab("Mean travel time (seconds)") +
        ylab("Travel time variance (seconds)") +
        theme_classic()
@

To make use of the log-linear relationship, we fit the following hierarchical model to the travel time data across all segments, using the mean observed travel time $\bar\beta_\ell = \sum_c\sum_m b_{\ellc}^m$,
\begin{equation}\label{eq:tt_hist_hier}
\begin{split}
\Vttobs_{\ellc}^m &\sim \Normal{\Vtt_{\ellc}^m}{\left(\Vtterr_{\ellc}^m\right)^2} \\
\Vtt_{\ellc}^m &\sim \Normal{\NWstate_{\ellc}}{\NWvar_{\ell}^2} \\
\NWstate_{\ellc} &\sim \Normal{\NWstate_{\ellc-1}}{\NWnoise_{\ell}^2} \\
\NWstate_{\ell0} &\sim \Normal{\mu_\ell}{100^2} \\
\NWvar_{\ell} &\sim \Normal{\theta_0 + \theta_1\log\left(\bar\beta_\ell\right)}{\sigma_\phi^2}
\end{split}
\end{equation}
and the parameters $\theta_0$, $\theta_1$, $\sigma_\phi^2$, $\mu_q$, and $\sigma_q^2$ were all given noninformative priors. The travel time data for five segments is shown in \cref{fig:nw_model_n2_segplots}.

<<nw_model_n2_segplots,echo=FALSE,cache=TRUE,fig.width=6,fig.height=9,out.width="0.8\\textwidth",fig.cap="Travel times along 5 roads throughout Auckland.">>=
library(ggplot2)
source("load_nw_data.R")

ggplot(tt_all %>% filter(segment_id %in% sids), aes(arrival_time, travel_time)) +
    geom_point() +
    facet_wrap(~paste("Segment ID:", segment_id), scales = "free_y", ncol = 1) +
    theme_classic() +
    theme(strip.background = element_blank()) +
    xlab("Time") + ylab("Travel time (seconds)")
@

<<nw_model_nw_jagsfits,echo=FALSE,cache=TRUE>>=
source("load_nw_data.R")
suppressPackageStartupMessages({
    library(dplyr)
    library(rjags)
    library(tidybayes)
    library(ggplot2)
})

model.jags <- "
model{
    for (i in 1:N) {
        b[i] ~ dnorm(B[i], pow(e[i], -2))
        B[i] ~ dnorm(mu[ell[i]] + beta[c[i]], pow(phi[ell[i]], -2))
    }

    for (l in 1:L) {
        beta[c0[l]] ~ dunif(0, 500)
        for (j in c1[l]:cJ[l]) {
            beta[j] ~ dnorm(beta[j-1], pow(delta[j] * q[l], -2))
        }

        # log(phi) = theta0 + theta1 * log(mu) + err
        phi[l] <- exp(log_phi[l])
        log_phi[l] ~ dnorm(log_mu_phi_ell[l], pow(sig_phi, -2))
        log_mu_phi_ell[l] <- theta[1] + theta[2] * log(mu[l])


        q[l] ~ dnorm(mu_q, pow(sig_q, -2))T(0,)
        #log_q[l] ~ dnorm(log_mu_q, pow(sig_q, -2))
        #eq[l] <- exp(log_q[l])
        #q[l] <- pow(eq[l], 2)
    }

    theta[1] ~ dnorm(0, 0.01)
    theta[2] ~ dnorm(1, 0.01)
    sig_phi ~ dgamma(0.001, 0.001)

    mu_q <- exp(log_mu_q)
    log_mu_q ~ dnorm(0, 0.01)
    sig_q ~ dgamma(0.001, 0.001)
}
"

jm <-
    jags.model(textConnection(model.jags),
        quiet = TRUE,
        data = jdata,
        n.chains = 4,
        n.adapt = 10000
    )

n1_samples <-
    coda.samples(jm,
        variable.names = c("beta", "phi", "q", "theta", "sig_phi", "mu_q", "sig_q"),
        n.iter = 5000,
        thin = 5
    )

save(n1_samples, file = "hier_model_samples.rda")
@

<<nw_model_n2_diag,cache=TRUE,echo=FALSE,fig.width=8,fig.height=9,out.width="\\textwidth",fig.cap="Traceplots of top-level network parameters.">>=
source("load_nw_data.R")
load("hier_model_samples.rda")

pmin <- ggplot(NULL, aes(x = .iteration, colour = as.factor(.chain), group = .chain)) +
    xlab("Iteration") +
    theme_classic() +
    theme(legend.position = "none")

egg::ggarrange(
    pmin +
        geom_path(aes(y = theta),
            data = n1_samples %>% spread_draws(theta[k]) %>% filter(k == 1)
        ) +
        ylab(expression(theta[0])),
    pmin +
        geom_path(aes(y = theta),
            data = n1_samples %>% spread_draws(theta[k]) %>% filter(k == 2)
        ) +
        ylab(expression(theta[1])),
    pmin +
        geom_path(aes(y = sig_phi),
            data = n1_samples %>% spread_draws(sig_phi)
        ) +
        ylab(expression(sigma[phi])),
    pmin +
        geom_path(aes(y = mu_q),
            data = n1_samples %>% spread_draws(mu_q)
        ) +
        ylab(expression(mu[q])),
    pmin +
        geom_path(aes(y = sig_q),
            data = n1_samples %>% spread_draws(sig_q)
        ) +
        ylab(expression(sigma[q])),
    ncol = 1
)
@

<<nw_model_n2_diag_2,cache=TRUE,echo=FALSE,fig.width=8,fig.height=9,out.width="\\textwidth",fig.cap="Traceplots of network parameters for each segment.">>=
source("load_nw_data.R")
load("hier_model_samples.rda")

pmin <- ggplot(NULL, aes(x = .iteration, colour = as.factor(.chain), group = .chain)) +
    xlab("Iteration") +
    theme_classic() +
    theme(legend.position = "none", strip.background = element_blank())

egg::ggarrange(
    pmin +
        geom_path(aes(y = phi),
            data = n1_samples %>% spread_draws(phi[l])
        ) +
        ylab(expression(phi[l])) +
        facet_wrap(l~., scales = "free_y", ncol = 1),
    pmin +
        geom_path(aes(y = q),
            data = n1_samples %>% spread_draws(q[l])
        ) +
        ylab(expression(q[l])) +
        facet_wrap(l~., scales = "free_y", ncol = 1),
    ncol = 2
)

@

<<nw_model_n2_resfits,cache=TRUE,echo=FALSE,fig.width=6,fig.height=9,out.width="0.8\\textwidth",fig.cap="Sample of posterior fits to segment travel times.">>=
source("load_nw_data.R")
load("hier_model_samples.rda")
library(ggplot2)
library(tidybayes)

betas <- n1_samples %>% spread_draws(beta[i]) %>%
    sample_draws(n = 20) %>%
    # median_qi() %>%
    mutate(
        l = tapply(jdata$ell, jdata$c, min)[i],
        t = jdata_t[i],
        mu = jdata$mu[l]
    )

ggplot(betas) +
    # geom_ribbon(aes(t, ymin = mu + .lower, ymax = mu + .upper)) +
    geom_path(aes(t, mu + beta, group = .draw)) +
    geom_point(aes(timestamp, travel_time),
        data = segdat,
        colour = "red", size = 0.5) +
    facet_wrap(~l, scales = "free_y", ncol = 1) +
    theme_classic() +
    theme(strip.background = element_blank()) +
    xlab("Time") + ylab("Travel time (seconds)")
@


The models were fitted, etc etc.

To evaluate, travel time data from the following week, shown in \cref{fig:tt_future_day}, were modelled using a \kf{} implementation of the model.

<<tt_future_day,echo=FALSE,fig.height=9,fig.width=6,fig.align="center",out.width=".8\\linewidth",fig.cap="Travel times along a road one week in the future.">>=
library(ggplot2)
source("load_nw_data.R")
date0 <- tt_all$arrival_time[1] %>% format("%Y-%m-%d")
bind_rows(tt_all, tt_future) %>%
    filter(segment_id %in% sids) %>%
    mutate(
        date = as.factor(format(arrival_time, "%Y-%m-%d")),
        time = as.POSIXct(paste(date0, format(arrival_time, "%H:%M:%S")))
    ) %>%
    ggplot() +
        geom_point(aes(time, travel_time)) +
        facet_grid(segment_id ~ date, scales = "free") +
        scale_x_datetime(labels = function(x) format(x, "%H:%M:%S")) +
        theme_classic() +
        theme(strip.background = element_blank()) +
        xlab("Time") + ylab("Travel time (seconds)")

@



<<nw_model_n2_kf,echo=FALSE,cache=TRUE,fig.width=8,fig.height=9,out.width="\\textwidth",fig.cap="Kalman filter results from real-time fitting, showing travel time estimate (left) and posterior predictive travel time (right).">>=
do.call(egg::ggarrange, c(
    do.call(c, lapply(seq_along(all.fits), function(i) {
        tts <- data.list[[i]]
        t30 <- attr(tts, "t30")
        n1_samples <- all.fits[[i]]

        N <- nrow(tts)
        M <- length(unique(t30))
        kf.fit <-
            tibble(
                time = sort(unique(t30)),
                delta = c(0, diff(sort(unique(t30)))),
                beta = rep(NA_real_, (M)),
                beta_hat = rep(NA_real_, (M)),
                P = rep(NA_real_, (M)),
                P_hat = rep(NA_real_, (M)),
                B_hat = 1 / P_hat,
                b_hat = beta_hat / P_hat,
                B = 1 / P,
                b = beta / P
            )

        kf.fit$beta[1] <- mean(as.matrix(n1_samples)[,"beta[1]"])
        kf.fit$P[1] <- 500

        q <- sqrt(mean(as.matrix(n1_samples)[,"q"]))
        phi <- sqrt(mean(as.matrix(n1_samples)[,"phi"]))
        mu <- attr(tts, "mu")

        # convert all data to information
        kf.data <-
            tibble(
                time = t30,
                t = as.integer(as.factor(t30)),
                b = tts$travel_time - mu,
                E = 3.0
            ) %>% mutate(
                I = 1 / (E^2 + phi^2),
                i = b / (E^2 + phi^2)
            ) %>% arrange(t)

        kf.fit <- kf.fit %>%
            left_join(
                kf.data %>% group_by(t) %>%
                    summarize(time = first(time), Z = sum(I), z = sum(i)),
                by = "time"
            )

        t0 <- proc.time()
        for (i in 2:M) {
            # predict
            kf.fit$beta_hat[i] <- kf.fit$beta[i-1]
            kf.fit$P_hat[i] <- kf.fit$P[i-1] + (kf.fit$delta[i] + q)^2

            # update
            kf.fit$B_hat[i] <- 1 / kf.fit$P_hat[i]
            kf.fit$b_hat[i] <- kf.fit$beta_hat[i] / kf.fit$P_hat[i]
            kf.fit$B[i] <- kf.fit$B_hat[i] + kf.fit$Z[i]
            kf.fit$b[i] <- kf.fit$b_hat[i] + kf.fit$z[i]

            # untransform
            kf.fit$beta[i] <- kf.fit$b[i] / kf.fit$B[i]
            kf.fit$P[i] <- 1 / kf.fit$B[i]
        }
        time_kf <- proc.time () - t0

        library(ggplot2)

        list(
            # n1_samples %>%
            #     spread_draws(beta[t]) %>%
            #     sample_draws(n = 20) %>%
            #     #median_qi(beta) %>%
            #     mutate(timestamp = sort(unique(t30))[t]) %>%
            #     ggplot(aes(timestamp, mu + beta)) +
            #         geom_point(aes(arrival_time, travel_time),
            #             data = tts, col = "red") +
            #         geom_path(aes(group = .draw)) +
            #         geom_hline(yintercept = mu, lty = 2) +
            #         theme_classic() +
            #         xlab("Time") + ylab("Travel time (seconds)"),

            ggplot(kf.fit[-1,], aes(time)) +
                geom_point(aes(y = mu + b), data = kf.data) +
                geom_ribbon(aes(
                        ymin = mu + truncnorm::qtruncnorm(0.025, 0, Inf, beta_hat, sqrt(P_hat)),
                        ymax = mu + truncnorm::qtruncnorm(0.975, 0, Inf, beta_hat, sqrt(P_hat))
                    ),
                    fill = "blue", alpha = 0.2) +
                geom_path(aes(y = mu + beta_hat), col = "blue") +
                geom_ribbon(aes(
                        ymin = mu + truncnorm::qtruncnorm(0.025, 0, Inf, beta, sqrt(P)),
                        ymax = mu + truncnorm::qtruncnorm(0.975, 0, Inf, beta, sqrt(P))
                    ),
                    fill = "red", alpha = 0.2) +
                geom_path(aes(y = mu + beta), col = "red") +
                theme_classic() +
                xlab("Time") + ylab("Travel time (seconds)"),

            ggplot(kf.fit[-1,], aes(time)) +
                geom_point(aes(y = mu + b), data = kf.data) +
                geom_ribbon(aes(
                        ymin = mu + truncnorm::qtruncnorm(0.025, 0, Inf, beta, sqrt(P) + phi),
                        ymax = mu + truncnorm::qtruncnorm(0.975, 0, Inf, beta, sqrt(P) + phi)
                    ),
                    fill = "red", alpha = 0.2) +
                geom_path(aes(y = mu + beta), col = "red") +
                theme_classic() +
                xlab("Time") + ylab("Travel time (seconds)")
        )
    })),
    ncol = 2
))
@

For most of them, despite a range of features,
the JAGS-estimated values of $\NWvar$ and $\NWnoise$ were well suited
for the \rt{} \kf{} implementation.
The traceplots are shown in \cref{fig:nw_model_n2_diag},
and a posterior sample of $\NWstate_{1:C}$ is shown in \cref{fig:nw_model_n2_resfits}.
For all segments, $\NWvar$ was sampled well;
however, $\NWnoise$ often had difficulties due to the zero-boundary.


We then took the posterior mean from the JAGS samples to estimate values
for $\NWvar$ and $\NWnoise$ for each segment,
and fit the \rt{} \kf{} as before.
\Cref{fig:nw_model_n2_kf} shows the estimates of
the predicted and updated network state and associated variances,
along with the predictive distribution (mean + uncertainty + between vehicle noise).


A better examination, however, is to look at data from a different day
for the same segment.

Should try fitting a single value of q and only estimate psi.

