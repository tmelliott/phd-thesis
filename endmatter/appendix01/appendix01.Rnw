\chapter{Weighted resampling}
\label{app:weighted-resampling}

Part of the particle filter update step is to, when required, resample the particles according to their weights. First, however, we will describe weighted resampling. Given a sample of size $N$, we use a \gls{rng} to obtain uniform numbers $u \in (0, 1)$. Since each particle has equal weight, we multiply $u$ by $N$ and round down (using the \emph{floor} function), so get
\begin{equation}
j = \lfloor uN \rfloor.
\end{equation}
Thus, we have sampled particle $j$.


When the particles are weighted, however, we cannot simply use $uN$. For example, here we have five particles, where each is represented by a rectangle whose width is equal to the particle's weight (the total weight is unity), as shown in \cref{fig:app_weighted_resampling}.
<<app_weighted_resampling,echo=FALSE,fig.width=9,fig.height=1,out.width="0.8\\textwidth",fig.align="center",fig.cap="Particle weights.",fig.pos="h">>=
set.seed(15)
N <- 5
w <- diff(c(0, sort(runif(N - 1)), 1))
wr <- cumsum(w)
wl <- c(0, wr[-N])
wc <- wl + (wr - wl) / 2
par(mar = c(0.1, 0.1, 0.1, 0.1))
plot.new()
plot.window(xlim = c(0, 1), ylim = c(-0.5, 1), xaxs = "i", yaxs = "i")
rect(wl + 0.005, 0.25, wr - 0.005, 0.75, col = "lightgray")
text(wc, 0, 1:N, cex = 1)
@

As before, we use a \gls{rng} to obtain a uniform random number $u$; to map the number to a particle, we compute \emph{cumulative weights} and find the maximum weight less than $u$:
\begin{equation}
j : \sum_{i=1}^j w\vi[j] \leq u.
\end{equation}

Optionally, the particles could be sorted in order of decreasing weight, as below. This reduces computation times since $j$ will, on average, be much smaller, particularly if a small number of particles constitute most of the weight.
<<app_weighted_resampling_sorted,echo=FALSE,fig.width=9,fig.height=1,out.width="0.8\\textwidth",fig.align="center",fig.cap="Particle weights in decreasing order.",fig.pos="h">>=
w <- sort(w, decreasing = TRUE)
wr <- cumsum(w)
wl <- c(0, wr[-N])
wc <- wl + (wr - wl) / 2
par(mar = c(0.1, 0.1, 0.1, 0.1))
plot.new()
plot.window(xlim = c(0, 1), ylim = c(-0.5, 1), xaxs = "i", yaxs = "i")
rect(wl + 0.005, 0.25, wr - 0.005, 0.75, col = "lightgray")
text(wc, 0, 1:N, cex = 1)
@


It is important to note that, although sorting the particles does reduce the time taken to find each particle, the sorting operation is of computational complexity $\mathcal{O}(N\log N)$.
To demonstrate, here is a simple Rcpp program which optionally sorts the particles.
<<app_weighted_program>>=
library(Rcpp)
N <- 10000
w <- diff(c(0, sort(runif(N - 1)), 1))
u <- runif(N)
cppFunction("std::vector<int> resample (NumericVector w, NumericVector u, int r, int Nstar)
{
    std::vector<double> wts = as<std::vector<double> > (w);
    std::vector<double> uu = as<std::vector<double> > (u);
    if (r) std::sort(wts.begin (), wts.end ());
    std::vector<int> jj;
    int N (wts.size ());
    jj.resize (Nstar);
    double wi;
    int j;
    for (int i=0; i<Nstar; ++i)
    {
        wi = 0.0;
        j = 0;
        while (wi <= uu.at (i)) wi += wts.at (j++);
        jj.at (i) = j;
    }
    return jj;
}
"
)

# full resample
system.time(resample(w, u, 0, N))
system.time(resample(w, u, 1, N))

# partial resample (i.e., for ETAs)
system.time(resample(w, u, 0, 200))
system.time(resample(w, u, 1, 200))

# inequal weights
N1 <- floor(0.95 * N)
N2 <- N - N1
r1 <- runif(N1, 0, 0.5)
r2 <- runif(N2, 0.5, 1)
w <- diff(c(0, sort(c(r1, r2))), 1)
u <- runif(N)

system.time(resample(w, u, 0, N))
system.time(resample(w, u, 1, N))
@
